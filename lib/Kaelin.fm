T Kaelin.Sprite
| Kaelin.Sprite.new(pos: Pos32, ang: U32, vox: VoxModel);

//Kaelin.renderer(model: VoxModel): App(U32)
  //get size buffer = model
  //let vox = VoxModel.alloc_size(size)
  //def init
    //0u
  //def draw(state)
    //App.Render.vox
    //| use idx vox = U32.for<>(vox, 0u, size)
      //let pos = VoxModel.get_pos(idx, model)
      //let p_x = Pos32.get_x(pos)
      //let p_y = Pos32.get_y(pos)
      //let p_z = Pos32.get_z(pos)
      //get p_x p_y = Kaelin.rotate2d(128u, 128u, p_x, p_y, state)
      //let p_x = U32.sub(p_x, U32.div(p_z, 2u))
      //let p_y = U32.sub(p_y, U32.div(p_z, 2u))
      //let pos = Pos32.new(p_x, p_y, p_z)
      //let vox = VoxModel.set_pos(idx, pos, vox)
      //let vox = VoxModel.set_col(idx, VoxModel.get_col(idx, model), vox)
      //vox;
  //def when(event, state)
    //case event:
    //| U32.add(state, 1u);
    //| state;
    //| state;
  //App.new<>(init, draw, when)

Kaelin.rotate2d(cx: U32, cy: U32, x: U32, y: U32, a: U32): Pair(U32, U32)
  let x = F64.sub(U32.to_f64(x), U32.to_f64(cx))
  let y = F64.sub(U32.to_f64(y), U32.to_f64(cy))
  let a = F64.mul(F64.div(U32.to_f64(a), 360.0), F64.tau)
  get x y = F64.rotate2d(x, y, a)
  Pair.new<,>(U32.add(F64.to_u32(x), cx), U32.add(F64.to_u32(y), cy))

Kaelin.draw(sprites: List(Kaelin.Sprite), screen: VoxModel): VoxModel
  def nil
    Pair.new<,>(0u, screen)
  def cons(sprite, state)
    get idx screen = state
    get sprite_pos sprite_ang sprite_vox = sprite
    let voxel_count = VoxModel.get_size(sprite_vox)
    for i : U32 = 0u .. voxel_count with screen:
      let pos = VoxModel.get_pos(i, sprite_vox)
      let p_x = Pos32.get_x(pos)
      let p_y = Pos32.get_y(pos)
      let p_z = Pos32.get_z(pos)
      get p_x p_y = Kaelin.rotate2d(128u, 128u, p_x, p_y, sprite_ang)
      let p_x = U32.add(U32.sub(p_x, U32.div(p_z, 2u)), Pos32.get_x(sprite_pos))
      let p_y = U32.add(U32.sub(p_y, U32.div(p_z, 2u)), Pos32.get_y(sprite_pos))
      let p_z = U32.add(p_z, Pos32.get_z(sprite_pos))
      let pos = Pos32.new(p_x, p_y, p_z)
      let screen
        = VoxModel.set_pos
        | U32.add(i,idx);
        | pos;
        | screen;
      let screen
        = VoxModel.set_col
        | U32.add(i,idx);
        | VoxModel.get_col(i,sprite_vox);
        | screen;
      screen
    Pair.new<,>(U32.add(voxel_count, idx), screen)
  let fold = List.fold<Kaelin.Sprite>(sprites)
  get idx screen = fold<Pair(U32,VoxModel)>(nil, cons)
  screen
  
Kaelin: App(U32)
  let wall = Kaelin.Models.wall
  let chest = Kaelin.Models.chest
  let seat = Kaelin.Models.seat
  let screen = VoxModel.alloc_size(524288u)
  def init
    0u
  def draw(state)
    let sprites = [
      Kaelin.Sprite.new(Pos32.new(0u,0u,0u), state, wall),
      Kaelin.Sprite.new(Pos32.new(32u,0u,0u), state, chest),
      //Kaelin.Sprite.new(Pos32.new(64u,0u,0u), state, seat),
    ]
    App.Render.vox(Kaelin.draw(sprites, screen))
  def when(event, state)
    case event:
    | init => [
      App.Action.watch<>("0x000000000000")
    ];
    | tick => [];
    | xkey =>
      if event.down then
        [ App.Action.post<>
          | "0x000000000000";
          | "0x4440000000000000000000000000000000000000000000000000000000000000000000000444";
        ]
      else
        [];
    | post => [
      App.Action.state<>(U32.add(state, 4u))
    ];
  App.new<>(init, draw, when)
