// TODO add more skills
T Mons.Skill
| Mons.Skill.hit_4;
| Mons.Skill.hit_2;
| Mons.Skill.heal;
| Mons.Skill.none;
| Mons.Skill.dig;
| Mons.Skill.sand_tomb;
| Mons.Skill.protect;
| Mons.Skill.slam;
| Mons.Skill.counter;
| Mons.Skill.recover;
| Mons.Skill.rock_smash;
| Mons.Skill.crunch;
| Mons.Skill.sludge_bomb;
| Mons.Skill.gyro_ball;
| Mons.Skill.iron_defense;
| Mons.Skill.super_fang;
| Mons.Skill.hypnosis;
| Mons.Skill.dream_eater;
| Mons.Skill.wing_attack;
| Mons.Skill.moonlight;
| Mons.Skill.play_rough;
| Mons.Skill.psychic;
| Mons.Skill.ancient_power;
| Mons.Skill.thunder_wave;
| Mons.Skill.charge;
| Mons.Skill.agility;
| Mons.Skill.hero_kill;

Mons.Skill.description(skill: Mons.Skill): String
  case skill:
  | hit_4 => "damage 4"; // test
  | hit_2 => "damage 2"; // test
  | heal => "heal 3"; // test
  | none => "does nothing"; // test
  | dig => "Protect for 1 turn. On the next turn, will attack and effects are applied";
  | sand_tomb => "Apply an initial dmg and +1/16 of MPH for 5 turns";
  | protect => "Avoid dmg on the next turn. Cannot be used on every turn.";
  | slam => "Damage";
  | counter => "Double the last damage that the adve received (dismiss effects)";
  | recover => "Restore 50% of mhp";
  | rock_smash => "Apply a medium damage(4) + 50% of critical";
  | crunch => "Apply a high damage(6) + 25% of critical";
  | sludge_bomb => "Damage and 30% of poisoning";
  | gyro_ball => "Apply medium damage (4). If this Mon has 'agi' faster than the adve, increase damage by 50%";
  | iron_defense => "Increase defense for 2 turns, including the current one";
  | super_fang => "Damage adve with 50% of current life then loses 25% of hp";
  | hypnosis => "Apply sleep to adve";
  | dream_eater => "Will only damage if adve is sleep. Will damage adve and heal 50% of the dmg";
  | wing_attack => "Damage";
  | moonlight => "Damage and 20% of sleep";
  | play_rough => "Damage and 20% of reduce damage";
  | psychic => "Damage and 10% of reduce damage and apply confusion";
  | ancient_power => "Damage and 10% of adve miss the attack";
  | thunder_wave => "Damage";
  | charge => "Double the damage of the next ellectric attack";
  | agility => "Invert Mon's agitity value";
  | hero_kill => "Herro atk";


Mons.Skill.get_name(skill: Mons.Skill): String
  case skill:
  | hit_4  => "hit 4";
  | hit_2  => "hit 2";
  | heal   => "heal"; 
  | none => "none";
  | dig => "Dig";
  | sand_tomb => "Sand bomb";
  | protect => "Protect";
  | slam => "Slam";
  | counter => "Counter";
  | recover => "Recover";
  | rock_smash => "Rock Smash";
  | crunch => "Crunch";
  | sludge_bomb => "Sludge bomb";
  | gyro_ball => "Gyro Ball";
  | iron_defense => "Iron Defense";
  | super_fang => "Super Fang";
  | hypnosis => "Hypnosis";
  | dream_eater => "Dream Eater";
  | wing_attack => "Wing Attack";
  | moonlight => "Moonlight";
  | play_rough => "Play Rough";
  | psychic => "Psychic";
  | ancient_power => "Ancient Power";
  | thunder_wave => "Thunder Wave";
  | charge => "Charge";
  | agility => "Agility";
  | hero_kill => "Hero kill";

Mons.Skill.update_mon_obj(
  hero_obj: Mons.Object,
  obj_updated: Mons.Object,
  pos: Pos32,
  idx: U32,
  game: Mons.Game) : Mons.Game
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then
    Mons.Game.map_set(pos, idx, obj_updated, game) // hero_obj
  else //game
    let idx_nat = U32.to_nat(hero_obj.mon)
    let new_bag = List.update_at<>(idx_nat, (a) obj_updated, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj) 
    Mons.Game.map_set(pos, idx, hero_obj, game)

// At the beginning of the game, apply and update effect: 
// burn and hit
Mons.Skill.apply_inital_eff(hero_idx: U32, adve_idx: U32, pos: Pos32, game: Mons.Game): Mons.Game
  let game = Mons.Skill.apply_inital_eff_hero(hero_idx, pos, game)
  Mons.Skill.apply_inital_eff_adve(adve_idx, pos, game)


Mons.Skill.apply_inital_eff_hero(hero_idx: U32, pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let hero_obj = Mons.Map.get(pos, hero_idx, game.map)
  let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
  open hero_mon_obj:
  open Mons.Kind.attr(hero_mon_obj.kin) as hero_mon_attr:
  // BUG: effects in the player's Mon are not updated
  // let hero_mon_obj = //pos: Pos32, hero_idx: U32, adve_idx: U32, game: Mons.Game
    // if Bool.or(Mons.Effect.has_swap_agi(hero_mon_obj.eff), Mons.Effect.has_swap_agi(adve_mon.eff)) 
    // then
    //   Mons.Skill.invert_agility(pos, hero_idx, adve_idx, game)
    // else
  let upd_effect = Mons.Effect.upd_initial_eff(hero_mon_obj.eff)
  let hero_mon_obj = Mons.Object.set_eff(upd_effect, hero_mon_obj)
  let game = Mons.Skill.update_mon_obj(hero_obj, hero_mon_obj, pos, hero_idx, game)
  // Only damage is taken
  let hero_dmg = Mons.Skill.apply_inital_eff_dmg(hero_mon_obj.eff, hero_mon_attr.mhp, hero_idx)
  let game = Mons.Skill.damage_eff(hero_obj, pos, hero_idx, hero_dmg, game)
  
  game

Mons.Skill.apply_inital_eff_adve(adve_idx: U32, pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let adve_obj = Mons.Map.get(pos, adve_idx, game.map)
  open adve_obj:
  open Mons.Kind.attr(adve_obj.kin) as adve_attr:
  let adve_dmg = Mons.Skill.apply_inital_eff_dmg(adve_obj.eff, adve_attr.mhp, adve_idx)
  let upd_effect = Mons.Effect.upd_initial_eff(adve_obj.eff)
  let adve_obj = Mons.Object.set_eff(upd_effect, adve_obj)
  let game = Mons.Skill.damage_eff(adve_obj, pos, adve_idx, adve_dmg, game)
  game

Mons.Skill.apply_inital_eff_dmg(eff: Mons.Effect, mhp: U32, idx: U32): U32 // idx is used for testing
  open eff:
  let poison = if eff.poison then "poison" else "no poison"
  use skp = Debug.log<>(String.flatten(["\n", U32.to_string(idx), " Poison? ", poison]))
  let poison = if eff.poison then "sleep" else "no sleep"
  use skp = Debug.log<>(String.flatten(["\n", U32.to_string(idx), " Sleep? ", poison]))
  if Mons.Effect.has_invulnerable(eff) then 0u
  else
    let dmg_burn = if Mons.Effect.has_burn(eff) then U32.div(mhp, 16u) else 0u
    let dmg_hit = if Mons.Effect.has_hit(eff) then eff.hit else 0u
    let dmg_poison = if Mons.Effect.has_poison(eff) then U32.div(mhp, 16u) else 0u
    let dmg = U32.add(dmg_poison, U32.add(dmg_burn, dmg_hit))
    use skp = Debug.log<>(String.flatten(["  DMG to take: ", U32.to_string(dmg)]))
    dmg 


// After casting the skills, update effects used during the cast: 
// sleep, protect, minimize and invulnerable
Mons.Skill.apply_end_turn_eff(hero_idx: U32, adve_idx: U32, pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let hero_obj = Mons.Map.get(pos, hero_idx, game.map)
  let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
  let adve_obj = Mons.Map.get(pos, adve_idx, game.map)

  open hero_mon_obj:
  let eff_upd = Mons.Effect.upd_end_turn_eff(hero_mon_obj.eff) 
  let hero_mon_obj = Mons.Object.set_eff(eff_upd, hero_mon_obj)
  let game = Mons.Skill.update_mon_obj(hero_obj, hero_mon_obj, pos, hero_idx, game)

  open adve_obj:
  let upd_effect = Mons.Effect.upd_end_turn_eff(adve_obj.eff)
  let adve_obj = Mons.Object.set_eff(upd_effect, adve_obj)
  let game = Mons.Game.map_set(pos, adve_idx, adve_obj, game)
  game


Mons.Skill.clear_after_battle(hero_idx: U32, adve_idx: U32, pos: Pos32, game: Mons.Game): Mons.Game
  use skp = Debug.log<>(">> Clear after battle")
  open game:
  let hero_obj = Mons.Map.get(pos, hero_idx, game.map)
  let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
  let adve_obj = Mons.Map.get(pos, adve_idx, game.map)
  // Clear effects and update Mons 
  let hero_mon_obj = Mons.Object.set_eff(Mons.Effect.clear, hero_mon_obj)
  let game = Mons.Skill.update_mon_obj(hero_obj, hero_mon_obj, pos, hero_idx, game)
  let adve_obj = Mons.Object.set_eff(Mons.Effect.clear, adve_obj)
  let game = Mons.Game.update_obj(adve_obj, pos, adve_idx, game)
  game

// Add damage to a Mon. Consider effects of invulnerable, protect and minimize before damaging
Mons.Skill.damage_eff(obj: Mons.Object, pos: Pos32, idx: U32, dmg: U32, game: Mons.Game): Mons.Game
  let obj_mon = Mons.Object.get_current_mon(obj)
  open obj_mon:
  if Mons.Effect.has_invulnerable(obj_mon.eff) then game
  else
    let dmg = if Mons.Effect.has_protect(obj_mon.eff)  then U32.div(dmg, 2u) else dmg // - 50%
    let dmg = if Mons.Effect.has_minimize(obj_mon.eff) then U32.sub(dmg, U32.div(dmg, 4u)) else dmg // - 25%
    // use skp = Debug.log<>(String.flatten(["Dmg eff:", U32.to_string(dmg), " idx:", U32.to_string(idx)]))
    let obj_mon = Mons.Object.hit(obj_mon, dmg)
    Mons.Skill.update_mon_obj(obj, obj_mon, pos, idx, game)

Mons.Skill.heal_eff(obj: Mons.Object, pos: Pos32, idx: U32, val: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Object.heal(Mons.Object.get_current_mon(obj), val)
  if Mons.Object.is_obj_defeated(obj_updated) then game
  else Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

// Secondary effects
// ------
Mons.Skill.invulnerable_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Effect.set_invulnerable(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.hit_next_eff(obj: Mons.Object, val: U32, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_hit(Mons.Object.get_current_mon(obj), val)
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.burn_eff(obj: Mons.Object, pos: Pos32, idx: U32, turns: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_burn(Mons.Object.get_current_mon(obj), turns)
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

// turn 1u: available this turn
// turn 2u: available next turn
Mons.Skill.protect_eff(obj: Mons.Object, pos: Pos32, idx: U32, turn: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_protect(Mons.Object.get_current_mon(obj), turn)
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.poison_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_poison(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.minimize_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_minimize(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.sleep_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Effect.set_sleep(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.Skill.swap_agi_eff(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  def obj_updated = Mons.Effect.set_swap_agi(Mons.Object.get_current_mon(obj))
  Mons.Skill.update_mon_obj(obj, obj_updated, pos, idx, game)

// Invert hero and adve agi values
Mons.Skill.invert_agility(pos: Pos32, hero_idx: U32, adve_idx: U32, game: Mons.Game): Mons.Game
  open game:
  def hero_obj = Mons.Map.get(pos, hero_idx, game.map)
  def adve_obj = Mons.Map.get(pos, adve_idx, game.map)
  let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
  let adve_mon_obj = Mons.Object.get_current_mon(adve_obj)
  open hero_mon_obj:
  open adve_mon_obj:
  let hero_agi = Mons.Kind.get_agi(hero_mon_obj.kin)
  let adve_agi = Mons.Kind.get_agi(adve_mon_obj.kin)

  let new_hero_kind = Mons.Kind.update_agi(hero_mon_obj.kin, adve_agi)
  let upd_hero_mon_obj = Mons.Object.set_kin(hero_mon_obj, new_hero_kind)
  let game = Mons.Skill.update_mon_obj(hero_obj, upd_hero_mon_obj, pos, hero_idx, game)

  let new_adve_kind = Mons.Kind.update_agi(adve_mon_obj.kin, hero_agi)
  let upd_adve_mon_obj = Mons.Object.set_kin(hero_mon_obj, new_adve_kind)
  let game = Mons.Skill.update_mon_obj(adve_obj, upd_adve_mon_obj, pos, adve_idx, game)
  game

// pos    : position of the map in which the battle is taking place
// source : index of the object which is casting a skill
// target : index of the object which is receiving the effect 
Mons.Skill.cast(pos: Pos32, source: U32, target: U32, skill: Mons.Skill, game: Mons.Game): Mons.Game 
  open game:
  def source_obj = Mons.Map.get(pos, source, game.map)
  def source_mon = Mons.Object.get_current_mon(source_obj)
  def target_obj = Mons.Map.get(pos, target, game.map)
  def target_mon = Mons.Object.get_current_mon(target_obj)

  // Note: attr referes to the mon that the object can have
  // damage_eff and heal_eff updates the hp of the mon
  open source_mon:
  open target_mon:
  open Mons.Kind.attr(source_mon.kin) as source_mon_attr:
  open Mons.Kind.attr(target_mon.kin) as target_mon_attr:
  // use skp = Debug.log<>(String.flatten(["Cast hp: ", U32.to_string(source_mon.dmg)]))
  let light_val = 2u
  let medium_val = 4u
  let high_val = 6u

  let can_attack = Bool.not(Mons.Effect.has_sleep(source_mon.eff))
  // Can't infer type
  // def damage_target = ((val, game) 
  //   Mons.Skill.damage_eff(target_obj, pos, target, val, game))
  //   :: U32 -> Mons.Game -> Mons.Game

  // Cast skill
  // ----------
  if can_attack then
  case skill:
  | hit_4  =>
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);
  | hit_2 => 
    let val = Mons.Type.skill_n_type(light_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);
  | heal => Mons.Skill.heal_eff(source_obj, pos, source, 3u, game);
  | none => game;

  // Invulnerable for this turn. On the next turn, will attack and effects can be applied
  | dig => // OK
    let game = Mons.Skill.invulnerable_eff(source_obj, pos, source, game) 
    let game = Mons.Skill.hit_next_eff(target_obj, 3u, pos, target, game)
    game;
    // Adve nÃ£o tem invul mas no hero tem o hit: quando jogando contra o Gasparzinho

  // Apply an initial dmg and +1/16 of MPH for 5 turns
  | sand_tomb => 
    let val = Mons.Type.skill_n_type(light_val, source_mon, target_mon) 
    // BUG: only the first line is executed
    // let game = Mons.Skill.damage_eff(target_obj, pos, target, val, game) // insta
    let game = Mons.Skill.burn_eff(target_obj, pos, target, 5u, game)
    game;

  // Avoid effects on the next turn. Can't be used successively
  // Updating to: reduce damage in 50% next turn. Can't be used successively.
  | protect =>
    open source_mon:
    open source_mon.eff as eff:
    let used_last_turn = Pair.snd<,>(eff.protect)
    if used_last_turn then game
    else Mons.Skill.protect_eff(source_obj, pos, source, 2u, game);

  // High damage
  | slam => // OK
    let val = Mons.Type.skill_n_type(high_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // Double the last damage that the adve received (dismiss effects)
  // Update: apply burn
  | counter =>  // ok
    Mons.Skill.burn_eff(target_obj, pos, target, 5u, game)
  ;

  // Restore 50% of mhp
  | recover => // ok
    let val = U32.div(source_mon_attr.mhp, 2u)
    Mons.Skill.heal_eff(source_obj, pos, source, val, game);

  // Apply a medium damage + 50% of critical
  | rock_smash => // ok 
    let val = Mons.Skill.critical_hit(target_mon_attr.mhp, medium_val, 2u, game.tik)
    let game = Mons.Skill.damage_eff(target_obj, pos, target, val, game)
    game;

  // Medium_val damage + 25% of critical
  | crunch =>  // OK
    let val = Mons.Skill.critical_hit(target_mon_attr.mhp, medium_val, 4u, game.tik)
    let game = Mons.Skill.damage_eff(target_obj, pos, target, val, game)
    game;

  // Damage and 33% of poisoning
  | sludge_bomb => // ok: poisoning
    let val = Mons.Type.skill_n_type(light_val, source_mon, target_mon)
    let game = Mons.Skill.damage_eff(target_obj, pos, target, val, game) // don't work
    let game =  // Apply poison
      if Mons.Skill.is_critical(3u, game.tik) then
        Mons.Skill.poison_eff(target_obj, pos, target, game)
      else game
    game;

  // Apply medium damage. If this Mon has "agi" faster than the adve, increase
  // damage by 50%.
  | gyro_ball => // OK
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    let val = 
      if U32.ltn(Mons.Kind.get_agi(target_mon.kin), Mons.Kind.get_agi(source_mon.kin)) 
      then U32.add(U32.div(val,2u), val)
      else val
    let game = Mons.Skill.damage_eff(target_obj, pos, target, val, game)
    game;

  // Minimize damage for 2 turns, including the current one
  | iron_defense =>  // OK
    Mons.Skill.minimize_eff(source_obj, pos, source, game);

  // Damage adve with 50% of current life. Loses 25% of hp
  | super_fang => 
    let adve_dmg = U32.div(Mons.Object.remaining_hp(source_mon), 2u)
    let hero_dmg = U32.div(adve_dmg, 2u)
    use skp = Debug.log<>(String.flatten(["Super fang dmg: ", U32.to_string(hero_dmg)]))
    let game = Mons.Skill.damage_eff(source_obj, pos, source, hero_dmg, game)
    let game = Mons.Skill.damage_eff(target_obj, pos, target, adve_dmg, game)
    game;

  // Apply sleep to adve
  | hypnosis => Mons.Skill.sleep_eff(target_obj, pos, target, game);

  // TODO: Will only damage if adve is sleep. Will damage adve and heal 50% of the dmg
  | dream_eater => game;

  // Medium damage
  | wing_attack => 
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // TODO Damage and 20% of sleep
  | moonlight => game;

  // TODO Damage and 20% of reduce damage
  | play_rough => game;

  // TODO Damage and 10% of reduce damage and apply confusion
  | psychic => game;

  // TODO Damage and 10% of adve miss the attack
  | ancient_power => game;

  // Medium damage
  | thunder_wave =>
    let val = Mons.Type.skill_n_type(medium_val, source_mon, target_mon)
    Mons.Skill.damage_eff(target_obj, pos, target, val, game);

  // TODO Double the damage of the next ellectric attack
  | charge => game;

  // Invent the Mons's agility
  // Note: if the enemy uses it, the damage received by the adve is also damaged in the hero
  // a possible solution is to execute this skill at the beggining of the turn, using it
  // as an effect
  | agility =>  game; //Mons.Skill.invert_agility(pos, source, target, game);

  | hero_kill => Mons.Skill.damage_eff(target_obj, pos, target, 40u, game);

  else game // end case of "can_attack" 


Mons.Skill.critical_hit(mhp: U32, hit_val: U32, perc: U32, tik: U32): U32
  if U32.eql(U32.mod(tik, perc), 0u) then // percentage applied
    U32.add(U32.div(mhp, 16u), hit_val) // +1/16 damage
  else hit_val

Mons.Skill.is_critical(perc: U32, tik: U32): Bool
  U32.eql(U32.mod(tik, perc), 0u)


// TODO remove
Mons.Skill.dummy_skills: List(Mons.Skill)
  [ Mons.Skill.hit_4, Mons.Skill.hit_2,
   Mons.Skill.heal, Mons.Skill.none ]


// Bugs:
// Adve is not getting invulnerable when using an attack to apply it
// Hero mon: burn don't update the counter, but deals damage
// sand_tomb can't use insta damage and burn at the same time
// sludge_bomb can't use insta damage and poison
// agility: if the enemy uses it, the damage received by the adve is also damaged in the hero