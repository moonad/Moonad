// GBA position: divide OpenEMU by 2.575

Mons.placa: Image3D
  Image3D.parse("")

// A Mons sprite
T Mons.Sprite
| Mons.Sprite.new(x: U32, y: U32, z: U32, img: Image3D);

// A direction
T Mons.Dir
| Mons.Dir.right;
| Mons.Dir.up;
| Mons.Dir.left;
| Mons.Dir.down;

T Mons.Map.Dir
| Mons.Map.Dir.right; // r
| Mons.Map.Dir.up; // u
| Mons.Map.Dir.left; // l
| Mons.Map.Dir.down; // d
| Mons.Map.Dir.middle; // m

T Mons.Map.Dir.expanded
| Mons.Map.Dir.expanded.right; // r
| Mons.Map.Dir.expanded.up; // u
| Mons.Map.Dir.expanded.left; // l
| Mons.Map.Dir.expanded.down; // d
| Mons.Map.Dir.expanded.middle; // m
| Mons.Map.Dir.expanded.right_up; // ru
| Mons.Map.Dir.expanded.right_down; // rd
| Mons.Map.Dir.expanded.left_up; // lu
| Mons.Map.Dir.expanded.left_down; // ld
// | Mons.Map.Dir.expanded.circle; // c

//T Mons.Action
//| Mons.Action.walk(dir: Mons.Dir);

//T Mons.Battle.Action
//| Mons.Battle.Action.atk;
//| Mons.Battle.Action.bag;
//| Mons.Battle.Action.mon;
//| Mons.Battle.Action.run;

T Mons.Sign
| Mons.Sign.minus;
| Mons.Sign.zero;
| Mons.Sign.plus;

T Mons.Pad
| Mons.Pad.new(r: Bool, u: Bool, l: Bool, d: Bool);

// A game object
T Mons.Object
| Mons.Object.new(
  kin: Mons.Kind, // represent the type of the object
  dir: Mons.Dir,  // direction the object is facing
  pad: Mons.Pad,  // movement key pad
  ani: U32,       // number of walk frames to animate
  dmg: U32,       // object's current health points
  bag: List(Mons.Object), // store normal Mons
  mon: U32, // idx of the current Mon. Default 0u
  bos: List(Mons.Object) // store Mons that are boss 
);

// TODO add more skills
T Mons.Skill
| Mons.Skill.Dummy_hit;
| Mons.Skill.Dummy_heal;

// TODO remove
Mons.dummy_skills: List(Mons.Skill)
  [ Mons.Skill.Dummy_hit, Mons.Skill.Dummy_hit,
   Mons.Skill.Dummy_heal, Mons.Skill.Dummy_heal ]


T Mons.Attr
| Mons.Attr.new(
  blocks: Bool,
  battles: Bool,
  mhp: U32,
  atk: U32,
  name: String,
  spr: (x: U32) -> (y: U32) -> (obj_ani: U32) -> (obj_dir: Mons.Dir) -> List(Image3D),
  pic: Image3D,
  battle_spr: (is_up: Bool) -> Image3D,
  skills: List(Mons.Skill)
);
// TODO add:
// def: U32,
// spr: (x: U32) -> (y: U32) -> List(Image3D),
// ...)

// A 2d map of game tiles
Mons.Map: Type
  Map(List(Mons.Object))

//let map = Map.new<>
//let objs = [graminha, arbusto, heroi]
//let map = Map.set(Pos32.to_bits(Pos32.new(2000u,2000u,0u)), objs, map)
//map


// The global game state
T Mons.Game
| Mons.Game.new(
  usr: Word(160), // player name
  pos: Map(Pos32), // player positions
  map: Mons.Map, // the game map
  stt: Mons.Screen // the current state of the game
);

T Mons.Screen
| Mons.Screen.game(cmd: Char); // cmd: movement
| Mons.Screen.inventory(idx: U32);
| Mons.Screen.capture_mon(
  idx: U32, // idx of the Mon to be replaced
  full_bag: Bool);

T Mons.Kind
| Mons.Kind.Mons(ele: Mons.Kind.mons, boss: Bool);
| Mons.Kind.Const(ele: Mons.Kind.const, portal: Bool);
| Mons.Kind.Terrain(ele: Mons.Kind.terrain);

T Mons.Kind.mons
| Mons.Kind.mons.HERO;
| Mons.Kind.mons.BATH;
| Mons.Kind.mons.BEHOLDER;
| Mons.Kind.mons.CRONI;
| Mons.Kind.mons.ELLIOT;
| Mons.Kind.mons.ESPECTRONUS;
| Mons.Kind.mons.GAKI;
| Mons.Kind.mons.GORR;
| Mons.Kind.mons.LAMURIA;
| Mons.Kind.mons.RAFIRE;
| Mons.Kind.mons.VARGOULI;
| Mons.Kind.mons.TUPITREE;
| Mons.Kind.mons.LELA;
| Mons.Kind.mons.MOSHY;
| Mons.Kind.mons.POISOLICK;
| Mons.Kind.mons.BUFF;
| Mons.Kind.mons.LAUGH;
| Mons.Kind.mons.COBE_ORN;
| Mons.Kind.mons.SANDY;
| Mons.Kind.mons.SLIME;
| Mons.Kind.mons.MIMIC;
| Mons.Kind.mons.SPARKY;
| Mons.Kind.mons.DOOMFIRE;
| Mons.Kind.mons.BEANSTRONG;
| Mons.Kind.mons.NAMELESS;
| Mons.Kind.mons.OCTOKING;
| Mons.Kind.mons.INPUBU;
| Mons.Kind.mons.EMERELDER;
| Mons.Kind.mons.ZOIO;
| Mons.Kind.mons.IGNITE;
| Mons.Kind.mons.FROST;
| Mons.Kind.mons.FRAB;
| Mons.Kind.mons.ELECTROWL;
| Mons.Kind.mons.NOCTUBRIGHT;


T Mons.Kind.const
| Mons.Kind.const.ROCK_PATH_C;
| Mons.Kind.const.ROCK_PATH_M;
| Mons.Kind.const.HOUSE(model: Nat, slice: Nat);
| Mons.Kind.const.CASTLE(model: Nat, slice: Nat);
| Mons.Kind.const.CHEST;
| Mons.Kind.const.PATH_BLOCKER;
| Mons.Kind.const.FENCE(model: Nat, dir: Mons.Map.Dir.expanded);

T Mons.Kind.terrain
| Mons.Kind.terrain.VOID;
| Mons.Kind.terrain.GRASS;
| Mons.Kind.terrain.GRASS_PLANT;
| Mons.Kind.terrain.BUSH;
| Mons.Kind.terrain.PLANT_0;
| Mons.Kind.terrain.ELV_TERRAIN_00;
| Mons.Kind.terrain.ELV_TERRAIN_01;
| Mons.Kind.terrain.ELV_TERRAIN_02;
| Mons.Kind.terrain.OCEAN(dir: Mons.Map.Dir);
| Mons.Kind.terrain.TREE(model: Nat, slice: Nat);
| Mons.Kind.terrain.SAND_0;
| Mons.Kind.terrain.SAND_1;
| Mons.Kind.terrain.WATER(dir: Mons.Map.Dir.expanded);
| Mons.Kind.terrain.WATER1_M;

Mons.Kind.get_mhp(kind: Mons.Kind): U32
  case Mons.Kind.attr(kind) as attr:
  | attr.mhp;

Mons.Kind.get_battle_spr(kind: Mons.Kind, is_up: Bool): Image3D
  case Mons.Kind.attr(kind) as attr:
  | attr.battle_spr(is_up);

Mons.Kind.get_name(kind: Mons.Kind): String 
  case Mons.Kind.attr(kind) as attr:
  | attr.name;

Mons.Kind.get_battles(kind: Mons.Kind): Bool
 case Mons.Kind.attr(kind) as attr:
  | attr.battles; 

Mons.Kind.get_blocks(kind: Mons.Kind): Bool
 case Mons.Kind.attr(kind) as attr:
  | attr.blocks;

Mons.Kind.get_atk(kind: Mons.Kind): U32
 case Mons.Kind.attr(kind) as attr:
  | attr.atk; 

Mons.Kind.get_skills(kind: Mons.Kind): List(Mons.Skill)
 case Mons.Kind.attr(kind) as attr:
  | attr.skills; 


// TODO make it better so it doesn't have to be updated
// everytime a new Mon is added/removed 
Mons.Kind.is_hero(kind: Mons.Kind): Bool
  case kind:
  | mons => 
    case kind.ele:
    | HERO        => Bool.true;
    | BATH        => Bool.false;
    | BEHOLDER    => Bool.false;
    | CRONI       => Bool.false;
    | ELLIOT      => Bool.false;
    | ESPECTRONUS => Bool.false;
    | GAKI        => Bool.false;
    | GORR        => Bool.false;
    | LAMURIA     => Bool.false;
    | RAFIRE      => Bool.false;
    | VARGOULI    => Bool.false;
    | TUPITREE    => Bool.false;
    | LELA        => Bool.false;
    | MOSHY       => Bool.false;
    | POISOLICK   => Bool.false;
    | BUFF        => Bool.false;
    | LAUGH       => Bool.false;
    | COBE_ORN    => Bool.false;
    | SANDY       => Bool.false;
    | SLIME       => Bool.false;
    | MIMIC       => Bool.false;
    | SPARKY      => Bool.false;
    | DOOMFIRE    => Bool.false;
    | BEANSTRONG  => Bool.false;
    | NAMELESS    => Bool.false;
    | OCTOKING    => Bool.false;
    | INPUBU      => Bool.false;
    | EMERELDER   => Bool.false;
    | ZOIO        => Bool.false;
    | IGNITE      => Bool.false;
    | FROST       => Bool.false;
    | FRAB        => Bool.false;
    | ELECTROWL   => Bool.false;
    | NOCTUBRIGHT => Bool.false;;
  | const   => Bool.false;
  | terrain => Bool.false;


// Sprites are centered at 128x128
Mons.vox_mid: Pos32
  Pos32.new(128u, 128u, 0u) 

// The game screen is 240x160 pixels
Mons.scr_mid: Pos32
  Pos32.new(120u, 80u, 0u)

// The game screen width
Mons.scr_w: U32
  U32.mul(Pos32.get_x(Mons.scr_mid), 2u)

// The game screen height
Mons.scr_h: U32
  U32.mul(Pos32.get_y(Mons.scr_mid), 2u)

// The null pad
Mons.Pad.null: Mons.Pad
  Mons.Pad.new(Bool.false, Bool.false, Bool.false, Bool.false)

// Sets the r field of a pad
Mons.Pad.set_r(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(val, pad.u, pad.l, pad.d)

// Sets the u field of a pad
Mons.Pad.set_u(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, val, pad.l, pad.d)

// Sets the l field of a pad
Mons.Pad.set_l(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, val, pad.d)

// Sets the d field of a pad
Mons.Pad.set_d(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, pad.l, val)

// The void tile
Mons.Object.void: Mons.Object
  let void = Mons.Kind.Terrain(Mons.Kind.terrain.VOID)
  Mons.Object.new(void, Mons.Dir.down, Mons.Pad.null, 0u, 0u, [], 0u, [])

// Gets an object's direction
Mons.Object.get_dir(obj: Mons.Object): Mons.Dir
  open obj: obj.dir

// Sets an object's direction
Mons.Object.set_dir(obj: Mons.Object, dir: Mons.Dir): Mons.Object
  open obj: Mons.Object.new(obj.kin, dir, obj.pad, obj.ani, obj.dmg, obj.bag, obj.mon, obj.bos)

// Gets an object's pad
Mons.Object.get_pad(obj: Mons.Object): Mons.Pad
  open obj: obj.pad

// Sets an object's pad
Mons.Object.set_pad(obj: Mons.Object, pad: Mons.Pad): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, pad, obj.ani, obj.dmg, obj.bag, obj.mon, obj.bos)

// Gets an object's walk animation frames
Mons.Object.get_ani(obj: Mons.Object): U32
  open obj: obj.ani

// Sets an object's walk animation frames
Mons.Object.set_ani(obj: Mons.Object, ani: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, ani, obj.dmg, obj.bag, obj.mon, obj.bos)

// Gets an object's current HP
Mons.Object.get_dmg(obj: Mons.Object): U32
  open obj: obj.dmg

// Gets an object's kind 
Mons.Object.get_kin(obj: Mons.Object): Mons.Kind
  open obj: obj.kin

// Sets an object's current HP
Mons.Object.set_dmg(obj: Mons.Object, dmg: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, dmg, obj.bag, obj.mon, obj.bos)

// Sets an object's pad.r
Mons.Object.set_pad_r(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_r(obj.pad, val))

// Sets an object's pad.u
Mons.Object.set_pad_u(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_u(obj.pad, val))

// Sets an object's pad.l
Mons.Object.set_pad_l(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_l(obj.pad, val))

// Sets an object's pad.d
Mons.Object.set_pad_d(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_d(obj.pad, val))

Mons.Object.set_mon(idx: U32, obj: Mons.Object): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, idx, obj.bos)

Mons.Object.set_bos(bos: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, obj.mon, bos)

// Hits an object, damaging it
Mons.Object.hit(obj: Mons.Object, dmg: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.add(Mons.Object.get_dmg(obj), dmg))

// Heals an object
Mons.Object.heal(obj: Mons.Object, val: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.sub(Mons.Object.get_dmg(obj), val))

// Returns true if any of the object's pad is non-zero (it is walking)
Mons.Object.is_walking(obj: Mons.Object): Bool
  open obj:
  open obj.pad:
  let is_walking_x = Bool.or(obj.pad.u, obj.pad.d)
  let is_walking_y = Bool.or(obj.pad.l, obj.pad.r)
  Bool.or(is_walking_x, is_walking_y)

// Is this object free to move?
Mons.Object.is_free_to_move(obj: Mons.Object): Bool
  open obj:
  U32.eql(obj.ani, 0u)

Mons.Object.is_standing(obj: Mons.Object): Bool
  U32.eql(Mons.Object.get_ani(obj),0u)

Mons.walk_char_pack(
  t_x: U32,
  t_y: U32,
  ani: U32,
  dir: Mons.Dir,
  r_0: Image3D,
  u_0: Image3D,
  l_0: Image3D,
  d_0: Image3D,
  r_1: Image3D,
  u_1: Image3D,
  l_1: Image3D,
  d_1: Image3D,
  r_2: Image3D,
  u_2: Image3D,
  l_2: Image3D,
  d_2: Image3D
): List(Image3D)
  //0 = parado
  //1 = pe direito pra frente
  //2 = pe esquerdo pra frente
  if U32.eql(ani, 0u) then
    case dir:
    | right => [r_0];
    | up    => [u_0];
    | left  => [l_0];
    | down  => [d_0];
  else
    if U32.eql(U32.mod(U32.add(t_x,t_y),2u), 0u) then
      case dir:
      | right => [r_1];
      | up    => [u_1];
      | left  => [l_1];
      | down  => [d_1];
    else
      case dir:
      | right => [r_2];
      | up    => [u_2];
      | left  => [l_2];
      | down  => [d_2];
  
// An empty map
Mons.Map.new: Mons.Map
  Map.new<>

// Adds a tile to a position on the map
Mons.Map.set_list(pos: Pos32, objs: List(Mons.Object), map: Mons.Map): Mons.Map
  Map.set<>(U32.to_bits(pos), objs, map)

// Gets the tile stored on a position on the map
Mons.Map.get_list(pos: Pos32, map: Mons.Map): List(Mons.Object)
  case Map.get<>(U32.to_bits(pos), map) as got:
  | [];
  | got.value;

// Gets the nth object of a tile
Mons.Map.get(pos: Pos32, idx: U32, map: Mons.Map): Mons.Object
  let list = Mons.Map.get_list(pos, map)
  case List.at<>(U32.to_nat(idx), list) as got:
  | Mons.Object.void;
  | got.value;

// Sets the nth object of a tile
Mons.Map.set(pos: Pos32, idx: U32, val: Mons.Object, map: Mons.Map): Mons.Map
  let list = Mons.Map.get_list(pos, map)
  let list = List.update_at<>(U32.to_nat(idx), () val, list)
  Mons.Map.set_list(pos, list, map)

// Pushes an object to the top of a tile
Mons.Map.push(pos: Pos32, obj: Mons.Object, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.cons<>(obj, objs)
  Mons.Map.set_list(pos, objs, map)

// Pops an object from the top of a tile
Mons.Map.pop(pos: Pos32, map: Mons.Map): Pair(Mons.Map, Mons.Object)
  let objs = Mons.Map.get_list(pos, map)
  case objs:
  | Pair.new<,>(map, Mons.Object.void);
  | let map = Mons.Map.set_list(pos, objs.tail, map)
    Pair.new<,>(map, objs.head);

// Gets the the object on top of a tile
Mons.Map.get_top(pos: Pos32, map: Mons.Map): Mons.Object 
  Pair.snd<,>(Mons.Map.pop(pos,map))

// Gets the hero's object and its index from a tile
Mons.Map.get_hero(pos: Pos32, map: Mons.Map): Pair(Mons.Object, U32)
  let tile = Mons.Map.get_list(pos, map)
  let obj_is_hero = ((obj) Mons.Kind.is_hero(Mons.Object.get_kin(obj))) :: Mons.Object -> Bool 
  let fun = ((obj, idx) obj_is_hero(obj)) :: Mons.Object -> Nat -> Bool
  let both = List.ifind<>(tile, fun)
  case both: 
  | none => Pair.new<,>(Mons.Object.void, 0u);
  | some => 
    let hero = Pair.fst<,>(both.value)
    let idx = Nat.to_u32(Pair.snd<,>(both.value))
    Pair.new<,>(hero, idx);

// Deletes an object from a tile
Mons.Map.del(pos: Pos32, idx: U32, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.delete_at.u32<>(idx, objs)
  Mons.Map.set_list(pos, objs, map)

Mons.Object.push_to_bag(obj: Mons.Object, hero: Mons.Object): Mons.Object
  open obj:
  open hero:
  let qtd = List.length<>(hero.bag)
  case obj.kin as kind:
  | mon =>
    let obj = Mons.Object.set_dmg(obj, 0u)
    if Nat.ltn(qtd, 3) then
      let new_bag = List.append<>(hero.bag, obj)
      Mons.Object.set_bag(new_bag, hero)
    else
      hero;
  | const => hero;
  | terrain => hero;

Mons.Object.capture_boss(boss: Mons.Object, hero: Mons.Object): Mons.Object
  open boss:
  open hero:
  case boss.kin as kind:
  | mon => 
    let new_boss_bag = List.append<>(hero.bos, boss)
    Mons.Object.set_bos(new_boss_bag, hero);
  | const => hero;
  | terrain => hero;

Mons.Object.pop_from_bag(obj: Mons.Object): Mons.Object
  open obj:
  let qtd = List.length<>(obj.bag)
  if Nat.eql(qtd, 1) then
    obj
  else
    let new_bag = List.drop<>(1, obj.bag)
    Mons.Object.set_bag(new_bag, obj)

Mons.Object.delete_from_bag(idx: U32, obj: Mons.Object): Mons.Object
  let idx = U32.to_nat(idx)
  open obj:
  let qtd = List.length<>(obj.bag)
  if Nat.eql(qtd, 0) then obj
  else
    let new_bag = List.delete_at<>(idx, obj.bag)
    Mons.Object.set_bag(new_bag, obj)

Mons.Object.is_bag_full(obj: Mons.Object): Bool
  open obj:
  let size = List.length<>(obj.bag)
  Nat.eql(size, 3)

// Get names in a list of Mons.Objects
Mons.Object.get_names(bag: List(Mons.Object)): List(String)
  let names = List.nil<String>
  for mon in bag with names:
    open mon:
    let name = Mons.Kind.get_name(mon.kin);
    List.cons<>(name, names)

// Get images in a list of Mons.Objects
Mons.Object.get_images(bag: List(Mons.Object)): List(Image3D)
  let images = List.nil<Image3D>
  for mon in bag with images:
    open mon:
    let mon_attr = Mons.Kind.attr(mon.kin)
    open mon_attr:
    List.cons<Image3D>(mon_attr.pic, images)

Mons.Object.set_bag(bag: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, bag, obj.mon, obj.bos)

Mons.Object.hero: Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false))

Mons.Object.is_battleable(obj: Mons.Object): Bool
  open obj:
  case obj.kin as mon:
  | mons => Bool.true;
  | const => Bool.false;
  | terrain => Bool.false;

// Creates a new object with a given kind
Mons.Object.new_of_kind(kin: Mons.Kind): Mons.Object
  // kin, dir, pad, ani, dmg, bag, mon
  Mons.Object.new(kin, Mons.Dir.down, Mons.Pad.null, 1u, 0u, [], 0u, [])

Mons.Kind.new_terrain(kin: Mons.Kind.terrain): Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Terrain(kin))

Mons.Kind.new_const(kin: Mons.Kind.const): Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Const(kin, Bool.false))

Mons.Kind.new_portal(kin: Mons.Kind.const): Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Const(kin, Bool.true))

Mons.Kind.new_mons(kin: Mons.Kind.mons): List(Mons.Object)
  [ Mons.Object.new_of_kind(Mons.Kind.Mons(kin, Bool.false)),
    // Mons.Kind.new_terrain(Mons.Kind.terrain.BUSH)
    Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS)]

Mons.Kind.new_boss(kin: Mons.Kind.mons): List(Mons.Object)
  [ Mons.Object.new_of_kind(Mons.Kind.Mons(kin, Bool.true)),
    Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS)]

Mons.Kind.water_with_kin(kin: Mons.Kind.mons): List(Mons.Object)
  [ Mons.Object.new_of_kind(Mons.Kind.Mons(kin, Bool.false)),
    Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.middle))]

Mons.Map.code_to_tile.aux(code: String, cond: List(Pair(String, List(Mons.Object)))) : List(Mons.Object)
  case cond:
  | nil  => [];
  | cons =>
    get str objs = cond.head
    if String.eql(code, str) then 
      objs 
    else 
     Mons.Map.code_to_tile.aux(code, cond.tail);

// Converts a tile code (ex: ".g") into a list of obs
Mons.Map.code_to_tile(code: String): List(Mons.Object)
  let grass = Mons.Object.new_of_kind(Mons.Kind.Terrain(Mons.Kind.terrain.GRASS))
  let rock_path = Mons.Object.new_of_kind(Mons.Kind.Const(Mons.Kind.const.ROCK_PATH_M, Bool.false))

  Mons.Map.code_to_tile.aux(code,[
    { ".g", [ grass ]},
    { ".d", [ Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS_PLANT) ]},
    { "bg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.BUSH), grass ]},
    { "pg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.PLANT_0), grass ]},
    { "t0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_00) ]},
    { "t1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_01) ]},
    { "t2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_02) ]},
    { "w0", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.up)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "wm", [ Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.middle)) ]},
    { "w1", [ 
      Mons.Object.new_of_kind( Mons.Kind.Terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.left))),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "w2", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.right)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0)
     ]},
    { "w3", [
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.down)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "T0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 0)), grass]},
    { "T1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 1)), grass ]},
    { "/0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 0)), grass ]},
    { "/1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 1)) ]},
    { "/2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 2)), grass ]},
    { "B0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 0)), grass ]},
    { "B1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 1)), grass ]},
    { ".s", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_C), grass ]},
    { ".r", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_M) ]},

    { "30", Mons.Kind.new_mons(Mons.Kind.mons.BATH) },
    { "31", Mons.Kind.new_mons(Mons.Kind.mons.BEHOLDER) },
    { "32", Mons.Kind.new_mons(Mons.Kind.mons.CRONI) },
    { "33", Mons.Kind.new_mons(Mons.Kind.mons.ELLIOT) },
    { "34", Mons.Kind.new_mons(Mons.Kind.mons.ESPECTRONUS) },
    { "35", Mons.Kind.new_mons(Mons.Kind.mons.GAKI) },
    { "36", Mons.Kind.new_mons(Mons.Kind.mons.GORR) },
    { "37", Mons.Kind.new_mons(Mons.Kind.mons.LAMURIA) },
    { "38", Mons.Kind.new_mons(Mons.Kind.mons.RAFIRE) },
    { "39", Mons.Kind.new_mons(Mons.Kind.mons.VARGOULI) },
    { "40", Mons.Kind.new_mons(Mons.Kind.mons.TUPITREE) },
    { "41", Mons.Kind.new_mons(Mons.Kind.mons.LELA) },
    { "42", Mons.Kind.new_mons(Mons.Kind.mons.MOSHY) },
    { "43", Mons.Kind.water_with_kin(Mons.Kind.mons.ESPECTRONUS) },
    { "44", Mons.Kind.water_with_kin(Mons.Kind.mons.LAMURIA)},
    { "45", Mons.Kind.new_mons(Mons.Kind.mons.POISOLICK) },
    { "46", Mons.Kind.new_boss(Mons.Kind.mons.BUFF) },
    { "47", Mons.Kind.new_boss(Mons.Kind.mons.LAUGH) },
    { "48", Mons.Kind.new_mons(Mons.Kind.mons.COBE_ORN) },
    { "49", Mons.Kind.new_mons(Mons.Kind.mons.SANDY) },
    { "50", Mons.Kind.new_mons(Mons.Kind.mons.SLIME) },
    { "51", Mons.Kind.new_mons(Mons.Kind.mons.MIMIC) },
    { "52", Mons.Kind.new_mons(Mons.Kind.mons.SPARKY) },
    { "53", Mons.Kind.new_mons(Mons.Kind.mons.DOOMFIRE) },
    { "54", Mons.Kind.new_mons(Mons.Kind.mons.BEANSTRONG) },
    { "55", Mons.Kind.new_mons(Mons.Kind.mons.NAMELESS) },
    { "56", Mons.Kind.new_boss(Mons.Kind.mons.OCTOKING) },
    { "57", Mons.Kind.new_mons(Mons.Kind.mons.INPUBU) },
    { "58", Mons.Kind.new_mons(Mons.Kind.mons.EMERELDER) },
    { "59", Mons.Kind.new_mons(Mons.Kind.mons.ZOIO) },
    { "60", Mons.Kind.new_mons(Mons.Kind.mons.IGNITE) },
    { "61", Mons.Kind.new_mons(Mons.Kind.mons.FROST) },
    { "62", Mons.Kind.new_mons(Mons.Kind.mons.FRAB) },
    { "63", Mons.Kind.new_mons(Mons.Kind.mons.ELECTROWL) },
    { "64", Mons.Kind.new_mons(Mons.Kind.mons.NOCTUBRIGHT) },

    { "K0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 0)), rock_path ]},
    { "K1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 1)) ]},
    { "K2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 2)) ]},
    { "K3", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 3)) ]},
    { "K4", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 4)), rock_path ]},
    { "C0", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 0)) rock_path ]},
    { "C1", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 1)) rock_path ]},
    { "C2", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 2)), rock_path ]},
    { "C3", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 3)), rock_path ]},
    { "C4", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 4)), rock_path ]},
    { "S0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "S1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_1) ]},
    { "ch", [ Mons.Kind.new_portal(Mons.Kind.const.CHEST) ]},
    { "om", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.middle))]},
    { "on", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER1_M) ]},
    { "o0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right)), grass ]},
    { "o1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.up)), grass ]},
    { "o2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left)), grass ]},
    { "o3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.down)), grass ]},
    { "o4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_up)), grass]},
    { "o5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_up)), grass ]},
    { "o6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_down)), grass ]},
    { "o7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_down)), grass ]},
    { "xx", [ Mons.Kind.new_const(Mons.Kind.const.PATH_BLOCKER) ]},
    { "f0", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right)), grass ]},
    { "f1", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.middle)), grass ]},
    { "f2", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left)), grass ]},
    { "f3", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_up)), grass ]},
    { "f4", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_up)), grass ]},
    { "f5", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_down)), grass ]},
    { "f6", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_down)), grass ]},
  ])

// Converts a string map source to an actual map
Mons.Map.build(code: List(List(String))): Mons.Map
  List.ifor.u32<>(code)<>
  | Mons.Map.new;
  | (z, plane, map) 
    let size = List.length.u32<>(plane) // NOTE: assumes width == height
    List.ifor.u32<>(plane)<>
    | map;
    | (j, row, map)
      for i : U32 = 0u .. size with map:
        let t_x = U32.add(U32.sub(2048u, U32.div(size, 2u)), i)
        let t_y = U32.add(U32.sub(2048u, U32.div(size, 2u)), j)
        let t_z = z
        let pos = Pos32.new(t_x, t_y, t_z)
        let ini = U32.to_nat(U32.mul(i,2u)) // slice start index
        let end = U32.to_nat(U32.add(U32.mul(i,2u),2u)) // slice end index
        let sli = String.slice(ini, end, row) // slice with tile code
        Mons.Map.set_list(pos, Mons.Map.code_to_tile(sli), map);;   

// Get the game user
Mons.Game.get_usr(game: Mons.Game): Word(160)
  open game: game.usr

// Set the game user
Mons.Game.set_usr(usr: Word(160), game: Mons.Game): Mons.Game
  open game: Mons.Game.new(usr, game.pos, game.map, game.stt)

Mons.Game.set_stt(stt: Mons.Screen, game: Mons.Game): Mons.Game
  open game: Mons.Game.new(game.usr, game.pos, game.map, stt)

// Gets an user's position
Mons.Game.get_user_pos(user: Word(160), game: Mons.Game): Maybe(Pos32)
  open game:
  Map.get<>(Word.to_bits<160>(user), game.pos)

// Sets an user's position
Mons.Game.set_user_pos(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, Map.set<>(Word.to_bits<160>(user), pos, game.pos), game.map, game.stt)

// Gets the hero's position
Mons.Game.get_hero_pos(game: Mons.Game): Maybe(Pos32)
  open game: Mons.Game.get_user_pos(game.usr, game)

// Sets the game map
Mons.Game.set_map(map: Mons.Map, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, game.pos, map, game.stt)

Mons.Game.update_obj(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Updates the object at given position on the game map
Mons.Game.update(fn: Mons.Object -> Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let obj = fn(Mons.Map.get(pos, idx, game.map))
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

Mons.Game.get_tile(pos: Pos32, game: Mons.Game): List(Mons.Object)
  open game:
  Mons.Map.get_list(pos, game.map)

Mons.Game.move_obj(from: Pos32, idx: U32, to: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game 
  let game = Mons.Game.map_del(from, idx, game)
  let game = Mons.Game.map_push(to, obj, game)
  game

Mons.Game.delete_adve_obj(
  adve_obj: Mons.Object, 
  hero_obj: Mons.Object, 
  pos: Pos32,
  hero_idx: U32,
  adve_idx: U32,
  game: Mons.Game): Mons.Game
  let game = Mons.Game.map_del(pos, adve_idx, game)
  let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
  Mons.Game.set_stt(Mons.Screen.game('.'), game)
  
Mons.Game.move_hero_down(
  usr: Word(160), 
  hero_obj: Mons.Object, 
  pos: Pos32, 
  hero_idx: U32, 
  game: Mons.Game): Mons.Game
  let y = Pos32.get_y(pos)
  let x = Pos32.get_x(pos)
  let z = Pos32.get_z(pos)
  let new_pos = Pos32.new(x,U32.add(y, 1u),z)
  let game = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game) 
  Mons.Game.set_user_pos(usr, new_pos, game)

// hero and adve have some hp
Mons.Object.is_battling(adve: Mons.Object, hero: Mons.Object): Bool
  open adve:
  open hero:
  open Mons.Kind.attr(adve.kin) as adve_kin:
  let is_adve_alive = Bool.not(U32.eql(adve_kin.mhp, adve.dmg))
  let qtd = List.length<>(hero.bag)
  if Nat.eql(qtd, 0) then
    open Mons.Kind.attr(hero.kin) as hero_kin:
    let is_hero_alive = Bool.not(U32.eql(hero_kin.mhp, hero.dmg))
    Bool.and(is_adve_alive, is_hero_alive)
  else
    let current_mon = Mons.Object.get_current_mon(hero)
    open current_mon:
    open Mons.Kind.attr(current_mon.kin) as mon_kin:
    let is_mon_alive = Bool.not(U32.eql(mon_kin.mhp, current_mon.dmg))
    Bool.and(is_adve_alive, is_mon_alive)
  

Mons.Object.ended_battle(adve: Mons.Object, hero: Mons.Object): Bool
  open adve:
  open hero:
  case adve.kin:
  | mon => 
    let adve_kin = Mons.Kind.attr(adve.kin)
    let hero_kin = Mons.Kind.attr(hero.kin)
    open adve_kin:
    open hero_kin:
    let adve_status = Mons.Object.is_obj_defeated(adve)
    let hero_status = Mons.Object.is_obj_defeated(hero)
    Bool.or(adve_status, hero_status)  
  ;
  | const => Bool.false;
  | terrain => Bool.false;
  
Mons.Object.is_obj_defeated(obj: Mons.Object): Bool
  open obj:
  case obj.kin as kind:
  | mons => 
    open Mons.Kind.attr(obj.kin) as kind:
    U32.eql(kind.mhp, obj.dmg);
  | const => Bool.false;
  | terrain => Bool.false;


Mons.Object.get_current_mon(obj: Mons.Object): Mons.Object
  open obj:
  let idx = U32.to_nat(obj.mon)
  case List.at<>(idx, obj.bag) as mon:
  | obj;
  | mon.value;

// When hero wins a battle, adds the adversary to hero's game
// and updates de game status
Mons.Game.hero_won_batle(
  adve_obj: Mons.Object,
  hero_obj: Mons.Object,
  hero_pos: Pos32,
  hero_idx: U32,
  game: Mons.Game
): Mons.Game
  open game:
  let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
  let game = Mons.Game.update((hero_obj) hero_obj, hero_pos, hero_idx, game)
  game

Mons.Kind.set_static_sprites(spr: List(Image3D)): U32 -> U32 -> U32 -> Mons.Dir -> List(Image3D)
  (x,y,obj_ani,obj_dir) spr

Mons.Kind.set_pic(spr: List(Image3D)): Image3D
  case spr:
  | Mons.Assets.tile_chest_0;
  | spr.head;

// TODO: update default battle image
Mons.Kind.set_default_battle_spr:  Bool -> Image3D
  (is_up) Mons.Assets.battle_croni_u

// Mons.Attr with "battles" equals to Bool.true
Mons.Attr.new_battleable(
  spr: List(Image3D),
  name: String,
  battle_spr: Bool -> Image3D
  ): Mons.Attr
  Mons.Attr.new(
    Bool.false, Bool.true, 40u, 0u, name,
    Mons.Kind.set_static_sprites(spr),
    Mons.Kind.set_pic(spr),
    battle_spr, Mons.dummy_skills)

// Mons.Attr with "block" equals to Bool.true
Mons.Attr.new_blockable(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.true, Bool.false, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

// Mons.Attr with "block" and "batlles" equals to Bool.false
Mons.Attr.new_neutral(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.false, Bool.false, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

Mons.Attr.new_hero: Mons.Attr
  Mons.Attr.new(Bool.false, Bool.false, 12u, 0u, "HERO",
    (x,y,obj_ani,obj_dir) 
      Mons.walk_char_pack(
        x, y, obj_ani, obj_dir,
        Mons.Assets.boy_r_0, Mons.Assets.boy_u_0, 
        Mons.Assets.boy_l_0, Mons.Assets.boy_d_0,

        Mons.Assets.boy_r_1, Mons.Assets.boy_u_1,
        Mons.Assets.boy_l_1, Mons.Assets.boy_d_1,

        Mons.Assets.boy_r_2, Mons.Assets.boy_u_2,
        Mons.Assets.boy_l_2, Mons.Assets.boy_d_2),
        Mons.Kind.set_pic([Mons.Assets.boy_d_0]),
      (is_up) Bool.if<>(is_up,Mons.Assets.battle_hero_u,Mons.Assets.battle_hero_u),
      Mons.dummy_skills 
  )

// blocks: Bool,
// battles: Bool,
// mhp: U32,
// atk: U32
// name: String
// spr: (x: U32) -> (y: U32) -> (obj_ani: U32) -> (obj_dir: Mons.Dir)-> List(Image3D)
Mons.Kind.attr(kin: Mons.Kind): Mons.Attr
  case kin:
  | Mons.Kind.mons => 
    case kin.ele as kin:
    | Mons.HERO => Mons.Attr.new_hero;
    | Mons.BATH => Mons.Attr.new_battleable(
      [Mons.Assets.mons_bath_d_0], "BATH",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_bath_u, Mons.Assets.battle_bath_d));
    | Mons.BEHOLDER => Mons.Attr.new_battleable(
      [Mons.Assets.mons_beholder_d_0], "BEHOLDER",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_beholder_u, Mons.Assets.battle_beholder_d));
    | Mons.CRONI => Mons.Attr.new_battleable(
      [Mons.Assets.mons_croni_d_0], "CRONI",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_croni_u, Mons.Assets.battle_croni_d));
    | Mons.ELLIOT => Mons.Attr.new_battleable(
      [Mons.Assets.mons_elliot_d_0], "ELLIOT",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_elliot_u, Mons.Assets.battle_elliot_d));
    | Mons.ESPECTRONUS => Mons.Attr.new_battleable(
      [Mons.Assets.mons_espectronus_d_0], "ESPECTRONUS",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_espectronus_u, Mons.Assets.battle_espectronus_d));
    | Mons.GAKI => Mons.Attr.new_battleable(
      [Mons.Assets.mons_gaki_d_0], "GAKI",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_gaki_u, Mons.Assets.battle_gaki_d));
    | Mons.GORR => Mons.Attr.new_battleable(
      [Mons.Assets.mons_gorr_d_0], "GORR",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_gorr_u, Mons.Assets.battle_gorr_d));
    | Mons.LAMURIA => Mons.Attr.new_battleable(
      [Mons.Assets.mons_lamuria_d_0], "LAMURIA",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_lamuria_u, Mons.Assets.battle_lamuria_d));
    | Mons.RAFIRE => Mons.Attr.new_battleable(
      [Mons.Assets.mons_rafire_d_0], "RAFIRE",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_rafire_u, Mons.Assets.battle_rafire_d));
    | Mons.VARGOULI => Mons.Attr.new_battleable(
      [Mons.Assets.mons_vargouli_d_0], "VARGOULI",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_vargouli_u, Mons.Assets.battle_vargouli_d));
    | Mons.TUPITREE => Mons.Attr.new_battleable(
      [Mons.Assets.mons_tupitree_d_0], "TUPITREE",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_tupitree_u, Mons.Assets.battle_tupitree_d));
    | Mons.LELA => Mons.Attr.new_battleable(
      [Mons.Assets.mons_lela_d_0], "LELA",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_lela_u, Mons.Assets.battle_lela_d));
    | Mons.MOSHY => Mons.Attr.new_battleable(
      [Mons.Assets.mons_moshy_d_0], "MOSHY",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_moshy_u, Mons.Assets.battle_moshy_d));
    | Mons.POISOLICK => Mons.Attr.new_battleable(
      [Mons.Assets.mons_poisolick_d_0], "POISOLICK",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_poisolick_u, Mons.Assets.battle_poisolick_d));
    | Mons.BUFF => Mons.Attr.new_battleable(
      [Mons.Assets.mons_buff_d_0], "BUFF",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_buff_u, Mons.Assets.battle_buff_d));
    | Mons.LAUGH => Mons.Attr.new_battleable(
      [Mons.Assets.mons_laugh_d_0], "LAUGH",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_laugh_u, Mons.Assets.battle_laugh_d));
    | Mons.COBE_ORN => Mons.Attr.new_battleable(
      [Mons.Assets.mons_cobeorn_d_0], "COBE_ORN",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_cobeorn_u, Mons.Assets.battle_cobeorn_d));
    | Mons.SANDY => Mons.Attr.new_battleable(
      [Mons.Assets.mons_sandy_d_0], "SANDY",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_sandy_u, Mons.Assets.battle_sandy_d));
    | Mons.SLIME => Mons.Attr.new_battleable(
      [Mons.Assets.mons_slime_d_0], "SLIME",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_slime_u, Mons.Assets.battle_slime_d));
    | Mons.MIMIC => Mons.Attr.new_battleable(
      [Mons.Assets.mons_mimic_d_0], "MIMIC",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_mimic_u, Mons.Assets.battle_mimic_d));
    | Mons.SPARKY => Mons.Attr.new_battleable(
      [Mons.Assets.mons_sparky_d_0], "SPARKY",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_sparky_u, Mons.Assets.battle_sparky_d));
    | Mons.DOOMFIRE => Mons.Attr.new_battleable(
      [Mons.Assets.mons_doomfire_d_0], "DOOMFIRE",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_doomfire_u, Mons.Assets.battle_doomfire_d));
    | Mons.BEANSTRONG => Mons.Attr.new_battleable(
      [Mons.Assets.mons_beanstrong_d_0], "BEANSTRONG",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_beanstrong_u, Mons.Assets.battle_beanstrong_d));
    | Mons.NAMELESS => Mons.Attr.new_battleable(
      [Mons.Assets.mons_nameless_d_0], "NAMELESS",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_nameless_u, Mons.Assets.battle_nameless_d));
    | Mons.OCTOKING => Mons.Attr.new_battleable(
      [Mons.Assets.mons_octoking_d_0], "OCTOKING",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_octoking_u, Mons.Assets.battle_octoking_d));
    | Mons.INGPUBU => Mons.Attr.new_battleable(
      [Mons.Assets.mons_ingpubu_d_0], "INGPUBU",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_ingpubu_u, Mons.Assets.battle_ingpubu_d));
    | Mons.EMERELDER => Mons.Attr.new_battleable(
      [Mons.Assets.mons_emerelder_d_0], "EMERELDER",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_emerelder_u, Mons.Assets.battle_emerelder_d));
    | Mons.ZOIO => Mons.Attr.new_battleable(
      [Mons.Assets.mons_zoio_d_0], "ZOIO",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_zoio_u, Mons.Assets.battle_zoio_d));
    | Mons.IGNITE => Mons.Attr.new_battleable(
      [Mons.Assets.mons_ignite_d_0], "IGNITE",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_ignite_u, Mons.Assets.battle_ignite_d));
    | Mons.FROST => Mons.Attr.new_battleable(
      [Mons.Assets.mons_frost_d_0], "FROST",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_frost_u, Mons.Assets.battle_frost_d));
    | Mons.FRAB => Mons.Attr.new_battleable(
      [Mons.Assets.mons_frab_d_0], "FRAB",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_frab_u, Mons.Assets.battle_frab_d));
    | Mons.ELECTROWL => Mons.Attr.new_battleable(
      [Mons.Assets.mons_electrowl_d_0], "ELECTROWL",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_electrowl_u, Mons.Assets.battle_electrowl_d));
    | Mons.NOCTUBRIGHT => Mons.Attr.new_battleable(
      [Mons.Assets.mons_noctubright_d_0], "NOCTUBRIGHT",
      (is_up) Bool.if<>(is_up, Mons.Assets.battle_noctubright_u, Mons.Assets.battle_noctubright_d));
  ; // end mons
  
  | Mons.Kind.construction =>
    case kin.ele as kin:
    | ROCK_PATH_C => Mons.Attr.new_neutral([Mons.Assets.rock_path_0_c]);
    | ROCK_PATH_M => Mons.Attr.new_neutral([Mons.Assets.rock_path_0_m]);
    | Mons.HOUSE =>
      if Nat.eql(kin.model, 0) then // Simple house
        if Nat.eql(kin.slice, 0) then
          Mons.Attr.new_blockable([Mons.Assets.brown_house0_00])
        else if Nat.eql(kin.slice, 1) then
          Mons.Attr.new_blockable([Mons.Assets.brown_house0_01])
        else if Nat.eql(kin.slice, 2) then
          Mons.Attr.new_blockable([Mons.Assets.brown_house0_02])
        else if Nat.eql(kin.slice, 3) then
          Mons.Attr.new_blockable([Mons.Assets.brown_house0_03])
        else Mons.Attr.new_blockable([Mons.Assets.brown_house0_04])
      else if Nat.eql(kin.model, 1) then // Tent
        if Nat.eql(kin.slice, 0) then
          Mons.Attr.new_blockable([Mons.Assets.tent_00])
        else if Nat.eql(kin.slice, 1) then
          Mons.Attr.new_blockable([Mons.Assets.tent_01])
        else Mons.Attr.new_blockable([Mons.Assets.tent_02])
      else Mons.Attr.new_blockable([]);
    | Mons.CASTLE_00 =>
      if Nat.eql(kin.model, 0) then
        if Nat.eql(kin.slice, 0) then
          Mons.Attr.new_blockable([Mons.Assets.brown_castle_00])
        else if Nat.eql(kin.slice, 1) then
          Mons.Attr.new_blockable([Mons.Assets.brown_castle_01])
        else if Nat.eql(kin.slice, 2) then
          Mons.Attr.new_blockable([Mons.Assets.brown_castle_02])
        else if Nat.eql(kin.slice, 3) then
          Mons.Attr.new_blockable([Mons.Assets.brown_castle_03])
        else Mons.Attr.new_blockable([Mons.Assets.brown_castle_04])
      else Mons.Attr.new_blockable([]);
    | Mons.CHEST => Mons.Attr.new_neutral([Mons.Assets.tile_chest_0]);
    | Mons.PATH_BLOCKER => Mons.Attr.new_blockable([Mons.Assets.rock_path_0_m]);
    | Mons.FENCE =>
      if Nat.eql(kin.model, 0) then
        case kin.dir:
        | Mons.Map.Dir.expanded.right => Mons.Attr.new_blockable([Mons.Assets.wood_fence_r]); 
        | Mons.Map.Dir.expanded.up => Mons.Attr.new_blockable([]); 
        | Mons.Map.Dir.expanded.left => Mons.Attr.new_blockable([Mons.Assets.wood_fence_l]); 
        | Mons.Map.Dir.expanded.down => Mons.Attr.new_blockable([]); 
        | Mons.Map.Dir.expanded.middle => Mons.Attr.new_blockable([Mons.Assets.wood_fence_m]);
        | Mons.Map.Dir.expanded.right_up => Mons.Attr.new_blockable([Mons.Assets.wood_fence_ru]); 
        | Mons.Map.Dir.expanded.right_down => Mons.Attr.new_blockable([Mons.Assets.wood_fence_rd]); 
        | Mons.Map.Dir.expanded.left_up => Mons.Attr.new_blockable([Mons.Assets.wood_fence_lu]); 
        | Mons.Map.Dir.expanded.left_down => Mons.Attr.new_blockable([Mons.Assets.wood_fence_ld]);
      else Mons.Attr.new_blockable([]);
  ; // end of construction

  | Mons.Kind.terrain => 
    case kin.ele as kin:
    | VOID => Mons.Attr.new_neutral([Mons.Assets.ocean_m]);
    | GRASS => Mons.Attr.new_neutral([Mons.Assets.grass_3_m]);
    | PLANT => Mons.Attr.new_neutral([Mons.Assets.grass_4_m]);
    | BUSH => Mons.Attr.new_neutral([Mons.Assets.bush_0, Mons.Assets.bush_1]);
    | PLANT_0 => Mons.Attr.new_blockable([Mons.Assets.home_decor_plant_0]);
    | ELV_TERRAIN_00 => Mons.Attr.new_neutral([Mons.Assets.grass_elevated_3_00]);
    | ELV_TERRAIN_01 => Mons.Attr.new_neutral([Mons.Assets.grass_elevated_3_01]);
    | ELV_TERRAIN_02 => Mons.Attr.new_neutral([Mons.Assets.grass_elevated_3_02]);
    | OCEAN => 
      case kin.dir:
        | Mons.Map.Dir.right => Mons.Attr.new_blockable([Mons.Assets.ocean_r]);
        | Mons.Map.Dir.up => Mons.Attr.new_blockable([Mons.Assets.ocean_u]);
        | Mons.Map.Dir.left => Mons.Attr.new_blockable([Mons.Assets.ocean_l]);
        | Mons.Map.Dir.down => Mons.Attr.new_blockable([Mons.Assets.ocean_d]);
        | Mons.Map.Dir.middle => Mons.Attr.new_blockable([Mons.Assets.ocean_d]);;
    | TREE =>
      if Nat.eql(kin.model, 0) then // Tree
        if Nat.eql(kin.slice, 0) then 
          Mons.Attr.new_blockable([Mons.Assets.tree_0_00])
        else Mons.Attr.new_blockable([Mons.Assets.tree_0_01])
      if Nat.eql(kin.model, 1) then // Big tree
        if Nat.eql(kin.slice, 0) then 
          Mons.Attr.new_blockable([Mons.Assets.bigtree0_00])
        else Mons.Attr.new_blockable([Mons.Assets.bigtree0_01])
      else Mons.Attr.new_blockable([]);
    | Mons.SAND_0 => Mons.Attr.new_neutral([Mons.Assets.sand_0]);
    | Mons.SAND_1 => Mons.Attr.new_neutral([Mons.Assets.sand_1]);
    | Mons.WATER => 
      case kin.dir:
      | Mons.Map.Dir.expanded.right => Mons.Attr.new_neutral([Mons.Assets.water_0_r]); 
      | Mons.Map.Dir.expanded.up => Mons.Attr.new_neutral([Mons.Assets.water_0_u, Mons.Assets.water_0_10]); 
      | Mons.Map.Dir.expanded.left => Mons.Attr.new_neutral([Mons.Assets.water_0_l]); 
      | Mons.Map.Dir.expanded.down => Mons.Attr.new_neutral([Mons.Assets.water_0_d]); 
      | Mons.Map.Dir.expanded.middle => Mons.Attr.new_neutral([Mons.Assets.water_0_m, Mons.Assets.water_0_10]);
      | Mons.Map.Dir.expanded.right_up => Mons.Attr.new_neutral([Mons.Assets.water_1_ru]); 
      | Mons.Map.Dir.expanded.right_down => Mons.Attr.new_neutral([Mons.Assets.water_1_rd]); 
      | Mons.Map.Dir.expanded.left_up => Mons.Attr.new_neutral([Mons.Assets.water_1_lu]); 
      | Mons.Map.Dir.expanded.left_down => Mons.Attr.new_neutral([Mons.Assets.water_1_ld]);; 
    | Mons.WATER1_M => Mons.Attr.new_neutral([Mons.Assets.water_1_m, Mons.Assets.water_0_10]);
  ; // end terrain
  

Mons.Dir.move(dir: Mons.Dir, pos: Pos32): Pos32
  case dir:
  | Pos32.add(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.sub(pos, Pos32.new(0u, 1u, 0u));
  | Pos32.sub(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.add(pos, Pos32.new(0u, 1u, 0u));

Mons.Skill.get_name(skill: Mons.Skill): String
  case skill:
  | dummy_hit  => "dummy_hit";
  | dummy_heal => "dummy_heal";

Mons.update_mon_obj(
  hero_obj: Mons.Object,
  obj_updated: Mons.Object,
  pos: Pos32,
  idx: U32,
  game: Mons.Game) : Mons.Game
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then
    Mons.Game.map_set(pos, idx, obj_updated, game) // hero_obj
  else //game
    let idx_nat = U32.to_nat(hero_obj.mon)
    let new_bag = List.update_at<>(idx_nat, (a) obj_updated, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj) 
    Mons.Game.map_set(pos, idx, hero_obj, game)

Mons.damage(obj: Mons.Object, pos: Pos32, idx: U32, dmg: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Object.hit(Mons.Object.get_current_mon(obj), dmg)
  Mons.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.heal(obj: Mons.Object, pos: Pos32, idx: U32, val: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Object.heal(Mons.Object.get_current_mon(obj), val)
  Mons.update_mon_obj(obj, obj_updated, pos, idx, game)

// pos    : position of the map in which the battle is taking place
// source : index of the object which is casting a skill
// target : index of the object which is receiving the effect 
Mons.cast(pos: Pos32, source: U32, target: U32, skill: Mons.Skill, game: Mons.Game): Mons.Game 
  open game:
  let source_obj = Mons.Map.get(pos, source, game.map)
  let target_obj = Mons.Map.get(pos, target, game.map)
  case skill: 
  | dummy_hit  => Mons.damage(target_obj, pos, target, 4u, game);
  | dummy_heal => Mons.heal(source_obj, pos, source, 2u, game);

// TODO: change Mons.Game.cmd to receive 'pos' instead, and use this one for usr
// Mons.Game.cmd_usr(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game

// Update a Mons.Game by pushing a new obj to a pos
Mons.Game.map_push(pos: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.push(pos, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by setting a new obj to a pos
Mons.Game.map_set(pos: Pos32, idx: U32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by deleting an obj from a tile
Mons.Game.map_del(pos: Pos32, idx: U32, game: Mons.Game): Mons.Game 
  open game: 
  let map = Mons.Map.del(pos, idx, game.map)
  Mons.Game.set_map(map, game)

// Computes a command from an user
Mons.Game.cmd(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game
  let pos = Mons.Game.get_user_pos(usr, game)
  case pos:
  // New player
  | let pos = Pos32.new(2048u, 2048u, 0u)
    let obj = Mons.Object.hero
    let game = Mons.Game.map_push(pos, obj, game)
    let game = Mons.Game.set_user_pos(usr, pos, game)
    game;
  // Existing player
  | open game:
    let pos = pos.value
    let hero_pair = Mons.Map.get_hero(pos, game.map)
    let hero_obj  = Pair.fst<,>(hero_pair)
    let hero_idx  = Pair.snd<,>(hero_pair)
    let adve_idx  = 1u
    let adve_obj = Mons.Map.get(pos, adve_idx, game.map)
    let is_battling = Mons.Object.is_battling(adve_obj, hero_obj)
    let end_battle = Mons.Object.ended_battle(adve_obj, hero_obj)
    let curr_mon = Mons.Object.get_current_mon(hero_obj)
    open curr_mon: 
    let skills = Mons.Kind.get_skills(curr_mon.kin)
    // let game = Mons.test.add_bag(hero_obj, pos, 0u, game) // TEST - bag
    // let game = Mons.test.add_boss(hero_obj, pos, 0u, game) // TEST - boss

    open hero_obj:
    open adve_obj:
    // TODO let usr = Mons.Game.get_from_map(pos, game) // gets the object that used the command
    // TODO let atks = Mons.Game.get_attack_list(usr.kin)... // gets the attack list of that usr
    case game.stt as stt:
    | game =>
    // TODO remove - just testing dmg to hero to check heal eff
    if U16.eql(cmd, 'T') then
      if Mons.Object.is_obj_defeated(hero_obj) then
        let hero_obj = Mons.Object.set_dmg(hero_obj, 0u)
        Mons.Game.map_set(pos, hero_idx, hero_obj, game)
      else
        Mons.cast(pos, hero_idx, hero_idx, Mons.Skill.Dummy_hit, game)

    else if U16.eql(cmd, 'U') then
      if is_battling then
        case List.at<>(0, skills) as skill:
        | none => game;
        | some => Mons.cast(pos, hero_idx, adve_idx, skill.value, game);
      else game
    else if U16.eql(cmd, 'I') then
      if is_battling then
        case List.at<>(1, skills) as skill:
        | none => game;
        | some => Mons.cast(pos, hero_idx, adve_idx, skill.value, game);
      else game
    else if U16.eql(cmd, 'J') then
      if is_battling then
        case List.at<>(2, skills) as skill:
        | none => game;
        | some => Mons.cast(pos, hero_idx, adve_idx, skill.value, game);
      else game
    else if U16.eql(cmd, 'K') then
      if is_battling then
        case List.at<>(3, skills) as skill:
        | none => game;
        | some => Mons.cast(pos, hero_idx, adve_idx, skill.value, game);
      else game
    else if U16.eql(cmd, 'D') then
      Mons.Game.update((obj) Mons.Object.set_pad_r(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'W') then
      Mons.Game.update((obj) Mons.Object.set_pad_u(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'A') then
      Mons.Game.update((obj) Mons.Object.set_pad_l(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'S') then
      Mons.Game.update((obj) Mons.Object.set_pad_d(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'd') then
      Mons.Game.update((obj) Mons.Object.set_pad_r(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 'w') then
      Mons.Game.update((obj) Mons.Object.set_pad_u(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 'a') then
      Mons.Game.update((obj) Mons.Object.set_pad_l(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 's') then
      Mons.Game.update((obj) Mons.Object.set_pad_d(obj, Bool.false), pos, hero_idx, game)

    // else if U16.eql(cmd, 'O') then //TODO remove
    //     let new_pos = Pos32.add(pos, Pos32.new(0u,0u,1u)) 
    //     let game    = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game)  
    //     Mons.Game.set_user_pos(usr, new_pos, game)
    // else if U16.eql(cmd, 'P') then //TODO remove
    //     let new_pos = Pos32.sub(pos, Pos32.new(0u,0u,1u)) 
    //     let game    = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game)
    //     Mons.Game.set_user_pos(usr, new_pos, game)
      
    else if U16.eql(cmd, 'e') then // Open hero's bag
      if Bool.or(is_battling, end_battle) then game
      else 
        Mons.Game.set_stt(Mons.Screen.inventory(0u), game)

    // --------- End battle
    else if U16.eql(cmd, 'c') then // Action to capture a Mon
      case adve_obj.kin as kind:
      | mon =>
        if Mons.Object.is_obj_defeated(adve_obj) then
          if kind.boss then
            let hero_obj = Mons.Object.capture_boss(adve_obj, hero_obj)
            Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
          else
            if Mons.Object.is_full_bag(hero_obj) then
              Mons.Game.set_stt(Mons.Screen.capture_mon(0u, Bool.true), game)
            else
              let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
              Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
        else if Mons.Object.is_obj_defeated(curr_mon) then
            let adve_obj = Mons.Object.set_dmg(adve_obj, 0u) // adve heals all hp
            let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
            let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
            let game = Mons.Game.map_set(pos, adve_idx, adve_obj, game)
            let game = Mons.Game.move_hero_down(usr, hero_obj, pos, hero_idx, game)
            Mons.Game.set_stt(Mons.Screen.game('.'), game)
        else // hero lost, restore life do avoid game over
          let hero_obj = Mons.Object.set_dmg(hero_obj, 0u)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
      ;
      | construction =>
        let qtd_boss = Nat.to_u32(List.length<>(hero_obj.bos))
        let can_use_portal = U32.eql(U32.add(hero_idx, 1u), qtd_boss)
        if can_use_portal then
          let new_pos = Pos32.add(pos, Pos32.new(0u,0u,1u)) 
          let game    = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game)  
          Mons.Game.set_user_pos(usr, new_pos, game)
        else game
      ;
      | terrain => Mons.Game.set_stt(Mons.Screen.game('.'), game);

    else if U16.eql(cmd, 'z') then // Free Mon
      if Mons.Object.is_obj_defeated(adve_obj) then
        let game = Mons.Game.map_del(pos, adve_idx, game)
        let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
        Mons.Game.set_stt(Mons.Screen.game('.'), game)
      else game

    else game ;

    | inventory => 
      if U16.eql(cmd, 'e') then
        Mons.Game.set_stt(Mons.Screen.game('.'), game)
      
      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.inventory(cmd),
          pos, hero_obj, hero_idx, game);

    | capture => // accessed by pressing "c" after battle
      if U16.eql(cmd, 'c') then
        // if stt.full_bag then // Update the current mon by the new one
          let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
          let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
          let hero_obj = Mons.Object.set_mon(2u, hero_obj)
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
        // else
        //   let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
        //   let game = Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
        //   Mons.Game.set_stt(Mons.Screen.game('.'), game)

      else if U16.eql(cmd, 'z') then // Free Mon
        if Mons.Object.is_obj_defeated(adve_obj) then
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
        else game

      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.capture_mon(cmd, Bool.true),
          pos, hero_obj, hero_idx, game)
    ;
  ;

// Update the current Mon by changing it with the keys 'w' (up) and 's' (down)
Mons.Object.change_curr_mon(
  cmd: Char,
  stt: U32 -> Mons.Screen,
  pos: Pos32,
  hero_obj: Mons.Object,
  hero_idx: U32,
  game: Mons.Game): Mons.Game
  // open game:
  open hero_obj:
  if Bool.or(U16.eql(cmd, 'a'), U16.eql(cmd, 'w')) then
    let hero_obj = Mons.Object.set_mon(U32.sub(hero_obj.mon, 1u), hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(1u), game)
  else if Bool.or(U16.eql(cmd, 'd'), U16.eql(cmd, 's')) then
    let hero_obj =
      let qtd_mon = Nat.to_u32(List.length<>(hero_obj.bag))
      if U32.ltn(hero_obj.mon, U32.sub(qtd_mon, 1u)) then
        Mons.Object.set_mon(U32.add(hero_obj.mon, 1u), hero_obj)
      else Mons.Object.set_mon(hero_obj.mon, hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(2u), game)
  else game

Mons.Object.is_full_bag(obj: Mons.Object): Bool
  open obj:
  let len = List.length<>(obj.bag)
  Nat.eql(len, 3)

Mons.test.add_bag(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
  open hero_obj:
  let hero_obj = Mons.Object.set_bag([], hero_obj)
  let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.CRONI, Bool.false))
  let mon1_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.LAMURIA, Bool.false))
  let mon2_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.ELLIOT, Bool.false))
  let hero_obj = Mons.Object.push_to_bag(mon0_bag, hero_obj)
  let hero_obj = Mons.Object.push_to_bag(mon1_bag, hero_obj)
  let hero_obj = Mons.Object.push_to_bag(mon2_bag, hero_obj)
  Mons.Game.map_set(pos, hero_idx, hero_obj, game)

Mons.test.add_boss(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
  open hero_obj:
  let hero_obj = Mons.Object.set_bos([], hero_obj)
  let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.BUFF, Bool.true))
  let hero_obj = Mons.Object.capture_boss(mon0_bag, hero_obj)
  Mons.Game.map_set(pos, hero_idx, hero_obj, game)

// Converts a keyboard key to a direction:
// A = [-1,  0,  0]
// D = [ 1,  0,  0]
// W = [ 0, -1,  0]
// S = [ 0,  1,  0]
// * = [ 0,  0,  0]a
Mons.key_to_dir(key_code: U16): Maybe(Mons.Dir)
  if U16.eql(key_code, 'A') then
    Maybe.some<>(Mons.Dir.left)
  else if U16.eql(key_code, 'D') then
    Maybe.some<>(Mons.Dir.right)
  else if U16.eql(key_code, 'W') then
    Maybe.some<>(Mons.Dir.up)
  else if U16.eql(key_code, 'S') then
    Maybe.some<>(Mons.Dir.down)
  else
    Maybe.none<>

// Given a tile (x, y) and an object, returns its global (x, y) positions
Mons.draw.global_xy(t_x: U32, t_y: U32, obj: Mons.Object): Pair(U32, U32)
  case obj:
  | let ani = Mons.Object.get_ani(obj)
    let dir = Mons.Object.get_dir(obj)
    let g_x = U32.mul(t_x, 16u)
    let g_y = U32.mul(t_y, 16u)
    let g_x
      = case dir:
      | right => U32.sub(g_x, ani);
      | up    => g_x;
      | left  => U32.add(g_x, ani);
      | down  => g_x;
    let g_y
      = case dir:
      | right => g_y;
      | up    => U32.add(g_y, ani);
      | left  => g_y;
      | down  => U32.sub(g_y, ani);
    Pair.new<,>(g_x, g_y);

//Mons.game_sprites.push_obj(t_x: U32, t_y: U32, obj: Mons.Object, sprs: List(Mons.Sprite)): List(Mons.Sprite)
  //for img in Mons.Object.get_images(t_x, t_y, obj) with sprs:
    //let ani = Mons.Object.get_ani(obj)
    //let dir = Mons.Object.get_dir(obj)
    //get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
    //let s_z = t_z
    //let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
    //List.cons<>(spr, sprs)

// Converts the game state to a list of sprites to be rendered
// TODO: for some reason, using a `case obj` here causes the
// function not to type check anymore. Investigate why.
Mons.game_sprites(game: Mons.Game): List(Mons.Sprite)
  open game:
  let sprs = []
  case Mons.Game.get_hero_pos(game) as cam_pos:
  | [];
  | let c_x = Pos32.get_x(cam_pos.value)
    let c_y = Pos32.get_y(cam_pos.value)
    let c_z = Pos32.get_z(cam_pos.value)
    for x : U32 = 0u .. 17u with sprs:
      for y : U32 = 0u .. 13u with sprs:
        let t_x = U32.add(U32.sub(c_x, 8u), x)
        let t_y = U32.add(U32.sub(c_y, 6u), y)
        let t_z = c_z
        let pos = Pos32.new(t_x, t_y, t_z)
        let got = Map.get<>(U32.to_bits(pos), game.map)
        let objs
          = case got:
          | [Mons.Object.void];
          | List.reverse<>(got.value);
        for obj in objs with sprs:
          open obj:
          open Mons.Kind.attr(obj.kin) as hero_attr:
          let sprites = hero_attr.spr(t_x, t_y, obj.ani, obj.dir)
          for img in sprites with sprs:
            let ani = Mons.Object.get_ani(obj)
            let dir = Mons.Object.get_dir(obj)
            get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
            let s_z = t_z
            let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
            List.cons<>(spr, sprs);

// Draw an inventory showing mons captured and their names
Mons.draw.bag(obj: Mons.Object, scr: Image3D): Image3D
  let scr = Mons.draw.image(Mons.Assets.inventory, Pos32.new(120u,80u,0u), scr)
  let scr = Mons.draw.image(Mons.Assets.battle_grass_full_bg, Pos32.new(120u,80u,0u), scr)
  open obj:
  let boss_def = U32.to_string(Nat.to_u32(List.length<>(obj.bos)))
  let qtd = Nat.to_u32(List.length<>(obj.bag))
  let qtd_field = 
    if U32.eql(qtd, 0u) then "Nothing to show for now"
    else String.flatten(["Qtd boss defeated: ", boss_def])
  let scr = Mons.draw.text(qtd_field, Mons.font_black, Pos32.new(95u,25u,0u), scr)
  let scr = Mons.draw.bag_select(obj.mon, qtd, scr)
  let scr = Mons.draw.bag_select_image(obj.mon, qtd, scr)
  let mons_names = List.reverse<>(Mons.Object.get_names(obj.bag)) 
  let mons_images = List.reverse<>(Mons.Object.get_images(obj.bag))
  let scr = Mons.draw.list_image(mons_images, Bool.true, Pos32.new(40u,50u,0u), scr)
  let scr = Mons.draw.list(mons_names, 11u, Pos32.new(95u,31u,0u), scr)
  scr

// 0: neutral
// 1: left, up
// 2: right, down
// To highlight a Mon name in inventory
Mons.draw.bag_select(mon_idx: U32, qtd: U32, scr: Image3D): Image3D
  let def_y = 42u
  let pos = 
    if U32.eql(mon_idx, 0u) then Pos32.new(160u,def_y,0u)
    else Pos32.new(160u, U32.add(def_y, U32.mul(12u, mon_idx)), 0u)
  if U32.eql(qtd, 0u) then scr
  else Mons.draw.image(Mons.Assets.inventory_row_mon_selected, pos, scr)

// To highlight a Mon image in inventory 40u,50u
Mons.draw.bag_select_image(mon_idx: U32, qtd: U32, scr: Image3D): Image3D
  let def_y = 50u
  let pos = 
    if U32.eql(mon_idx, 0u) then Pos32.new(40u,def_y,0u)
    else Pos32.new(40u, U32.add(def_y, U32.mul(35u, mon_idx)), 0u)
  if U32.eql(qtd, 0u) then scr
  else Mons.draw.image(Mons.Assets.inventory_mon_selected, pos, scr)

// Draw an inventory showing mons captured, their names and options to
// replace or skip the "mon capture"
Mons.draw.full_bag(obj: Mons.Object, adve_obj: Mons.Object, scr: Image3D): Image3D
  let scr = Mons.draw.image(Mons.Assets.inventory_replace_bg, Pos32.new(120u,80u,0u), scr)
  open obj:
  open adve_obj:
  open Mons.Kind.attr(adve_obj.kin) as adve_attr:
  let scr = Mons.draw.image(adve_attr.battle_spr(Bool.false), Pos32.new(180u,40u,0u), scr)
  let scr = Mons.draw.image(adve_attr.pic, Pos32.new(180u,92u,0u), scr)
  let scr = Mons.draw.image(Mons.Assets.inventory_mon_selection, Pos32.new(180u,90u,0u), scr)
  
  let qtd = Nat.to_u32(List.length<>(obj.bag))
  let mons_images = List.reverse<>(Mons.Object.get_images(obj.bag))
  let scr = Mons.draw.list_image(mons_images, Bool.false, Pos32.new(30u,90u,0u), scr)
  let scr = Mons.draw.bag_full_select(obj.mon, qtd, scr)
  let scr = Mons.draw.text("Select a mon to replace or skip", Mons.font_black, Mons.draw.msg_screen.line_0, scr)
  let scr = Mons.draw.text("[c] Replace  | [z] Skip     ", Mons.font_black, Mons.draw.msg_screen.line_1, scr)
  scr

// 0: neutral
// 1: left, up
// 2: right, down
// To highlight a Mon image when replacing Mon
Mons.draw.bag_full_select(mon_idx: U32, qtd: U32, scr: Image3D): Image3D
  let def_x = 30u
  let pos = 
    if U32.eql(mon_idx, 0u) then Pos32.new(def_x,90u,0u)
    else  Pos32.new(U32.add(def_x, U32.mul(35u, mon_idx)),90u,0u)
  if U32.eql(qtd, 0u) then scr
  else Mons.draw.image(Mons.Assets.inventory_mon_selected, pos, scr)

// Draw auxiliars
// -------------
Mons.draw.msg_screen.line_0: Pos32
  Pos32.new(16u,128u,0u)

Mons.draw.msg_screen.line_1: Pos32
  Pos32.new(16u,144u,0u)

Mons.draw.list(texts: List(String), spacing: U32, start_pos: Pos32, scr: Image3D): Image3D
   let qtd = Nat.to_u32(List.length<>(texts))
   Mons.draw.list.go(texts, spacing, start_pos, scr, 0u)

Mons.draw.list.go(texts: List(String), spacing: U32, pos: Pos32, scr: Image3D, idx: U32): Image3D
   let x = Pos32.get_x(pos)
   let y = Pos32.get_y(pos)
   let pos = Pos32.new(x,U32.add(U32.add(spacing, idx), y),0u)
   case texts:
   | scr;
   | let scr = Mons.draw.text(texts.head, Mons.font_black, pos, scr)
     Mons.draw.list.go(texts.tail, spacing, pos, scr, U32.add(idx, 1u));

// Draw images of Mons in the replace screen
// TODO: UP and DOWn
Mons.draw.list_image(images: List(Image3D), horizontal: Bool, start_pos: Pos32, scr: Image3D): Image3D
   let qtd = Nat.to_u32(List.length<>(images))
   Mons.draw.list_image.go(images, horizontal, start_pos, scr, 0u)

Mons.draw.list_image.go(images: List(Image3D), horizontal: Bool, pos: Pos32, scr: Image3D, idx: U32): Image3D
   let x = Pos32.get_x(pos)
   let y = Pos32.get_y(pos)
   case images:
   | scr;
   | let scr = Mons.draw.image(Mons.Assets.inventory_mon_selection, pos, scr)
     let pos_mon = Pos32.set_y(pos, U32.add(y, 2u))
     if horizontal then
        let scr = Mons.draw.image(images.head, pos_mon, scr)
        let pos = Pos32.new(x,U32.add(U32.add(35u, idx), y),0u)
        Mons.draw.list_image.go(images.tail, horizontal, pos, scr, U32.add(idx, 1u))
     else
        let scr = Mons.draw.image(images.head, pos_mon, scr)
        let pos = Pos32.new(U32.add(U32.add(35u, idx), x),y,0u)
        Mons.draw.list_image.go(images.tail, horizontal, pos, scr, U32.add(idx, 1u));

// Draws an ASCII char to a position using 
Mons.draw.char(chr: Char, font_map: Mons.font, chr_pos: Pos32, scr: Image3D): Image3D
  case Mons.font.get_img(chr, font_map) as got:
  | scr;
  | let img = got.value
    let img_len = Image3D.get_length(img)
    let scr = for i : U32 = 0u .. img_len:
      let vox_pos = Image3D.get_pos(i, img)
      let pos = Pos32.sub(Pos32.add(chr_pos, vox_pos), Mons.vox_mid)
      let col = Image3D.get_col(i, img)
      Image3D.push(pos, col, scr)
    scr;

// Draws an ASCII text to a position
Mons.draw.text(txt: String, font_map: Mons.font, chr_pos: Pos32, scr: Image3D): Image3D
  for pair in List.indices.u32<>(String.to_list(txt)) with scr:
    get i chr = pair
    let add_pos = Pos32.new(U32.mul(i,6u), 0u, 0u)
    Mons.draw.char(chr, font_map, Pos32.add(chr_pos, add_pos), scr)

// Draws a sprite to a position
Mons.draw.image(img: Image3D, pos: Pos32, scr: Image3D): Image3D
  let len = Image3D.get_length(img)
  for i : U32 = 0u .. len with scr:
    let pix_pos = Image3D.get_pos(i, img)
    let pix_col = Image3D.get_col(i, img)
    let pix_pos = Pos32.sub(Pos32.add(pos, pix_pos), Mons.vox_mid)
    Image3D.push(pix_pos, pix_col, scr)

Mons.draw.battle_bg(adve_kind: Mons.Kind.mons, is_boss: Bool, scr: Image3D): Image3D
  // TODO: check if adve is of type Grass, Ice, etc.
  let scr = Mons.draw.image(Mons.Assets.battle_grass_bg, Pos32.new(120u,80u,0u), scr)
  let scr = 
    if is_boss then
      Mons.draw.image(Mons.Assets.battle_boss, Pos32.new(120u,80u,0u), scr)
    else Mons.draw.image(Mons.Assets.battle_default, Pos32.new(120u,80u,0u), scr)
  scr

Mons.draw.capture_bg(adve_kind: Mons.Kind.mons, scr: Image3D): Image3D
  let scr = Mons.draw.image(Mons.Assets.battle_grass_full_bg, Pos32.new(120u,80u,0u), scr)
  let sct = Mons.draw.image(Mons.Assets.text_screen_bg, Pos32.new(120u,80u,0u), scr)
  scr


Mons.draw.adve_hp(chp: U32, mhp: U32, name: String, scr: Image3D): Image3D
  let p_hp = U32.div(U32.mul(chp, 70u), mhp) // x = 66u: full hp
  let pos_chp = Pos32.new(p_hp,21u,0u) 
  let pos_name = Pos32.new(38u,21u,0u)
  let scr = Mons.draw.image(Mons.Assets.battle_hp, pos_chp, scr)
  let scr = Mons.draw.text(name, Mons.font_white, pos_name, scr)
  scr

Mons.draw.hero_hp(chp: U32, mhp: U32, name: String, scr: Image3D): Image3D
  let p_hp = U32.div(U32.mul(chp, 70u), mhp) 
  let pos_chp = Pos32.new(U32.add(100u, p_hp),82u,0u) // x = 175u: full hp
  let pos_name = Pos32.new(139u,82u,0u)
  let scr = Mons.draw.image(Mons.Assets.battle_hp, pos_chp, scr)
  let scr = Mons.draw.text(name, Mons.font_white, pos_name, scr)
  scr

Mons.draw.battle_win_bg(adve_kind: Mons.Kind.mons, scr: Image3D): Image3D
  let scr = Mons.draw.image(Mons.Assets.battle_grass_full_bg, Pos32.new(120u,80u,0u), scr)
  let scr = Mons.draw.image(Mons.Assets.battle_win, Pos32.new(70u,90u,0u), scr)
  let scr = Mons.draw.image(Mons.Assets.text_screen_bg, Pos32.new(120u,80u,0u), scr)
  scr

// Draws the game to screen
Mons.draw(game: Mons.Game, scr: Image3D): Image3D
  open game:
  let hero_pos = Mons.Game.get_hero_pos(game)
  let scr = Image3D.clear(scr)
  case hero_pos:
  | scr;
  | let hero_pair = Mons.Map.get_hero(hero_pos.value, game.map)
    let hero_obj = Pair.fst<,>(hero_pair)
    let hero_idx = Pair.snd<,>(hero_pair)
    let adve_obj = Mons.Map.get(hero_pos.value, U32.add(hero_idx, 1u), game.map)
    open hero_obj:
    open adve_obj:
    let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
    open hero_mon_obj:

    case game.stt as stt:
    | game =>
      let hero_mon_attr = Mons.Kind.attr(hero_mon_obj.kin)
      let adve_attr = Mons.Kind.attr(adve_obj.kin)
      let is_standing = Mons.Object.is_standing(hero_obj)
      open hero_mon_attr:
      open adve_attr:

      case adve_obj.kin as adve_kind:
      | mon => 
        let hero_chp = U32.sub(hero_mon_attr.mhp, hero_mon_obj.dmg)
        let hero_btl_img = hero_mon_attr.battle_spr(Bool.true);
        let hero_txt = String.flatten([hero_mon_attr.name, " ", U32.to_string(hero_chp), " HP"])

        let adve_chp = U32.sub(adve_attr.mhp, adve_obj.dmg)
        let adve_btl_img = adve_attr.battle_spr(Bool.false);
        let adve_txt = String.flatten([adve_attr.name, " ", U32.to_string(adve_chp), " HP"])

        if is_standing then
          if Mons.Object.is_battling(adve_obj, hero_obj) then
            let scr = Mons.draw.battle_bg(adve_kind.ele, adve_kind.boss, scr)
            let scr = Mons.draw.hero_hp(hero_chp, hero_mon_attr.mhp, hero_txt, scr)
            let scr = Mons.draw.adve_hp(adve_chp, adve_attr.mhp, adve_txt, scr)
            let scr = Mons.draw.text("[U] hit(4)   | [I] hit(4)       ", Mons.font_black, Mons.draw.msg_screen.line_0, scr)
            let scr = Mons.draw.text("[J] heal(2)  | [T] self hit       ", Mons.font_black, Mons.draw.msg_screen.line_1, scr)
            let scr = Mons.draw.image(hero_btl_img, Pos32.new(75u,80u,0u), scr) 
            let scr = Mons.draw.image(adve_btl_img, Pos32.new(180u,40u,0u), scr)
            scr
          else
            let scr = Mons.draw.capture_bg(adve_kind.ele, scr)
            let scr = 
              if Mons.Object.is_obj_defeated(adve_obj) then
                let scr = Mons.draw.battle_win_bg(adve_kind.ele, scr)
                let scr = Mons.draw.text("[c] Capture", Mons.font_black, Mons.draw.msg_screen.line_0, scr)
                let scr = Mons.draw.text("[z] Free", Mons.font_black, Mons.draw.msg_screen.line_1, scr)
                Mons.draw.image(adve_btl_img, Pos32.new(180u,40u,0u), scr)
              else
                if Nat.eql(List.length<>(hero_obj.bag), 0) then
                  let scr = Mons.draw.text("GAME OVER", Mons.font_black, Pos32.new(90u,80u,0u), scr)
                  Mons.draw.text("[T] Restart",Mons.font_black, Mons.draw.msg_screen.line_0, scr)
                else
                  let scr = Mons.draw.text("You lost the battle and", Mons.font_white, Pos32.new(16u,26u,0u), scr)
                  let scr = Mons.draw.text("your current Mon.", Mons.font_white, Pos32.new(16u,42u,0u), scr)
                  let scr = Mons.draw.text("[c] I'll do better next time",Mons.font_black, Mons.draw.msg_screen.line_0, scr)
                  Mons.draw.image(hero_btl_img, Pos32.new(75u,80u,0u), scr)
            scr
        else
          Mons.Map.build_sprites(game, scr, hero_pos.value, hero_obj)
      ;
      | cons =>
        if Bool.and(is_standing, adve_kind.portal) then
          let boss_def = Nat.to_u32(List.length<>(hero_obj.bos))
          if U32.gtn(boss_def, hero_idx) then
            let scr = Mons.draw.image(Mons.Assets.text_screen_bg, Pos32.new(120u,80u,0u), scr)
            Mons.draw.text("Press [c] to access next level", Mons.font_black, Pos32.new(30u,135u,0u), scr)
          else
            let scr = Mons.draw.image(Mons.Assets.text_screen_bg, Pos32.new(120u,80u,0u), scr)
            let scr = Mons.draw.text("To access the next level you must", Mons.font_black, Mons.draw.msg_screen.line_0, scr)
            Mons.draw.text("first defeat the boss.", Mons.font_black, Mons.draw.msg_screen.line_1, scr)
        else Mons.Map.build_sprites(game, scr, hero_pos.value, hero_obj)
      ;
      | terrain => Mons.Map.build_sprites(game, scr, hero_pos.value, hero_obj);
    ; // end case stt.game
    | inventory => Mons.draw.bag(hero_obj, scr);

    | capture => // pressed to capture mon
      if stt.full_bag then Mons.draw.full_bag(hero_obj, adve_obj, scr) 
      else Mons.Map.build_sprites(game, scr, hero_pos.value, hero_obj);
  ;    

// Build sprites around the hero
Mons.Map.build_sprites(game: Mons.Game, scr: Image3D, hero_pos: Pos32, hero_obj: Mons.Object): Image3D
  let sprs = Mons.game_sprites(game)
  for spr in sprs with scr:
  // For each pixel of the sprite...
  open spr:
  let len = Image3D.get_length(spr.img)
  for i : U32 = 0u .. len with scr:
    let s_w = Pos32.get_x(Mons.scr_mid)
    let s_h = Pos32.get_y(Mons.scr_mid)
    // The origin global position (centered on hero)
    let h_x = Pos32.get_x(hero_pos)
    let h_y = Pos32.get_y(hero_pos)
    //let o_x = U32.mul(Pos32.get_x(hero_pos.value), 16u)
    //let o_y = U32.mul(Pos32.get_y(hero_pos.value), 16u)
    get o_x o_y = Mons.draw.global_xy(h_x, h_y, hero_obj)
    // Gets the spr global position
    let s_x = spr.x
    let s_y = spr.y
    let s_z = spr.z
    // Gets the pixel global position (its cpos on img is x=128, y=128)
    let xyz = Image3D.get_pos(i, spr.img)
    let v_x = U32.sub(U32.add(Pos32.get_x(xyz),s_x),Pos32.get_x(Mons.vox_mid))
    let v_y = U32.sub(U32.add(Pos32.get_y(xyz),s_y),Pos32.get_y(Mons.vox_mid))
    let v_z = Pos32.get_z(xyz)
    // Temporary: if pixel is out of screen, make it invisible
    let ok0 = U32.lte(U32.sub(o_x, s_w), v_x) // o_x - s_w <= v_x
    let ok1 = U32.ltn(v_x, U32.add(o_x, s_w)) // v_x < o_x + s_w
    let ok2 = U32.lte(U32.sub(o_y, s_h), v_y) // o_y - s_h <= v_y
    let ok3 = U32.ltn(v_y, U32.add(o_y, s_h)) // v_y < o_y + s_h
    //let ok  = List.and([ok0, ok1, ok2, ok3])
    let ok  = Bool.and(ok0, Bool.and(ok1, Bool.and(ok2, ok3)))
    // Computes the pixel position on the final canvas
    let c_x = U32.sub(U32.add(v_x, Pos32.get_x(Mons.scr_mid)), o_x)
    let c_y = U32.sub(U32.add(v_y, Pos32.get_y(Mons.scr_mid)), o_y)
    let c_z = Bool.if<>(ok, v_z, 0u)
    // Pushes the pixel to the scr
    let pos = Pos32.new(c_x, c_y, c_z) // final pixel pos
    let col = Image3D.get_col(i, spr.img) // final pixel col
    Image3D.push(pos, col, scr) // pushes to scr

// For each tick, updates an object
Mons.Object.tick(obj: Mons.Object): Mons.Object
  open obj:
  // Configs the walk animation
  let obj = Mons.Object.set_ani(obj)
    | if U32.gtn(obj.ani, 0u)
      then U32.sub(obj.ani, 2u)
      else obj.ani;
  // Sets the direction based on pad
  let obj = Mons.Object.set_dir(obj)
    | if Mons.Object.is_free_to_move(obj) then
        open obj.pad:
        if obj.pad.u then
          Mons.Dir.up
        else if obj.pad.l then
          Mons.Dir.left
        else if obj.pad.d then
          Mons.Dir.down
        else if obj.pad.r then
          Mons.Dir.right
        else
          obj.dir
      else
        obj.dir;
  obj

Mons.Game.dim(pos: Pos32, map: Mons.Map): U32
  let obj_idx = Mons.Map.get_hero(pos, map)
  let obj = Pair.fst<,>(obj_idx)
  let idx = Pair.snd<,>(obj_idx)
  idx

// Moves an object towards a given direction
Mons.Game.tick_user(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let map = game.map
  let obj_idx = Mons.Map.get_hero(pos, map)
  let obj = Pair.fst<,>(obj_idx)
  let idx = Pair.snd<,>(obj_idx)
  let obj = Mons.Object.tick(obj)
  open obj:
  let old_pos = pos
  let new_pos = Mons.Dir.move(obj.dir, pos)
  let trg = Mons.Map.get_top(new_pos, map)
  open trg:
  let is_walking = Mons.Object.is_walking(obj)
  let is_movfree = Mons.Object.is_free_to_move(obj)
  let is_blocked = Mons.Kind.get_blocks(trg.kin)
  if Bool.and(is_walking, Bool.and(is_movfree, Bool.not(is_blocked))) then
    let obj = Mons.Object.set_ani(obj, 16u)
    let game = Mons.Game.move_obj(old_pos, idx, new_pos, obj, game)
    let game = Mons.Game.set_user_pos(user, new_pos, game)
    game
  else
    Mons.Game.map_set(pos, idx, obj, game)

// For each tick, updates the game state
// TODO: tick objects other than hero
Mons.Game.tick(game: Mons.Game): Mons.Game
  open game:
  for user_pos in Map.to_list<>(game.pos) with game:
    get key pos = user_pos
    let user = Word.from_bits(160, key)
    Mons.Game.tick_user(user, pos, game)

// All valid inputs and its code
Mons.Input.list: List(Pair(Char, Bits))
  let b0 = Bits.0
  let b1 = Bits.1
  let bn = Bits.nil
  [
    {'D', b0(b0(b0(b0(b0(b0(b0(b0(bn))))))))},
    {'W', b0(b0(b0(b0(b0(b0(b0(b1(bn))))))))},
    {'A', b0(b0(b0(b0(b0(b0(b1(b0(bn))))))))},
    {'S', b0(b0(b0(b0(b0(b0(b1(b1(bn))))))))},
    {'U', b0(b0(b0(b0(b0(b1(b0(b0(bn))))))))},
    {'I', b0(b0(b0(b0(b0(b1(b0(b1(bn))))))))},
    {'J', b0(b0(b0(b0(b0(b1(b1(b0(bn))))))))},
    {'K', b0(b0(b0(b0(b0(b1(b1(b1(bn))))))))},
    {'d', b0(b0(b0(b0(b1(b0(b0(b0(bn))))))))},
    {'w', b0(b0(b0(b0(b1(b0(b0(b1(bn))))))))},
    {'a', b0(b0(b0(b0(b1(b0(b1(b0(bn))))))))},
    {'s', b0(b0(b0(b0(b1(b0(b1(b1(bn))))))))},
    {'u', b0(b0(b0(b0(b1(b1(b0(b0(bn))))))))},
    {'i', b0(b0(b0(b0(b1(b1(b0(b1(bn))))))))},
    {'j', b0(b0(b0(b0(b1(b1(b1(b0(bn))))))))},
    {'k', b0(b0(b0(b0(b1(b1(b1(b1(bn))))))))},
    {'P', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'O', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'e', b0(b0(b0(b1(b0(b0(b0(b0(bn))))))))},
    {'E', b0(b0(b0(b1(b0(b0(b0(b1(bn))))))))},
    {'c', b0(b0(b0(b1(b0(b0(b1(b1(bn))))))))},
    {'C', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))},
    {'z', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))},
    {'Z', b0(b0(b1(b0(b0(b0(b0(b0(bn))))))))},
    {'T', b0(b0(b1(b0(b0(b0(b0(b1(bn))))))))} //TODO remove! just using to test heal
  ]

// Maps from chars to their codes
Mons.Input.char_to_code_map: Map(Bits)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(U16.to_bits(char), code, map)

// Maps from codes to their chars
Mons.Input.code_to_char_map: Map(Char)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(code, char, map)

// Serializes an input to its code
Mons.Input.serialize(char: Char): Maybe(Word(256))
  case Map.get<>(U16.to_bits(char), Mons.Input.char_to_code_map) as code:
  | Maybe.none<>;
  | Maybe.some<>(Word.from_bits(256, code.value));

// Deserializes a code to its input
Mons.Input.deserialize(code: Word(256)): Maybe(Char)
  Map.get<>(Bits.slice(8, Word.to_bits<256>(code)), Mons.Input.code_to_char_map)

// Generates an input char from the event down/code info
Mons.Input.char(down: Bool, code: Char): Char
  if down
  then Char.to_upper(code)
  else Char.to_lower(code)

// Online mode room name
Mons.App.room: Word(48)
  Word.from_bits(48, String.to_bits("MON"))

// Startup
Mons.start(online: Bool): App(Mons.Game)
  let screen = Image3D.alloc_capacity(524288u)
  App.new<>
  // Initial state
  | let game_usr = Word.zero(160)
    let game_pos = Map.new<>
    let game_map = Mons.Map.build(Mons.map_source)
    Mons.Game.new(game_usr, game_pos, game_map, Mons.Screen.game('.'));
  // Render function
  | (game) App.Render.vox(Mons.draw(game, screen));
  // Event handlers
  | (event, game)
    if online then // online mode
      case event:
      | init => [
        App.Action.print<>("Starting app."),
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        App.Action.state<>(Mons.Game.set_usr(event.addr, game)),
        App.Action.watch<>(Mons.App.room),
        // Sends a J to init our char. TODO: better initialization.
        let chr = Mons.Input.char(Bool.true, '.')
        case Mons.Input.serialize(chr) as data:
        | App.Action.print<>(""); // unreachable
        | App.Action.post<>(Mons.App.room, data.value);
      ];
      | tick => [
        App.Action.state<>(Mons.Game.tick(game)),
      ];
      | xkey => // send input to server
        let chr = Mons.Input.char(event.down, event.code)
        case Mons.Input.serialize(chr) as data:
        | [];
        | [App.Action.post<>(Mons.App.room, data.value)];;
      | post => // applies input to this post's hero
        // use skp = Debug.log<>("Got post.")
        // use skp = Debug.log<>(Bits.to_string(Word.to_bits<256>(event.data)))
        case Mons.Input.deserialize(event.data) as input:
        | [];
        | [
          // use skp = Debug.log<>(String.concat("Got input:", String.pure(input.value)))
          // use skp = Debug.log<>(String.concat("From user:", Bits.to_string(Word.to_bits<160>(event.addr))))
          open game:
          App.Action.state<>(Mons.Game.cmd(input.value, event.addr, game))
        ];;
    else // offline mode
      case event:
      | init => [
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        let game = Mons.Game.set_usr(event.addr, game)
        let game = Mons.Game.cmd('j', event.addr, game) // inits hero
        App.Action.state<>(game),
      ];
      | tick => [App.Action.state<>(Mons.Game.tick(game))];
      | xkey => [
        open game:
        let chr = Mons.Input.char(event.down, event.code)
        App.Action.state<>(Mons.Game.cmd(chr, game.usr, game))
      ];
      | post => [];;

// Startup (online mode)
Mons.on: App(Mons.Game)
  Mons.start(Bool.true)

// Startup (offline mode)
Mons.off: App(Mons.Game)
  Mons.start(Bool.false)

// Startup (default mode = offline)
Mons: App(Mons.Game)
  Mons.off

//Mons: _
  //let map = Map.new<>
  //let map = Map.set<>(U16.to_bits('i'), 5, map)
  //Map.get<>(U16.to_bits('i'), map)
  //let map = Map.set<>(U16.to_bits('i'), 7)
  //U16.to_bits('i')
//0000000001100001
//0000000001101001
  //Map.get<>(U16.to_bits('h'), Mons.Input.char_to_code_map)
