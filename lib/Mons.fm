// TODO: adicionar uma lista de objetos "tickaveis" pra que não seja necessário
// chamar o tick em todos os objetos do mapa a todo frame, por performance

// GBA position: divide OpenEMU by 2.575

// enter_animation: quando você entra em um tile
// - grass walk animation
// - grass jump animation
// - ground jump animation (fumacinha)

// Exemplo de stack:
// [
//   [(GRASS, z=1)],
//   [(BUSH_BACK, z=2), (BUSH_FRONT, z=16)]
//   [(HERO, z=4..28), (BUSH_ANIM, z=30)]
// ]

// bush_back.png (16x16, a parte de trás do arbusto)
// bush_front.png (16x16, a parte de frente do arbusto)
// bush_anim_000.png (uns 3 frames, 16x16, a animação no arbusto)
// pedir pra maisa: adicionar Z nos voxels das imagens

Mons.placa: Image3D
  Image3D.parse("")

// A Mons sprite
T Mons.Sprite
| Mons.Sprite.new(x: U32, y: U32, z: U32, img: Image3D);

// A direction
T Mons.Dir
| Mons.Dir.right;
| Mons.Dir.up;
| Mons.Dir.left;
| Mons.Dir.down;

T Mons.Action
| Mons.Action.walk(dir: Mons.Dir);

//T Mons.Battle.Action
//| Mons.Battle.Action.atk;
//| Mons.Battle.Action.bag;
//| Mons.Battle.Action.mon;
//| Mons.Battle.Action.run;

// A game object
T Mons.Object
| Mons.Object.new(
  kin: Mons.Kind,   // represent the type of the object
  dir: Mons.Dir,    // direction the object is facing
  wlk: U32,         // number of walk frames to animate
  dmg: U32          // object's current health points
);

// A 2d map of game tiles
Mons.Map: Type
  Map(List(Mons.Object))

// The global game state
T Mons.Game
| Mons.Game.new(
  pos: Pos32, // main hero position
  map: Mons.Map // the game map
);

// THING ID (kin)
T Mons.Kind
| Mons.VOID;
| Mons.HERO;
| Mons.GRASS;
| Mons.BUSH;
| Mons.PLANT_0;
| Mons.ELV_TERRAIN_00;
| Mons.ELV_TERRAIN_01;
| Mons.ELV_TERRAIN_02;
| Mons.OCEAN_M;
| Mons.OCEAN_R;
| Mons.OCEAN_U;
| Mons.OCEAN_L;
| Mons.OCEAN_D;
| Mons.OCEAN_RU;
| Mons.OCEAN_LU;
| Mons.OCEAN_LD;
| Mons.OCEAN_RD;
| Mons.TREE_0_00;
| Mons.TREE_0_01;
| Mons.TENT_00;
| Mons.TENT_01;
| Mons.TENT_02;
| Mons.BIG_TREE_00;
| Mons.BIG_TREE_01;
| Mons.ROCK_PATH_C;
| Mons.CAPIVARA;
| Mons.BEHOLDER;
| Mons.CRONI;
| Mons.ELLIOT;
| Mons.ESPECTRONUS;
| Mons.GAKI;
| Mons.GORR;
| Mons.LAMURIA;
| Mons.RAFIRE;
| Mons.VARGOULI;

// Sprites are centered at 128x128
Mons.vox_mid: Pos32
  Pos32.new(128u, 128u, 0u) 

// The game screen is 256x256 pixels
Mons.scr_mid: Pos32
  Pos32.new(120u, 80u, 0u)

// The void tile
Mons.Object.void: Mons.Object
  Mons.Object.new(Mons.VOID, Mons.Dir.down, 0u, 0u)

// Gets an object's direction
Mons.Object.get_dir(obj: Mons.Object): Mons.Dir
  open obj:
  obj.dir

// Sets an object's direction
Mons.Object.set_dir(obj: Mons.Object, dir: Mons.Dir): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, dir, obj.wlk, obj.dmg)

// Gets an object's walk animation frames
Mons.Object.get_wlk(obj: Mons.Object): U32
  open obj:
  obj.wlk

// Sets an object's walk animation frames
Mons.Object.set_wlk(obj: Mons.Object, wlk: U32): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, obj.dir, wlk, obj.dmg)

// Gets an object's current HP
Mons.Object.get_dmg(obj: Mons.Object): U32
  open obj:
  obj.dmg

// Sets an object's current HP
Mons.Object.set_dmg(obj: Mons.Object, dmg: U32): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, obj.dir, obj.wlk, dmg)

// Hits an object, damaging it
Mons.Object.hit(obj: Mons.Object, dmg: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.add(Mons.Object.get_dmg(obj), dmg))

// Returns the image of a tile
Mons.Object.get_images(t_x: U32, t_y: U32, obj: Mons.Object): List(Image3D)
  open obj:
  case obj.kin:
  | Mons.VOID => [];
  | Mons.HERO => 
    //0 = parado
    //1 = pe direito pra frente
    //2 = pe esquerdo pra frente
    //let wlk_num = 
    if U32.eql(obj.wlk, 0u) then
      case obj.dir:
      | right => [Mons.Assets.boy_r_0];
      | up    => [Mons.Assets.boy_u_0];
      | left  => [Mons.Assets.boy_l_0];
      | down  => [Mons.Assets.boy_d_0];
    else
      if U32.eql(U32.mod(U32.add(t_x,t_y),2u), 0u) then
        case obj.dir:
        | right => [Mons.Assets.boy_r_1];
        | up    => [Mons.Assets.boy_u_1];
        | left  => [Mons.Assets.boy_l_1];
        | down  => [Mons.Assets.boy_d_1];
      else
        case obj.dir:
        | right => [Mons.Assets.boy_r_2];
        | up    => [Mons.Assets.boy_u_2];
        | left  => [Mons.Assets.boy_l_2];
        | down  => [Mons.Assets.boy_d_2];;
  | Mons.GRASS => [Mons.Assets.dark_grass_0];
  | Mons.BUSH => [Mons.Assets.bush_0, Mons.Assets.bush_1];
  | Mons.PLANT_0 => [Mons.Assets.home_decor_plant_0];
  | Mons.ELV_TERRAIN_00 => [Mons.Assets.dark_grass_elevated_00];
  | Mons.ELV_TERRAIN_01 => [Mons.Assets.dark_grass_elevated_01];
  | Mons.ELV_TERRAIN_02 => [Mons.Assets.dark_grass_elevated_02];
  | Mons.OCEAN_M => [Mons.Assets.ocean_m];
  | Mons.OCEAN_R => [Mons.Assets.ocean_r];
  | Mons.OCEAN_U => [Mons.Assets.ocean_u];
  | Mons.OCEAN_L => [Mons.Assets.ocean_l];
  | Mons.OCEAN_D => [Mons.Assets.ocean_d];
  | Mons.OCEAN_RU => [Mons.Assets.ocean_ru];
  | Mons.OCEAN_LU => [Mons.Assets.ocean_lu];
  | Mons.OCEAN_LD => [Mons.Assets.ocean_ld];
  | Mons.OCEAN_RD => [Mons.Assets.ocean_rd];
  | Mons.TREE_0_00 => [Mons.Assets.tree_0_00];
  | Mons.TREE_0_01 => [Mons.Assets.tree_0_01];
  | Mons.TENT => [Mons.Assets.tent_00];
  | Mons.TENT => [Mons.Assets.tent_01];
  | Mons.TENT => [Mons.Assets.tent_02];
  | Mons.BIG_TREE_00 => [Mons.Assets.bigtree0_00];
  | Mons.BIG_TREE_01 => [Mons.Assets.bigtree0_01];
  | Mons.ROCK_PATH_C => [Mons.Assets.rock_path_0_c];
  | Mons.CAPIVARA => [Mons.Assets.mons_bath_d_0];
  | Mons.BEHOLDER => [Mons.Assets.mons_beholder_d_0];
  | Mons.CRONI => [Mons.Assets.mons_croni_d_0];
  | Mons.ELLIOT => [Mons.Assets.mons_elliot_d_0];
  | Mons.ESPECTRONUS => [Mons.Assets.mons_espectronus_d_0];
  | Mons.GAKI => [Mons.Assets.mons_gaki_d_0];
  | Mons.GORR => [Mons.Assets.mons_gorr_d_0];
  | Mons.LAMURIA => [Mons.Assets.mons_lamuria_d_0];
  | Mons.RAFIRE => [Mons.Assets.mons_rafire_d_0]; 
  | Mons.VARGOULI => [Mons.Assets.mons_vargouli_d_0];
  
// An empty map
Mons.Map.new: Mons.Map
  Map.new<>

// Adds a tile to a position on the map
Mons.Map.set_list(pos: Pos32, objs: List(Mons.Object), map: Mons.Map): Mons.Map
  Map.set<>(U32.to_bits(Pos32.set_z(pos,0u)), objs, map)

// Gets the tile stored on a position on the map
Mons.Map.get_list(pos: Pos32, map: Mons.Map): List(Mons.Object)
  case Map.get<>(U32.to_bits(Pos32.set_z(pos,0u)), map) as got:
  | [];
  | got.value;

// Gets the nth object of a tile
Mons.Map.get(pos: Pos32, map: Mons.Map): Mons.Object
  let list = Mons.Map.get_list(pos, map)
  case List.at<>(U32.to_nat(Pos32.get_z(pos)), list) as got:
  | Mons.Object.void;
  | got.value;

// Sets the nth object of a tile
Mons.Map.set(pos: Pos32, val: Mons.Object, map: Mons.Map): Mons.Map
  let list = Mons.Map.get_list(pos, map)
  let list = List.update_at<>(U32.to_nat(Pos32.get_z(pos)), () val, list)
  Mons.Map.set_list(pos, list, map)

// Pushes an object to the top of a tile
Mons.Map.push(pos: Pos32, obj: Mons.Object, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.cons<>(obj, objs)
  Mons.Map.set_list(pos, objs, map)

// Pops an object from the top of a tile
Mons.Map.pop(pos: Pos32, map: Mons.Map): Pair(Mons.Map, Mons.Object)
  let objs = Mons.Map.get_list(pos, map)
  case objs:
  | Pair.new<,>(map, Mons.Object.void);
  | let map = Mons.Map.set_list(pos, objs.tail, map)
    Pair.new<,>(map, objs.head);

// Converts a tile code (ex: ".g") into a list of obs
Mons.Map.tile_of(code: String): List(Mons.Object)
  if String.eql(code, ".g") then
    [Mons.Map.tile_of_one(Mons.GRASS)]
  else if String.eql(code, "bg") then
    [
      Mons.Map.tile_of_one(Mons.BUSH),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "hg") then
    [
      Mons.Map.tile_of_one(Mons.HERO),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "pg") then
    [
      Mons.Map.tile_of_one(Mons.PLANT_0),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  
  else if String.eql(code, "t0") then
    [Mons.Map.tile_of_one(Mons.ELV_TERRAIN_00)]
  else if String.eql(code, "t1") then
    [Mons.Map.tile_of_one(Mons.ELV_TERRAIN_01)]
  else if String.eql(code, "t2") then
    [Mons.Map.tile_of_one(Mons.ELV_TERRAIN_02)]

  else if String.eql(code, "w0") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_LU),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w1") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_U),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "wm") then
    [Mons.Map.tile_of_one(Mons.OCEAN_M)]
  else if String.eql(code, "w2") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_RU),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w3") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_L),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w4") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_R),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w5") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_LD),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w6") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_D),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "w7") then
    [
      Mons.Map.tile_of_one(Mons.OCEAN_RD),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "T0") then
    [
      Mons.Map.tile_of_one(Mons.TREE_0_00),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "T1") then
    [
      Mons.Map.tile_of_one(Mons.TREE_0_01),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "/0") then
    [
      Mons.Map.tile_of_one(Mons.TENT_00),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "/1") then
    [ Mons.Map.tile_of_one(Mons.TENT_01) ]
  else if String.eql(code, "/2") then
    [
      Mons.Map.tile_of_one(Mons.TENT_02),
      Mons.Map.tile_of_one(Mons.GRASS),
    ]
  else if String.eql(code, "B0") then
    [ 
      Mons.Map.tile_of_one(Mons.BIG_TREE_00),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "B1") then
    [ 
      Mons.Map.tile_of_one(Mons.BIG_TREE_01),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, ".p") then
    [ 
      Mons.Map.tile_of_one(Mons.ROCK_PATH_C),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "30") then
    [ 
      Mons.Map.tile_of_one(Mons.CAPIVARA),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "31") then
    [ 
      Mons.Map.tile_of_one(Mons.BEHOLDER),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "32") then
    [ 
      Mons.Map.tile_of_one(Mons.CRONI),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "33") then
    [ 
      Mons.Map.tile_of_one(Mons.ELLIOT),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "34") then
    [ 
      Mons.Map.tile_of_one(Mons.ESPECTRONUS),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "35") then
    [ 
      Mons.Map.tile_of_one(Mons.GAKI),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "36") then
    [ 
      Mons.Map.tile_of_one(Mons.GORR),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "37") then
    [ 
      Mons.Map.tile_of_one(Mons.LAMURIA),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "38") then
    [ 
      Mons.Map.tile_of_one(Mons.RAFIRE),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else if String.eql(code, "39") then
    [ 
      Mons.Map.tile_of_one(Mons.VARGOULI),
      Mons.Map.tile_of_one(Mons.GRASS)
    ]
  else
    []

Mons.Map.tile_of_one(tile_kin: Mons.Kind): Mons.Object
  Mons.Object.new(tile_kin, Mons.Dir.down, 0u, 0u)

// Converts a string map source to an actual map
Mons.Map.load(code: String): Mons.Map
  let code = String.slice(1, Nat.pred(String.length(code)), code)
  let rows = String.split(code, "\n")
  let rows = List.map<,>(String.chunks_of(2), rows)
  let mapw = List.length.u32<>(rows)
  let maph = List.length.u32<>(List.head_with_default<>([], rows))
  let objs = List.map<,>(List.map<,>(Mons.Map.tile_of), rows)
  let objs = List.flatten<>(objs)
  List.ifoldr.u32<,>
  | Mons.Map.new;
  | (i, objs, map)
    let o_x = U32.sub(2048u, U32.div(mapw, 2u))
    let o_y = U32.sub(2048u, U32.div(maph, 2u))
    let p_x = U32.add(U32.mod(i, mapw), o_x)
    let p_y = U32.add(U32.div(i, maph), o_y)
    let p_z = 0u
    let pos = Pos32.new(p_x, p_y, p_z)
    Mons.Map.set_list(pos, objs, map);
  | objs;

// Gets the hero position
Mons.Game.get_hero_pos(game: Mons.Game): Pos32
  open game:
  game.pos

// Sets the hero position
Mons.Game.set_hero_pos(pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(pos, game.map)

// Sets the game map
Mons.Game.set_map(map: Mons.Map, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.pos, map)

Mons.Kind.blocks(kin: Mons.Kind): Bool
  case kin:
  | Mons.VOID           => Bool.false;
  | Mons.HERO           => Bool.false;
  | Mons.GRASS          => Bool.false;
  | Mons.BUSH           => Bool.false;
  | Mons.PLANT_0        => Bool.true;
  | Mons.ELV_TERRAIN_00 => Bool.false;
  | Mons.ELV_TERRAIN_01 => Bool.false;
  | Mons.ELV_TERRAIN_02 => Bool.false;
  | Mons.OCEAN_L        => Bool.true;
  | Mons.OCEAN_D        => Bool.true;
  | Mons.OCEAN_M        => Bool.true;
  | Mons.OCEAN_R        => Bool.true;
  | Mons.OCEAN_U        => Bool.true;
  | Mons.OCEAN_LD       => Bool.true;
  | Mons.OCEAN_LU       => Bool.true;
  | Mons.OCEAN_RD       => Bool.true;
  | Mons.OCEAN_RU       => Bool.true;
  | Mons.TREE_0_00      => Bool.false;
  | Mons.TREE_0_01      => Bool.false;
  | Mons.TENT           => Bool.false;
  | Mons.TENT           => Bool.false;
  | Mons.TENT           => Bool.false;
  | BIG_TREE_00         => Bool.true;
  | BIG_TREE_01         => Bool.true;
  | ROCK_PATH_C         => Bool.false;
  | Mons.CAPIVARA       => Bool.false;
  | Mons.BEHOLDER       => Bool.false;
  | Mons.CRONI          => Bool.false;
  | Mons.ELLIOT         => Bool.false;
  | Mons.ESPECTRONUS    => Bool.false;
  | Mons.GAKI           => Bool.false;
  | Mons.GORR           => Bool.false;
  | Mons.LAMURIA        => Bool.false;
  | Mons.RAFIRE         => Bool.false;
  | Mons.VARGOULI       => Bool.false;

Mons.Kind.battles(kin: Mons.Kind): Bool
  case kin:
  | Mons.VOID           => Bool.false;
  | Mons.HERO           => Bool.false;
  | Mons.GRASS          => Bool.false;
  | Mons.BUSH           => Bool.false;
  | Mons.PLANT_0        => Bool.false;
  | Mons.ELV_TERRAIN_00 => Bool.false;
  | Mons.ELV_TERRAIN_01 => Bool.false;
  | Mons.ELV_TERRAIN_02 => Bool.false;
  | Mons.OCEAN_L        => Bool.false;
  | Mons.OCEAN_D        => Bool.false;
  | Mons.OCEAN_M        => Bool.false;
  | Mons.OCEAN_R        => Bool.false;
  | Mons.OCEAN_U        => Bool.false;
  | Mons.OCEAN_LD       => Bool.false;
  | Mons.OCEAN_LU       => Bool.false;
  | Mons.OCEAN_RD       => Bool.false;
  | Mons.OCEAN_RU       => Bool.false;
  | Mons.TREE_0_00      => Bool.false;
  | Mons.TREE_0_01      => Bool.false;
  | Mons.TENT           => Bool.false;
  | Mons.TENT           => Bool.false;
  | Mons.TENT           => Bool.false;
  | BIG_TREE_00         => Bool.false;
  | BIG_TREE_01         => Bool.false;
  | ROCK_PATH_C         => Bool.false;
  | Mons.CAPIVARA       => Bool.true;
  | Mons.BEHOLDER       => Bool.true;
  | Mons.CRONI          => Bool.true;
  | Mons.ELLIOT         => Bool.true;
  | Mons.ESPECTRONUS    => Bool.true;
  | Mons.GAKI           => Bool.true;
  | Mons.GORR           => Bool.true;
  | Mons.LAMURIA        => Bool.true;
  | Mons.RAFIRE         => Bool.true;
  | Mons.VARGOULI       => Bool.true;

Mons.Kind.get_battle_img(kin: Mons.Kind, up: Bool): Image3D
  case kin:
  | Mons.VOID           => Mons.Assets.battle_croni_u;
  | Mons.HERO           => Mons.Assets.battle_croni_u;
  | Mons.GRASS          => Mons.Assets.battle_croni_u;
  | Mons.BUSH           => Mons.Assets.battle_croni_u;
  | Mons.PLANT_0        => Mons.Assets.battle_croni_u;
  | Mons.ELV_TERRAIN_00 => Mons.Assets.battle_croni_u;
  | Mons.ELV_TERRAIN_01 => Mons.Assets.battle_croni_u;
  | Mons.ELV_TERRAIN_02 => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_L        => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_D        => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_M        => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_R        => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_U        => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_LD       => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_LU       => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_RD       => Mons.Assets.battle_croni_u;
  | Mons.OCEAN_RU       => Mons.Assets.battle_croni_u;
  | Mons.TREE_0_00      => Mons.Assets.battle_croni_u;
  | Mons.TREE_0_01      => Mons.Assets.battle_croni_u;
  | Mons.TENT           => Mons.Assets.battle_croni_u;
  | Mons.TENT           => Mons.Assets.battle_croni_u;
  | Mons.TENT           => Mons.Assets.battle_croni_u;
  | BIG_TREE_00         => Mons.Assets.battle_croni_u;
  | BIG_TREE_01         => Mons.Assets.battle_croni_u;
  | ROCK_PATH_C         => Mons.Assets.battle_croni_u;
  | Mons.CAPIVARA       => case up: |Mons.Assets.battle_bath_u; |Mons.Assets.battle_bath_d;;
  | Mons.BEHOLDER       => case up: |Mons.Assets.battle_beholder_u; |Mons.Assets.battle_beholder_d;;
  | Mons.CRONI          => case up: |Mons.Assets.battle_croni_u; |Mons.Assets.battle_croni_d;;
  | Mons.ELLIOT         => case up: |Mons.Assets.battle_elliot_u; |Mons.Assets.battle_elliot_d;;
  | Mons.ESPECTRONUS    => case up: |Mons.Assets.battle_espectronus_u; |Mons.Assets.battle_espectronus_d;;
  | Mons.GAKI           => case up: |Mons.Assets.battle_gaki_u; |Mons.Assets.battle_gaki_d;;
  | Mons.GORR           => case up: |Mons.Assets.battle_gorr_u; |Mons.Assets.battle_gorr_d;;
  | Mons.LAMURIA        => case up: |Mons.Assets.battle_lamuria_u; |Mons.Assets.battle_lamuria_d;;
  | Mons.RAFIRE         => case up: |Mons.Assets.battle_rafire_u; |Mons.Assets.battle_rafire_d;;
  | Mons.VARGOULI       => case up: |Mons.Assets.battle_vargouli_u; |Mons.Assets.battle_vargouli_d;;

// Moves the hero to a given direction
Mons.Game.walk(pos: Pos32, dir: Mons.Dir, game: Mons.Game): Mons.Game
  let old_pos = pos
  let new_pos
    = case dir:
    | Pos32.add(old_pos, Pos32.new(1u, 0u, 0u));
    | Pos32.sub(old_pos, Pos32.new(0u, 1u, 0u));
    | Pos32.sub(old_pos, Pos32.new(1u, 0u, 0u));
    | Pos32.add(old_pos, Pos32.new(0u, 1u, 0u));
  //let new_pos = Pos32.set_z(new_pos, 0u)
  open game:
  let map = game.map
  get map obj = Mons.Map.pop(old_pos, map)
  let wlk = Mons.Object.get_wlk(obj)
  let trg = Mons.Map.get(new_pos, map)
  open trg:
  let is_walking = U32.gtn(wlk, 0u)
  let is_blocked = Mons.Kind.blocks(trg.kin)
  if Bool.or(is_walking, is_blocked) then
    let map = Mons.Map.push(old_pos, obj, map)
    Mons.Game.new(old_pos, map)
  else
    let obj = Mons.Object.set_dir(obj, dir)
    let obj = Mons.Object.set_wlk(obj, 16u)
    let map = Mons.Map.push(new_pos, obj, map)
    Mons.Game.new(new_pos, map)

Mons.Game.act(pos: Pos32, act: Mons.Action, game: Mons.Game): Mons.Game
  case act:
  | Mons.Game.walk(pos, act.dir, game);

Mons.Game.cmd(pos: Pos32, key: Char, game: Mons.Game): Mons.Game
  let hero_pos = pos
  let adve_pos = Pos32.add(pos, Pos32.new(0u,0u,1u))
  open game:
  case Mons.key_to_dir(key) as dir:
  | if U16.eql(key, 'U') then
      // TODO: make a proper get_battle(tile_pos) function
      let hero_obj = Mons.Map.get(hero_pos, game.map)
      let adve_obj = Mons.Map.get(adve_pos, game.map)
      let adve_obj = Mons.Object.hit(adve_obj, 1u)
      Mons.Game.set_map(Mons.Map.set(adve_pos, adve_obj, game.map), game)
    else
      game;
  | Mons.Game.act(pos, Mons.Action.walk(dir.value), game);

// Converts a keyboard key to a direction:
// A = [-1,  0,  0]
// D = [ 1,  0,  0]
// W = [ 0, -1,  0]
// S = [ 0,  1,  0]
// * = [ 0,  0,  0]
Mons.key_to_dir(key_code: U16): Maybe(Mons.Dir)
  if U16.eql(key_code, 'A') then
    Maybe.some<>(Mons.Dir.left)
  else if U16.eql(key_code, 'D') then
    Maybe.some<>(Mons.Dir.right)
  else if U16.eql(key_code, 'W') then
    Maybe.some<>(Mons.Dir.up)
  else if U16.eql(key_code, 'S') then
    Maybe.some<>(Mons.Dir.down)
  else
    Maybe.none<>

// Given a tile (x, y) and an object, returns its global (x, y) positions
Mons.draw.global_xy(t_x: U32, t_y: U32, obj: Mons.Object): Pair(U32, U32)
  case obj:
  | let wlk = Mons.Object.get_wlk(obj)
    let dir = Mons.Object.get_dir(obj)
    let g_x = U32.mul(t_x, 16u)
    let g_y = U32.mul(t_y, 16u)
    let g_x
      = case dir:
      | right => U32.sub(g_x, wlk);
      | up    => g_x;
      | left  => U32.add(g_x, wlk);
      | down  => g_x;
    let g_y
      = case dir:
      | right => g_y;
      | up    => U32.add(g_y, wlk);
      | left  => g_y;
      | down  => U32.sub(g_y, wlk);
    Pair.new<,>(g_x, g_y);

// Converts the game state to a list of sprites to be rendered
// TODO: for some reason, using a `case obj` here causes the
// function not to type check anymore. Investigate why.
Mons.game_sprites(game: Mons.Game): List(Mons.Sprite)
  case game:
  | let sprs = []
    let c_x = Pos32.get_x(game.pos)
    let c_y = Pos32.get_y(game.pos)
    let c_z = Pos32.get_z(game.pos)
    for x : U32 = 0u .. 19u with sprs:
      for y : U32 = 0u .. 19u with sprs:
        let t_x = U32.add(U32.sub(c_x, 9u), x)
        let t_y = U32.add(U32.sub(c_y, 9u), y)
        let t_z = c_z
        let pos = Pos32.new(t_x, t_y, t_z)
        let got = Map.get<>(U32.to_bits(pos), game.map)
        case got:
        | sprs;
        | for obj in List.reverse<>(got.value) with sprs:
            for img in Mons.Object.get_images(t_x, t_y, obj) with sprs:
              let wlk = Mons.Object.get_wlk(obj)
              let dir = Mons.Object.get_dir(obj)
              get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
              let s_z = t_z
              let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
              List.cons<>(spr, sprs);;

// Draws an ASCII char to a position using 
Mons.draw.char(chr: Char, chr_pos: Pos32, scr: Image3D): Image3D
  case Mons.font.get_img(chr, Mons.font.map) as got:
  | scr;
  | let img = got.value
    let img_len = Image3D.get_length(img)
    let scr = for i : U32 = 0u .. img_len:
      let vox_pos = Image3D.get_pos(i, img)
      let pos = Pos32.sub(Pos32.add(chr_pos, vox_pos), Mons.vox_mid)
      let col = Image3D.get_col(i, img)
      Image3D.push(pos, col, scr)
    scr;

// Draws an ASCII text to a position
Mons.draw.text(txt: String, chr_pos: Pos32, scr: Image3D): Image3D
  for pair in List.indices.u32<>(String.to_list(txt)) with scr:
    get i chr = pair
    let add_pos = Pos32.new(U32.mul(i,6u), 0u, 0u)
    Mons.draw.char(chr, Pos32.add(chr_pos, add_pos), scr)

// Draws a sprite to a position
Mons.draw.image(img: Image3D, pos: Pos32, scr: Image3D): Image3D
  let len = Image3D.get_length(img)
  for i : U32 = 0u .. len with scr:
    let pix_pos = Image3D.get_pos(i, img)
    let pix_col = Image3D.get_col(i, img)
    let pix_pos = Pos32.sub(Pos32.add(pos, pix_pos), Mons.vox_mid)
    Image3D.push(pix_pos, pix_col, scr)

// Draws the game to screen
Mons.draw(game: Mons.Game, scr: Image3D): Image3D
  open game:
  let hero_pos = game.pos
  let hero_obj = Mons.Map.get(Pos32.set_z(hero_pos,0u), game.map)
  let adve_obj = Mons.Map.get(Pos32.set_z(hero_pos,1u), game.map)
  open hero_obj:
  open adve_obj:
  let hero_chp = U32.sub(32u, hero_obj.dmg)
  let adve_chp = U32.sub(32u, adve_obj.dmg)
  let hero_kin = Mons.Kind.get_battle_img(hero_obj.kin, Bool.true)
  let adve_kin = Mons.Kind.get_battle_img(adve_obj.kin, Bool.false)
  let hero_txt = String.flatten(["CRONI: ", U32.to_string(hero_chp), " HP"])
  let adve_txt = String.flatten(["BATH: " , U32.to_string(adve_chp), " HP"])
  //let hero_btl =
    //if U32.gtn(Mons.Object.get_wlk(hero_obj), 0u)
    //then Maybe.none<>
    //else Mons.Object.get_btl(hero_obj)
  let scr = Image3D.clear(scr)
  // When hero is in a battle, draw it...
  let is_standing = U32.eql(Mons.Object.get_wlk(hero_obj),0u)
  let is_battling = Mons.Kind.battles(adve_obj.kin)
  if Bool.and(is_standing, is_battling) then
    let src = Mons.draw.image(Mons.Assets.battle_grass_bg, Pos32.new(120u,80u,0u), scr)
    let scr = Mons.draw.text(hero_txt, Pos32.new(130u,104u,0u), scr)
    let scr = Mons.draw.text(adve_txt, Pos32.new(25u,26u,0u), scr)
    let scr = Mons.draw.text("[U] SHADOW BALL   | [I] _           ", Pos32.new(16u,128u,0u), scr)
    let scr = Mons.draw.text("[J] _             | [K] _           ", Pos32.new(16u,144u,0u), scr)
    let scr = Mons.draw.image(hero_kin, Pos32.new(75u,80u,0u), scr) 
    let scr = Mons.draw.image(adve_kin, Pos32.new(180u,40u,0u), scr)
    scr
  // When hero isn't battling, draw map...
  else 
    let sprs = Mons.game_sprites(game)
    // For each sprite around the hero...
    for spr in sprs with scr:
      // For each pixel of the sprite...
      open spr:
      let len = Image3D.get_length(spr.img)
      for i : U32 = 0u .. len with scr:
        let s_w = Pos32.get_x(Mons.scr_mid)
        let s_h = Pos32.get_y(Mons.scr_mid)
        // The origin global position (centered on hero)
        let h_x = Pos32.get_x(hero_pos)
        let h_y = Pos32.get_y(hero_pos)
        //let o_x = U32.mul(Pos32.get_x(hero_pos), 16u)
        //let o_y = U32.mul(Pos32.get_y(hero_pos), 16u)
        get o_x o_y = Mons.draw.global_xy(h_x, h_y, hero_obj)
        // Gets the spr global position
        let s_x = spr.x
        let s_y = spr.y
        let s_z = spr.z
        // Gets the pixel global position (its cpos on img is x=128, y=128)
        let xyz = Image3D.get_pos(i, spr.img)
        let v_x = U32.sub(U32.add(Pos32.get_x(xyz),s_x),Pos32.get_x(Mons.vox_mid))
        let v_y = U32.sub(U32.add(Pos32.get_y(xyz),s_y),Pos32.get_y(Mons.vox_mid))
        let v_z = Pos32.get_z(xyz)
        // Temporary: if pixel is out of screen, make it invisible
        let ok0 = U32.lte(U32.sub(o_x, s_w), v_x) // o_x - s_w <= v_x
        let ok1 = U32.ltn(v_x, U32.add(o_x, s_w)) // v_x < o_x + s_w
        let ok2 = U32.lte(U32.sub(o_y, s_h), v_y) // o_y - s_h <= v_y
        let ok3 = U32.ltn(v_y, U32.add(o_y, s_h)) // v_y < o_y + s_h
        //let ok  = List.and([ok0, ok1, ok2, ok3])
        let ok  = Bool.and(ok0, Bool.and(ok1, Bool.and(ok2, ok3)))
        // Computes the pixel position on the final canvas
        let c_x = U32.sub(U32.add(v_x, Pos32.get_x(Mons.scr_mid)), o_x)
        let c_y = U32.sub(U32.add(v_y, Pos32.get_y(Mons.scr_mid)), o_y)
        let c_z = Bool.if<>(ok, v_z, 0u)
        // Pushes the pixel to the scr
        let pos = Pos32.new(c_x, c_y, c_z) // final pixel pos
        let col = Image3D.get_col(i, spr.img) // final pixel col
        Image3D.push(pos, col, scr) // pushes to scr

// For each tick, updates an object
Mons.Object.tick(obj: Mons.Object): Mons.Object
  open obj:
  let wlk =
    if U32.gtn(obj.wlk, 0u) then
      U32.sub(obj.wlk, 2u)
    else
      obj.wlk
  Mons.Object.new(obj.kin, obj.dir, wlk, obj.dmg)

// For each tick, updates the game state
Mons.Game.tick(game: Mons.Game): Mons.Game
  open game:
  let pos = game.pos
  let map = 
    def with_tile(objs)
      def with_obj(obj)
        Mons.Object.tick(obj)
      List.map<,>(with_obj, objs)
    Map.map<,>(with_tile, game.map)
  Mons.Game.new(pos, map)

// Examples
// ========

// An example map
//Mons.example_map: Mons.Map
  //let grass = Mons.Object.new(Mons.GRASS, Mons.Dir.down)
  //let hero = Mons.Object.new(Mons.HERO, Mons.Dir.down)
  //let bush = Mons.Object.new(Mons.BUSH, Mons.Dir.down)
  //let map = Mons.Map.new
  //let map = Mons.Map.set(Pos32.new(2047u, 2047u, 0u), [
    //grass,
    //bush,
  //], map)
  //let map = Mons.Map.set(Pos32.new(2048u, 2047u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2049u, 2047u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2047u, 2048u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2048u, 2048u, 0u), [
    //hero,
    //grass,
  //], map)
  //let map = Mons.Map.set(Pos32.new(2049u, 2048u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2047u, 2049u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2048u, 2049u, 0u), [grass], map)
  //let map = Mons.Map.set(Pos32.new(2049u, 2049u, 0u), [grass], map)
  //map

Mons.example_map: Mons.Map
  Mons.Map.load(Mons.map_source)

// An example game
Mons.example_game: Mons.Game
  Mons.Game.new(Pos32.new(2048u, 2048u, 0u), Mons.example_map)

// The entire game as an App
Mons: App(Mons.Game)
  let screen = Image3D.alloc_capacity(524288u)
  def init
    Mons.example_game
  def draw(game)
    App.Render.vox(Mons.draw(game, screen))
  def when(event, game)
    case event:
    | init => [
      let width = U32.mul(Pos32.get_x(Mons.scr_mid), 2u)
      let height = U32.mul(Pos32.get_y(Mons.scr_mid), 2u)
      App.Action.resize<>(width, height)
    ];
    | tick => [
      App.Action.state<>(Mons.Game.tick(game))
    ];
    | xkey =>
      open game:
      if event.down then
        [App.Action.state<>(Mons.Game.cmd(game.pos, event.code, game))]
      else
        [];
    | post => [];
  App.new<>(init, draw, when)
