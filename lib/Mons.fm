// GBA position: divide OpenEMU by 2.575

Mons.placa: Image3D
  Image3D.parse("")

// A Mons sprite
T Mons.Sprite
| Mons.Sprite.new(x: U32, y: U32, z: U32, img: Image3D);

// A direction
T Mons.Dir
| Mons.Dir.right;
| Mons.Dir.up;
| Mons.Dir.left;
| Mons.Dir.down;

T Mons.Map.Dir
| Mons.Map.Dir.right; // r
| Mons.Map.Dir.up; // u
| Mons.Map.Dir.left; // l
| Mons.Map.Dir.down; // d
| Mons.Map.Dir.middle; // m

T Mons.Map.Dir.expanded
| Mons.Map.Dir.expanded.right; // r
| Mons.Map.Dir.expanded.up; // u
| Mons.Map.Dir.expanded.left; // l
| Mons.Map.Dir.expanded.down; // d
| Mons.Map.Dir.expanded.middle; // m
| Mons.Map.Dir.expanded.right_up; // ru
| Mons.Map.Dir.expanded.right_down; // rd
| Mons.Map.Dir.expanded.left_up; // lu
| Mons.Map.Dir.expanded.left_down; // ld
// | Mons.Map.Dir.expanded.circle; // c

//T Mons.Action
//| Mons.Action.walk(dir: Mons.Dir);


T Mons.Sign
| Mons.Sign.minus;
| Mons.Sign.zero;
| Mons.Sign.plus;

T Mons.Pad
| Mons.Pad.new(r: Bool, u: Bool, l: Bool, d: Bool);

// A game object
T Mons.Object
| Mons.Object.new(
  kin: Mons.Kind, // represent the type of the object
  dir: Mons.Dir,  // direction the object is facing
  pad: Mons.Pad,  // movement key pad
  ani: U32,       // number of walk frames to animate
  dmg: U32,       // object's current health points
  bag: List(Mons.Object), // store normal Mons
  mon: U32, // idx of the current Mon. Default 0u
  bos: List(Mons.Object), // store Mons that are boss
  cap: Pair(U32, List(Mons.Object)), // store the quantity of Mons and a copy of the captured during game
  idl: U32, // frame for idle animation
  eff: Mons.Effect
);

T Mons.Attr
| Mons.Attr.new(
  blocks: Bool,
  mhp: U32,
  atk: U32,
  name: String,
  wlk: (x: U32) -> (y: U32) -> (obj_ani: U32) -> (obj_dir: Mons.Dir) -> List(Image3D), // walk
  idl: List(Image3D), // idle
  pic: Image3D,
  battle_spr: (is_up: Bool) -> Image3D,
  skills: List(Mons.Skill)
);

// A 2d map of game tiles
Mons.Map: Type
  Map(List(Mons.Object))

// The global game state
T Mons.Game
| Mons.Game.new(
  usr: Word(160), // player name
  pos: Map(Pos32), // players positions
  map: Mons.Map, // the game map
  stt: Mons.Screen, // the current state of the game
  tik: U32
);

T Mons.Screen
| Mons.Screen.introduction(step: U32); // step: number identifying the completion of scene
| Mons.Screen.intro_select(idx: U32); // idx: used to choose a Mon
| Mons.Screen.game(cmd: Char, turn: Mons.Turn); // cmd: movement
| Mons.Screen.inventory(idx: U32);
| Mons.Screen.capture_mon(
  idx: U32, // idx of the Mon to be replaced
  full_bag: Bool);

T Mons.Turn
| Mons.Turn.new(
  exec_hero: Bool, // if actions of the hero will be executed
  hero_skill: Mons.Skill, // skill used by the first player
  adve_skill: Mons.Skill, // skill used by the second player
  play: U32 // number of plays made
);

T Mons.Type
| Mons.Type.normal;
| Mons.Type.earth;
| Mons.Type.fire;
| Mons.Type.water;
| Mons.Type.grass;
| Mons.Type.electric;
| Mons.Type.psychic;
| Mons.Type.ice;
| Mons.Type.light;
| Mons.Type.darkness;

Mons.global_scr_mid: Pos32
  Pos32.new(2048u, 2048u, 0u) // default z is 0

// Gets an imagem map, the object position on it and transforms to a global pos
Mons.image_to_global(width: U32, height: U32, x: U32, y: U32, lvl: U32): Pos32
  let g_x = Pos32.get_x(Mons.global_scr_mid)
  let g_y = Pos32.get_y(Mons.global_scr_mid)
  let mid_width  = U32.div(width, 2u)
  let mid_height = U32.div(height, 2u)
  let mid_x_diff = U32.sub(mid_width, x)
  let mid_y_diff = U32.sub(mid_height, y)
  let upd_g_x =
    if U32.gtn(x, mid_width) then  U32.add(g_x, U32.sub(x, mid_width))
    else if U32.ltn(x, mid_width) then U32.sub(g_x, U32.sub(mid_width, x))
    else mid_width
  let upd_g_y = 
    if U32.gtn(y, mid_height) then U32.add(g_y, U32.sub(y, mid_height))
    else if U32.ltn(y, mid_height) then U32.sub(g_y, U32.sub(mid_height, y))
    else mid_height
  Pos32.new(upd_g_x, upd_g_y, lvl)

// Sprites are centered at 128x128
Mons.vox_mid: Pos32
  Pos32.new(128u, 128u, 0u) 

// The game screen is 240x160 pixels
Mons.scr_mid: Pos32
  Pos32.new(120u, 80u, 0u)

// The game screen width
Mons.scr_w: U32
  U32.mul(Pos32.get_x(Mons.scr_mid), 2u)

// The game screen height
Mons.scr_h: U32
  U32.mul(Pos32.get_y(Mons.scr_mid), 2u)

// The null pad
Mons.Pad.null: Mons.Pad
  Mons.Pad.new(Bool.false, Bool.false, Bool.false, Bool.false)

// Sets the r field of a pad
Mons.Pad.set_r(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(val, pad.u, pad.l, pad.d)

// Sets the u field of a pad
Mons.Pad.set_u(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, val, pad.l, pad.d)

// Sets the l field of a pad
Mons.Pad.set_l(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, val, pad.d)

// Sets the d field of a pad
Mons.Pad.set_d(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, pad.l, val)

// The void tile
Mons.Object.void: Mons.Object
  let void = Mons.Kind.Terrain(Mons.Kind.terrain.VOID)
  Mons.Object.new(void, Mons.Dir.down, Mons.Pad.null, 0u, 0u, [], 0u, [], {33u, []},
   0u, Mons.Effect.clear)

// Gets an object's direction
Mons.Object.get_dir(obj: Mons.Object): Mons.Dir
  open obj: obj.dir

// Sets an object's direction
Mons.Object.set_dir(obj: Mons.Object, dir: Mons.Dir): Mons.Object
  open obj: Mons.Object.new(obj.kin, dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

// Gets an object's pad
Mons.Object.get_pad(obj: Mons.Object): Mons.Pad
  open obj: obj.pad

// Sets an object's pad
Mons.Object.set_pad(obj: Mons.Object, pad: Mons.Pad): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

// Gets an object's walk animation frames
Mons.Object.get_ani(obj: Mons.Object): U32
  open obj: obj.ani

// Sets an object's walk animation frames
Mons.Object.set_ani(obj: Mons.Object, ani: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

// Gets an object's current HP
Mons.Object.get_dmg(obj: Mons.Object): U32
  open obj: obj.dmg

// Gets an object's kind 
Mons.Object.get_kin(obj: Mons.Object): Mons.Kind
  open obj: obj.kin

// Sets an object's current kin
Mons.Object.set_kin(obj: Mons.Object, kin: Mons.Kind): Mons.Object
  open obj: Mons.Object.new(kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

// Sets an object's current HP
Mons.Object.set_dmg(obj: Mons.Object, dmg: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

// Sets an object's pad.r
Mons.Object.set_pad_r(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_r(obj.pad, val))

// Sets an object's pad.u
Mons.Object.set_pad_u(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_u(obj.pad, val))

// Sets an object's pad.l
Mons.Object.set_pad_l(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_l(obj.pad, val))

// Sets an object's pad.d
Mons.Object.set_pad_d(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_d(obj.pad, val))

Mons.Object.set_bag(bag: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, obj.eff)

Mons.Object.set_mon(idx: U32, obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    idx, obj.bos, obj.cap, obj.idl, obj.eff)

Mons.Object.set_bos(bos: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, bos, obj.cap, obj.idl, obj.eff)

Mons.Object.set_cap(cap: Pair(U32, List(Mons.Object)), obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, cap, obj.idl, obj.eff)

Mons.Object.set_idl(idl: U32, obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, idl, obj.eff)

Mons.Object.set_eff(eff: Mons.Effect, obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, 
    obj.mon, obj.bos, obj.cap, obj.idl, eff)

Mons.Object.qtd_mons_defeated(obj: Mons.Object): U32
  open obj:
  Nat.to_u32(List.length<>(Pair.snd<,>(obj.cap)))

// Hits an object, damaging it
Mons.Object.hit(obj: Mons.Object, dmg: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.add(Mons.Object.get_dmg(obj), dmg))

// Heals an object
Mons.Object.heal(obj: Mons.Object, val: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.sub(Mons.Object.get_dmg(obj), val))

// Returns true if any of the object's pad is non-zero (it is walking)
Mons.Object.is_walking(obj: Mons.Object): Bool
  open obj:
  open obj.pad:
  let is_walking_x = Bool.or(obj.pad.u, obj.pad.d)
  let is_walking_y = Bool.or(obj.pad.l, obj.pad.r)
  Bool.or(is_walking_x, is_walking_y)

// Is this object free to move?
Mons.Object.is_free_to_move(obj: Mons.Object): Bool
  open obj:
  U32.eql(obj.ani, 0u)

// Related to moving an object
// ------
// Get the first pos which the hero is facing
Mons.Object.get_adjacent_pos(pos: Pos32, dir: Mons.Dir, map: Mons.Map): Pos32
  let x = Pos32.get_x(pos)
  let y = Pos32.get_y(pos)
  let z = Pos32.get_z(pos) // dim
  case dir:
  | r => Pos32.new(U32.add(x, 1u), y, z);
  | u => Pos32.new(x, U32.sub(y, 1u), z);
  | l => Pos32.new(U32.sub(x, 1u), y, z);
  | d => Pos32.new(x, U32.add(y, 1u), z);

// pos: actual position of the object
// dir: direction which will move forward
Mons.Object.can_move_forward(pos: Pos32, dir: Mons.Dir, game: Mons.Game): Bool
  open game:
  let adjacent_objs = Mons.Object.get_adjacent_obj_list(pos, dir, game)
  // If have only 1 element, is the plain terrain hehe
  if Nat.eql(List.length<>(adjacent_objs), 1) then Bool.true
  else Bool.false

// Indicates if the hero can push the object he is facing
Mons.Object.hero_can_push_obj(pos: Pos32, dir: Mons.Dir, map: Mons.Map): Bool
  let adjacent_obj = Mons.Object.get_adjacent_obj(pos, dir, map)
  open adjacent_obj:
  case adjacent_obj.kin as kind:
  | mons => Bool.false;
  | const => Bool.false;
  | terrain => Bool.false;
  | inter =>
    case kind.ele:
    | lever => Bool.true;
    | move  => Bool.true;
  ;

Mons.Object.get_adjacent_obj(pos: Pos32, dir: Mons.Dir, map: Mons.Map): Mons.Object
  let adjacent_pos = Mons.Object.get_adjacent_pos(pos, dir, map)
  Mons.Map.get_top(adjacent_pos, map)

Mons.Object.get_adjacent_obj_list(pos: Pos32, dir: Mons.Dir, game: Mons.Game): List(Mons.Object)
  open game:
  let adjacent_pos = Mons.Object.get_adjacent_pos(pos, dir, game.map)
  Mons.Game.get_tile(adjacent_pos, game)

// -------

Mons.Turn.empty: Mons.Turn
  Mons.Turn.new(Bool.false, Mons.Skill.none, Mons.Skill.none, 0u)

// 0u: inactive
Mons.Turn.is_active(turn: Mons.Turn): Bool
  open turn:
  U32.gtn(turn.play, 0u)

Mons.Turn.is_last_player_move(turn: Mons.Turn): Bool
  open turn:
  U32.eql(turn.play, 1u)

Mons.Turn.hero_turn(turn: Mons.Turn): Bool
  open turn:
  turn.exec_hero

Mons.Object.is_standing(obj: Mons.Object): Bool
  U32.eql(Mons.Object.get_ani(obj),0u)

Mons.walk_char_pack(
  t_x: U32,
  t_y: U32,
  ani: U32,
  dir: Mons.Dir,
  r_0: Image3D,
  u_0: Image3D,
  l_0: Image3D,
  d_0: Image3D,
  r_1: Image3D,
  u_1: Image3D,
  l_1: Image3D,
  d_1: Image3D,
  r_2: Image3D,
  u_2: Image3D,
  l_2: Image3D,
  d_2: Image3D
): List(Image3D)
  //0 = parado
  //1 = pe direito pra frente
  //2 = pe esquerdo pra frente
  if U32.eql(ani, 0u) then
    case dir:
    | right => [r_0];
    | up    => [u_0];
    | left  => [l_0];
    | down  => [d_0];
  else
    if U32.eql(U32.mod(U32.add(t_x,t_y),2u), 0u) then
      case dir:
      | right => [r_1];
      | up    => [u_1];
      | left  => [l_1];
      | down  => [d_1];
    else
      case dir:
      | right => [r_2];
      | up    => [u_2];
      | left  => [l_2];
      | down  => [d_2];
  
// An empty map
Mons.Map.new: Mons.Map
  Map.new<>

// Adds a tile to a position on the map
Mons.Map.set_list(pos: Pos32, objs: List(Mons.Object), map: Mons.Map): Mons.Map
  Map.set<>(U32.to_bits(pos), objs, map)

// Gets the tile stored on a position on the map
Mons.Map.get_list(pos: Pos32, map: Mons.Map): List(Mons.Object)
  case Map.get<>(U32.to_bits(pos), map) as got:
  | [];
  | got.value;

// Gets the nth object of a tile
Mons.Map.get(pos: Pos32, idx: U32, map: Mons.Map): Mons.Object
  let list = Mons.Map.get_list(pos, map)
  case List.at<>(U32.to_nat(idx), list) as got:
  | Mons.Object.void;
  | got.value;

// Sets the nth object of a tile
Mons.Map.set(pos: Pos32, idx: U32, val: Mons.Object, map: Mons.Map): Mons.Map
  let list = Mons.Map.get_list(pos, map)
  let list = List.update_at<>(U32.to_nat(idx), () val, list)
  Mons.Map.set_list(pos, list, map)

// Pushes an object to the top of a tile
Mons.Map.push(pos: Pos32, obj: Mons.Object, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.cons<>(obj, objs)
  Mons.Map.set_list(pos, objs, map)

// Pops an object from the top of a tile
Mons.Map.pop(pos: Pos32, map: Mons.Map): Pair(Mons.Map, Mons.Object)
  let objs = Mons.Map.get_list(pos, map)
  case objs:
  | Pair.new<,>(map, Mons.Object.void);
  | let map = Mons.Map.set_list(pos, objs.tail, map)
    Pair.new<,>(map, objs.head);

// Gets the the object on top of a tile
Mons.Map.get_top(pos: Pos32, map: Mons.Map): Mons.Object 
  Pair.snd<,>(Mons.Map.pop(pos,map))

// Gets the hero's object and its index from a tile
Mons.Map.get_hero(pos: Pos32, map: Mons.Map): Pair(Mons.Object, U32)
  let tile = Mons.Map.get_list(pos, map)
  let obj_is_hero = ((obj) Mons.Kind.is_hero(Mons.Object.get_kin(obj))) :: Mons.Object -> Bool 
  let fun = ((obj, idx) obj_is_hero(obj)) :: Mons.Object -> Nat -> Bool
  let both = List.ifind<>(tile, fun)
  case both: 
  | none => Pair.new<,>(Mons.Object.void, 0u);
  | some => 
    let hero = Pair.fst<,>(both.value)
    let idx = Nat.to_u32(Pair.snd<,>(both.value))
    Pair.new<,>(hero, idx);

// Deletes an object from a tile
Mons.Map.del(pos: Pos32, idx: U32, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.delete_at.u32<>(idx, objs)
  Mons.Map.set_list(pos, objs, map)

Mons.Object.push_to_bag(obj: Mons.Object, hero: Mons.Object): Mons.Object
  open obj:
  open hero:
  let qtd = List.length<>(hero.bag)
  case obj.kin as kind:
  | mon =>
    let obj = Mons.Object.set_dmg(obj, 0u)
    if Nat.ltn(qtd, 3) then
      let new_bag = List.append<>(hero.bag, obj)
      Mons.Object.set_bag(new_bag, hero)
    else
      hero;
  | const => hero;
  | terrain => hero;
  | inter => hero;

Mons.Object.add_defeated_mon(obj: Mons.Object, hero: Mons.Object): Mons.Object
  open obj:
  open hero:
   case obj.kin as kind:
  | mon =>
    let qtd_mons = Pair.fst<,>(hero.cap)
    let mons_defeated = Pair.snd<,>(hero.cap)
    let new_cap = {qtd_mons, List.append<>(mons_defeated, obj)}
    Mons.Object.set_cap(new_cap, hero)
  ;
  | const => hero;
  | terrain => hero;
  | inter => hero;

Mons.Object.capture_boss(boss: Mons.Object, hero: Mons.Object): Mons.Object
  open boss:
  open hero:
  case boss.kin as kind:
  | mon => 
    let new_boss_bag = List.append<>(hero.bos, boss)
    Mons.Object.set_bos(new_boss_bag, hero);
  | const => hero;
  | terrain => hero;
  | inter => hero;

Mons.Object.pop_from_bag(obj: Mons.Object): Mons.Object
  open obj:
  let qtd = List.length<>(obj.bag)
  if Nat.eql(qtd, 1) then
    obj
  else
    let new_bag = List.drop<>(1, obj.bag)
    Mons.Object.set_bag(new_bag, obj)

Mons.Object.delete_from_bag(idx: U32, hero_obj: Mons.Object): Mons.Object
  let idx_nat = U32.to_nat(idx)
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then hero_obj
  else
    let new_bag = List.delete_at<>(idx_nat, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj)
    Mons.Object.set_mon(0u, hero_obj)

Mons.Object.is_bag_full(obj: Mons.Object): Bool
  open obj:
  let size = List.length<>(obj.bag)
  Nat.eql(size, 3)

// Get names in a list of Mons.Objects
Mons.Object.get_names(bag: List(Mons.Object)): List(String)
  let names = List.nil<String>
  for mon in bag with names:
    open mon:
    let name = Mons.Kind.get_name(mon.kin);
    List.cons<>(name, names)

// Get images in a list of Mons.Objects
Mons.Object.get_images(bag: List(Mons.Object)): List(Image3D)
  let images = List.nil<Image3D>
  for mon in bag with images:
    open mon:
    let mon_attr = Mons.Kind.attr(mon.kin)
    open mon_attr:
    List.cons<Image3D>(mon_attr.pic, images)

Mons.Object.hero: Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.fire, 1u))

// Mons.Object.is_battleable(obj: Mons.Object): Bool
//   open obj:
//   case obj.kin as mon:
//   | mons => Bool.true;
//   | const => Bool.false;
//   | terrain => Bool.false;
//   | inter => Bool.false;

Mons.Object.update_interactive(obj: Mons.Object, fun: Mons.Kind -> Mons.Kind ): Mons.Object
  open obj:
  Mons.Object.set_kin(obj, fun(obj.kin))

// Mons.Object.can_attack(obj: Mons.Object): Bool 
//    open obj: 
//    case List.find<>(Mons.Effect.is_sleep, obj.eff) as res:
//    | none => Bool.true;
//    | some => Bool.false;

// Mons.Object.is_burning(obj: Mons.Object): Bool
//    open obj:
//    case List.find<>(Mons.Effect.is_burn, obj.eff):
//    | none => Bool.false;
//    | some => Bool.true;

// Calculate the damage received depending on the type of the Mon
Mons.Type.skill_n_type(val: U32, source_obj: Mons.Object, target_obj: Mons.Object): U32
  open source_obj:
  case source_obj.kin as s_kind:
  | mon =>
    open target_obj:
    case target_obj.kin as t_kind:
    | mon => 
      case s_kind.pri_type as s_type:
      | s_normal =>
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => val; // 1x
        | t_water  => val; // 1x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x 
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); // 0,5x
        | t_darkness => val; // 1x
      ;
      | s_earth => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => U32.mul(val, 2u); //2x
        | t_water  => val; //1x
        | t_grass  => U32.div(val, 2u); // 0,5x
        | t_electric => U32.mul(val, 2u); // 2x
        | t_psychic  => val;
        | t_ice   => val;
        | t_light => U32.mul(val, 2u); // 2x
        | t_darkness => val;
      ;
      | s_fire => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => U32.div(val, 2u); // 0,5x
        | t_water  => U32.div(val, 2u); // 0,5x
        | t_grass  => U32.mul(val, 2u); // 2x
        | t_electric => val;
        | t_psychic  => val;
        | t_ice   => U32.mul(val, 2u); // 2x
        | t_light => U32.mul(val, 2u); // 2x
        | t_darkness => val;
      ;
      | s_water => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_grass => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_electric => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => U32.div(val, 2u); //0,5x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_psychic=> 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => U32.div(val, 2u); //0,5x
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => val; // 1x
      ;
      | s_ice => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.mul(val, 2u); // 2x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => U32.div(val, 2u); //0,5x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_light => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => U32.mul(val, 2u); // 2x
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => U32.mul(val, 2u); // 2x
      ;
      | s_darkness => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val;
        | t_electric => val;
        | t_psychic  => U32.mul(val, 2u); // 2x
        | t_ice   => val;
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => U32.div(val, 2u); //0,5x
      ;
    ;
    | construction => 0u;
    | terrain => 0u;
    | inter => 0u;
  ;
  | construction => 0u;
  | terrain => 0u;
  | inter => 0u;

// Creates a new object with a given kind
Mons.Object.new_of_kind(kin: Mons.Kind): Mons.Object
  // kin, dir, pad, ani, dmg, bag, mon, bos, cap
  Mons.Object.new(kin, Mons.Dir.down, Mons.Pad.null, 1u, 0u, [], 0u, [], {33u, []}, 
    0u, Mons.Effect.clear)

Mons.Map.code_to_tile.aux(code: String, cond: List(Pair(String, List(Mons.Object)))) : List(Mons.Object)
  case cond:
  | nil  => [];
  | cons =>
    get str objs = cond.head
    if String.eql(code, str) then 
      objs 
    else 
     Mons.Map.code_to_tile.aux(code, cond.tail);

// Converts a tile code (ex: ".g") into a list of obs
Mons.Map.code_to_tile(code: String, dim: U32): List(Mons.Object)
  let grass = Mons.Object.new_of_kind(Mons.Kind.Terrain(Mons.Kind.terrain.GRASS))
  let rock_path = Mons.Object.new_of_kind(Mons.Kind.Const(Mons.Kind.const.ROCK_PATH_M, Bool.false, Bool.false))

  if U32.eql(dim, 0u) then // lvl 0 - city destroied
    let grass = Mons.Object.new_of_kind(Mons.Kind.Terrain(Mons.Kind.terrain.GRASS))
    Mons.Map.code_to_tile.aux(code,[
      // Mons
      { "m0", Mons.Kind.new_mons(Mons.Kind.mons.AZULA, Mons.Type.normal, 2u)},
      { "m1", Mons.Kind.new_mons(Mons.Kind.mons.POISOLICK, Mons.Type.normal, 1u)},
      { "m2", Mons.Kind.new_mons(Mons.Kind.mons.EMERELDER, Mons.Type.normal, 2u)},
      { "m3", Mons.Kind.new_mons(Mons.Kind.mons.ZOIO, Mons.Type.normal, 2u)},
      { "m4", Mons.Kind.new_mons(Mons.Kind.mons.MIMIC, Mons.Type.normal, 2u)},
      { "m5", Mons.Kind.new_mons(Mons.Kind.mons.CYCLOPE, Mons.Type.normal, 2u)},

      // Construction
      { "ch", [ Mons.Kind.new_portal(Mons.Kind.const.CRYSTAL), grass ]},
      { "ft", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 0), Bool.true) ]},
      // Terrain
      { ".g", [ grass ]},
      { ".d", [ Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS_PLANT) ]},
      { "xx", [ Mons.Kind.new_const(Mons.Kind.const.PATH_BLOCKER, Bool.false)] }
      { "bg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.BUSH), grass ]},
      { "pg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.PLANT_0), grass ]},
      { "S0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]}
    ]) 
  else // lvl 1 - Mons type "normal" 
  Mons.Map.code_to_tile.aux(code,[
    { ".g", [ grass ]},
    { ".d", [ Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS_PLANT) ]},
    { "bg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.BUSH), grass ]},
    { "pg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.PLANT_0), grass ]},
    { "t0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_00) ]},
    { "t1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_01) ]},
    { "t2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_02) ]},
    { "w0", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.up)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "wm", [ Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.middle)) ]},
    { "w1", [ 
      Mons.Object.new_of_kind( Mons.Kind.Terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.left))),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "w2", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.right)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0)
     ]},
    { "w3", [
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.down)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "T0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 0)), grass]},
    { "T1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 1)), grass ]},
    { "/0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 0), Bool.false), grass ]},
    { "/1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 1), Bool.false) ]},
    { "/2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 2), Bool.false), grass ]},
    { "B0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 0)), grass ]},
    { "B1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 1)), grass ]},
    { "P0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(2, 0)), grass ]},
    { "P1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(2, 1)), grass ]},
    { "P2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(3, 0)), grass ]},
    { "P3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(3, 1)), grass ]},
    { "P4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(4, 0)), grass ]},
    { "P5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(4, 1)), grass ]},
    { "P6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(5, 0)), grass ]},
    { "P7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(5, 1)), grass ]},
    { "P8", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(6, 0)), grass ]},
    { "P9", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(7, 0)), grass ]},    
    { ".s", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_C, Bool.false), grass ]},
    { ".r", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_M, Bool.false) ]},

    // { "30", Mons.Kind.new_mons(Mons.Kind.mons.BATH, Mons.Type.grass, 2u) },
    { "31", Mons.Kind.new_mons(Mons.Kind.mons.BEHOLDER, Mons.Type.normal, 2u) },
    // { "32", Mons.Kind.new_mons(Mons.Kind.mons.CRONI, Mons.Type.darkness, 2u) },
    // { "33", Mons.Kind.new_mons(Mons.Kind.mons.ELLIOT, Mons.Type.ice, 2u) },
    // { "34", Mons.Kind.new_mons(Mons.Kind.mons.ESPECTRONUS, Mons.Type.darkness, 2u) },
    // { "35", Mons.Kind.new_mons(Mons.Kind.mons.GAKI, Mons.Type.darkness, 2u) },
    // { "36", Mons.Kind.new_mons(Mons.Kind.mons.GORR, Mons.Type.grass, 2u) },
    // { "37", Mons.Kind.new_mons(Mons.Kind.mons.LAMURIA, Mons.Type.earth, 2u) },
    // { "38", Mons.Kind.new_mons(Mons.Kind.mons.RAFIRE, Mons.Type.fire, 2u) },
    // { "39", Mons.Kind.new_mons(Mons.Kind.mons.VARGOULI, Mons.Type.darkness, 2u) },
    // { "40", Mons.Kind.new_mons(Mons.Kind.mons.TUPITREE, Mons.Type.grass, 2u) },
    // { "41", Mons.Kind.new_mons(Mons.Kind.mons.LELA, Mons.Type.darkness, 2u) },
    // { "42", Mons.Kind.new_mons(Mons.Kind.mons.MOSHY, Mons.Type.grass, 2u) },
    // // { "43", Mons.Kind.water_with_kin(Mons.Kind.mons.ESPECTRONUS, Mons.Type.water, 2u) },
    // // { "44", Mons.Kind.water_with_kin(Mons.Kind.mons.LAMURIA, Mons.Type.water, 2u)},
    // // { "45", Mons.Kind.new_mons(Mons.Kind.mons.POISOLICK, Mons.Type.normal, 2u) },
    // { "46", Mons.Kind.new_boss(Mons.Kind.mons.BUFF, Mons.Type.grass, 0u) },
    // { "47", Mons.Kind.new_boss(Mons.Kind.mons.LAUGH, Mons.Type.psychic, 0u) },
    // { "48", Mons.Kind.new_mons(Mons.Kind.mons.COBE_ORN, Mons.Type.darkness, 2u) },
    // { "49", Mons.Kind.new_mons(Mons.Kind.mons.SANDY, Mons.Type.darkness, 2u) },
    // { "50", Mons.Kind.new_mons(Mons.Kind.mons.SLIME, Mons.Type.grass, 2u) },
    // { "51", Mons.Kind.new_mons(Mons.Kind.mons.MIMIC, Mons.Type.psychic, 2u) },
    // { "52", Mons.Kind.new_mons(Mons.Kind.mons.SPARKY, Mons.Type.fire, 2u) },
    // { "53", Mons.Kind.new_mons(Mons.Kind.mons.DOOMFIRE, Mons.Type.fire, 2u) },
    // { "54", Mons.Kind.new_mons(Mons.Kind.mons.BEANSTRONG, Mons.Type.earth, 2u) },
    // { "55", Mons.Kind.new_mons(Mons.Kind.mons.NAMELESS, Mons.Type.psychic, 2u) },
    // { "56", Mons.Kind.new_boss(Mons.Kind.mons.OCTOKING, Mons.Type.water, 0u) },
    // { "57", Mons.Kind.new_mons(Mons.Kind.mons.INPUBU, Mons.Type.light, 2u) },
    { "58", Mons.Kind.new_mons(Mons.Kind.mons.EMERELDER, Mons.Type.normal, 2u) },
    { "59", Mons.Kind.new_mons(Mons.Kind.mons.ZOIO, Mons.Type.normal, 2u) },
    // { "60", Mons.Kind.new_mons(Mons.Kind.mons.IGNITE, Mons.Type.fire, 2u) },
    // { "61", Mons.Kind.new_mons(Mons.Kind.mons.FROST, Mons.Type.ice, 2u) },
    // { "62", Mons.Kind.new_mons(Mons.Kind.mons.FRAB, Mons.Type.fire, 2u) },
    // { "63", Mons.Kind.new_mons(Mons.Kind.mons.ELECTROWL, Mons.Type.electric, 2u) },
    // { "64", Mons.Kind.new_mons(Mons.Kind.mons.NOCTUBRIGHT, Mons.Type.water, 2u) },

    { "K0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 0), Bool.false), rock_path ]},
    { "K1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 1), Bool.false) ]},
    { "K2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 2), Bool.false) ]},
    { "K3", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 3), Bool.false) ]},
    { "K4", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 4), Bool.false), rock_path ]},
    { "C0", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 0), Bool.false) rock_path ]},
    { "C1", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 1), Bool.false) rock_path ]},
    { "C2", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 2), Bool.false), rock_path ]},
    { "C3", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 3), Bool.false), rock_path ]},
    { "C4", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 4), Bool.false), rock_path ]},
    { "W0", [ Mons.Kind.new_const(Mons.Kind.const.WELL(0, 0), Bool.false), grass ]},
    { "W1", [ Mons.Kind.new_const(Mons.Kind.const.WELL(0, 1), Bool.false), grass ]},
    { "A0", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 0), Bool.false), rock_path ]},
    { "A1", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 1), Bool.false), rock_path ]},
    { "A2", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 2), Bool.false), rock_path ]},
    { "p1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(0, 0)), grass ]},
    { "p2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(0, 1)), grass ]},
    { "p3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(1, 0)), grass ]},
    { "p4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(2, 0)), grass ]},
    { "p5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(2, 1)), grass ]},
    { "p6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(3, 0)), grass ]},
    { "p7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(4, 0)), grass ]},
    { ".p", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(5, 0)), grass ]},
    { "p8", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(6, 0)), grass ]},
    { "pp", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(7, 0)), grass ]},
    { "po", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(8, 0)), grass ]},
    { "p9", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(9, 0)), grass ]},    
    // { "S0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "S1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_1) ]},
    { "ch", [ Mons.Kind.new_portal(Mons.Kind.const.CHEST) ]},
    { "s0", [ Mons.Kind.new_const(Mons.Kind.const.SIGN_0, Bool.false), grass ]},
    { "s1", [ Mons.Kind.new_const(Mons.Kind.const.SIGN_1, Bool.false), grass ]},
    { "om", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.middle))]},
    { "on", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER1_M) ]},
    { "o0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right)), grass ]},
    { "o1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.up)), grass ]},
    { "o2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left)), grass ]},
    { "o3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.down)), grass ]},
    { "o4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_up)), grass]},
    { "o5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_up)), grass ]},
    { "o6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_down)), grass ]},
    { "o7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_down)), grass ]},
    { "xx", [ Mons.Kind.new_const(Mons.Kind.const.PATH_BLOCKER, Bool.false) ]},
    { "f0", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right), Bool.false), grass ]},
    { "f1", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.middle), Bool.false), grass ]},
    { "f2", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left), Bool.false), grass ]},
    { "f3", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_up), Bool.false), grass ]},
    { "f4", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_up), Bool.false), grass ]},
    { "f5", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_down), Bool.false), grass ]},
    { "f6", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_down), Bool.false), grass ]},
    { "fa", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right), Bool.false), grass ]},
    { "fb", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.middle), Bool.false), grass ]},
    { "fc", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left), Bool.false), grass ]},
    { "fd", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right_up), Bool.false), grass ]},
    { "fe", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left_up), Bool.false), grass ]},
    { "ff", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left_down), Bool.false), grass ]},
    { "fg", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right_down), Bool.false), grass ]},
    { "mg", Mons.Kind.new_mons(Mons.Kind.mons.MAGE, Mons.Type.normal, 0u)},

    // Interactive objects
    { "al", [ Mons.Kind.new_interactive_tool(
                Mons.Kind.inter.LEVER(0u),
                Bool.false, 
                Mons.Kind.inter_lever_eff
              ), grass ]},
    { "mv", [ Mons.Kind.new_interactive_tool(
                Mons.Kind.inter.MOVE,
                Bool.true, 
                Mons.Kind.inter_lever_eff
              ), grass ]} 
    
  ])

// Converts a string map source to an actual map
Mons.Map.build(code: List(List(String))): Mons.Map
  List.ifor.u32<>(code)<>
  | Mons.Map.new;
  | (z, plane, map) 
    let size = List.length.u32<>(plane) // NOTE: assumes width == height
    List.ifor.u32<>(plane)<>
    | map;
    | (j, row, map)
      for i : U32 = 0u .. size with map:
        let t_x = U32.add(U32.sub(2048u, U32.div(size, 2u)), i)
        let t_y = U32.add(U32.sub(2048u, U32.div(size, 2u)), j)
        let t_z = z
        let pos = Pos32.new(t_x, t_y, t_z)
        let ini = U32.to_nat(U32.mul(i,2u)) // slice start index
        let end = U32.to_nat(U32.add(U32.mul(i,2u),2u)) // slice end index
        let sli = String.slice(ini, end, row) // slice with tile code
        Mons.Map.set_list(pos, Mons.Map.code_to_tile(sli, z), map);;   

// Get the game user
Mons.Game.get_usr(game: Mons.Game): Word(160)
  open game: game.usr

// Set the game user
Mons.Game.set_usr(usr: Word(160), game: Mons.Game): Mons.Game
  open game: Mons.Game.new(usr, game.pos, game.map, game.stt, game.tik)

Mons.Game.set_stt(stt: Mons.Screen, game: Mons.Game): Mons.Game
  open game: Mons.Game.new(game.usr, game.pos, game.map, stt, game.tik)

// Gets an user's position
Mons.Game.get_user_pos(user: Word(160), game: Mons.Game): Maybe(Pos32)
  open game:
  Map.get<>(Word.to_bits<160>(user), game.pos)

// Sets an user's position
Mons.Game.set_user_pos(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, Map.set<>(Word.to_bits<160>(user), pos, game.pos), 
    game.map, game.stt, game.tik)

// Gets the hero's position
Mons.Game.get_hero_pos(game: Mons.Game): Maybe(Pos32)
  open game: Mons.Game.get_user_pos(game.usr, game)

// Sets the game map
Mons.Game.set_map(map: Mons.Map, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, game.pos, map, game.stt, game.tik)

Mons.Game.set_tik(tik: U32, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, game.pos, game.map, game.stt, tik)

Mons.Game.update_obj(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Updates the object at given position on the game map
Mons.Game.update(fn: Mons.Object -> Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let obj = fn(Mons.Map.get(pos, idx, game.map))
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

Mons.Game.get_tile(pos: Pos32, game: Mons.Game): List(Mons.Object)
  open game:
  Mons.Map.get_list(pos, game.map)

Mons.Game.move_obj(from: Pos32, idx: U32, to: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game 
  let game = Mons.Game.map_del(from, idx, game)
  let game = Mons.Game.map_push(to, obj, game)
  game

Mons.Game.delete_adve_obj(
  adve_obj: Mons.Object, 
  hero_obj: Mons.Object, 
  pos: Pos32,
  hero_idx: U32,
  adve_idx: U32,
  game: Mons.Game): Mons.Game
  let game = Mons.Game.map_del(pos, adve_idx, game)
  let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
  Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game)

// At the beginning of the game 3 initial Mons are added to the bag.
// This function makes only the selected one remain
Mons.Object.delete_init_mons(hero_obj: Mons.Object): Mons.Object
  open hero_obj:
  let get_mon = List.at<>(U32.to_nat(hero_obj.mon), hero_obj.bag)
  let cur_mon =
    case get_mon:
    | none => Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.earth, 2u));
    | some => get_mon.value;
  let hero_obj = Mons.Object.set_bag([], hero_obj)
  let hero_obj = Mons.Object.push_to_bag(cur_mon, hero_obj)
  let hero_obj = Mons.Object.set_mon(0u, hero_obj)
  hero_obj

Mons.Game.move_hero_down(
  usr: Word(160), 
  hero_obj: Mons.Object, 
  pos: Pos32, 
  hero_idx: U32, 
  game: Mons.Game): Mons.Game
  let y = Pos32.get_y(pos)
  let x = Pos32.get_x(pos)
  let z = Pos32.get_z(pos)
  let new_pos = Pos32.new(x,U32.add(y, 1u),z)
  let game = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game) 
  Mons.Game.set_user_pos(usr, new_pos, game)

// Position for lvl 1. Whill he always start in the same position?
Mons.Game.hero_inital_position(
  usr: Word(160), 
  hero_obj: Mons.Object, 
  pos: Pos32, 
  hero_idx: U32, 
  game: Mons.Game): Mons.Game
  let y = Pos32.get_y(pos)
  let x = Pos32.get_x(pos)
  let z = Pos32.get_z(pos)
  let new_pos = Pos32.new(x,U32.add(y, 38u),z)
  let game = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game) 
  Mons.Game.set_user_pos(usr, new_pos, game)

// hero and adve have some hp
Mons.Object.is_battling(adve: Mons.Object, hero_or_mon: Mons.Object): Bool
  let is_adve_alive = Bool.not(Mons.Object.is_obj_defeated(adve))
  let is_hero_alive = Bool.not(Mons.Object.is_obj_defeated(hero_or_mon))
  Bool.and(is_adve_alive, is_hero_alive)
  

Mons.Object.ended_battle(adve: Mons.Object, hero: Mons.Object): Bool
  open adve:
  open hero:
  case adve.kin:
  | mon => 
    let adve_kin = Mons.Kind.attr(adve.kin)
    let hero_kin = Mons.Kind.attr(hero.kin)
    open adve_kin:
    open hero_kin:
    let adve_status = Mons.Object.is_obj_defeated(adve)
    let hero_status = Mons.Object.is_obj_defeated(hero)
    Bool.or(adve_status, hero_status)  
  ;
  | const    => Bool.false;
  | terrain  => Bool.false;
  | inter => Bool.false;
  
Mons.Object.is_obj_defeated(obj: Mons.Object): Bool
  U32.eql(Mons.Object.remaining_hp(obj), 0u)

Mons.Object.remaining_hp(obj: Mons.Object): U32
  open obj:
  case obj.kin as kind:
  | mons => 
    open Mons.Kind.attr(obj.kin) as kind:
    U32.sub(kind.mhp, obj.dmg);
  | const    => obj.dmg;
  | terrain  => obj.dmg;
  | inter => obj.dmg;

// If trying to get a Mon from a Mon, it will return and empty Mon (mhp 0, dmg0, no name)
Mons.Object.get_current_mon(obj: Mons.Object): Mons.Object
  open obj:
  let idx = U32.to_nat(obj.mon)
  case List.at<>(idx, obj.bag) as mon:
  | obj;
  | mon.value;

// When hero wins a battle, adds the adversary to hero's game
// and updates de game status
Mons.Game.hero_won_batle(
  adve_obj: Mons.Object,
  hero_obj: Mons.Object,
  hero_pos: Pos32,
  hero_idx: U32,
  game: Mons.Game
): Mons.Game
  open game:
  let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
  let game = Mons.Game.update((hero_obj) hero_obj, hero_pos, hero_idx, game)
  game

// Mons.Attr with "battles" equals to Bool.true
Mons.Attr.new_battleable(
  pic: Image3D,
  spr: List(Image3D),
  name: String,
  battle_spr: Bool -> Image3D,
  skills: List(Mons.Skill)
  ): Mons.Attr
  Mons.Attr.new(
    Bool.false, 40u, 0u, name,
    Mons.Kind.set_static_sprites(spr),
    spr,
    pic,
    battle_spr, skills)

// Mons.Attr with "block" equals to Bool.true
Mons.Attr.new_blockable(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.true, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    spr,
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

// Mons.Attr with "block" and "batlles" equals to Bool.false
Mons.Attr.new_neutral(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.false, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    spr,
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

Mons.Attr.new_hero: Mons.Attr
  Mons.Attr.new(Bool.false, 40u, 0u, "HERO",
    (x,y,obj_ani,obj_dir) 
      Mons.walk_char_pack(
        x, y, obj_ani, obj_dir,
        Mons.Assets.boy_r_0, Mons.Assets.boy_u_0, 
        Mons.Assets.boy_l_0, Mons.Assets.boy_d_0,

        Mons.Assets.boy_r_1, Mons.Assets.boy_u_1,
        Mons.Assets.boy_l_1, Mons.Assets.boy_d_1,

        Mons.Assets.boy_r_2, Mons.Assets.boy_u_2,
        Mons.Assets.boy_l_2, Mons.Assets.boy_d_2),
        [ Mons.Assets.boy_d_0],
        Mons.Assets.boy_d_0,
      (is_up) Bool.if<>(is_up,Mons.Assets.battle_hero_u,Mons.Assets.battle_hero_u),
      [Mons.Skill.hero_kill, Mons.Skill.none, Mons.Skill.none, Mons.Skill.none] 
  )

Mons.Attr.new_mage: Mons.Attr
  Mons.Attr.new(
    Bool.false, 40u, 0u, "MAGE",
    Mons.Kind.set_static_sprites([Mons.Assets.mons_croni_d_0]),
    [Mons.Assets.mons_croni_d_0],
    Mons.Assets.mons_croni_d_0,
    (is_up: Bool) Mons.Assets.battle_croni_d,
    Mons.Skill.dummy_skills)

Mons.Dir.move(dir: Mons.Dir, pos: Pos32): Pos32
  case dir:
  | Pos32.add(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.sub(pos, Pos32.new(0u, 1u, 0u));
  | Pos32.sub(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.add(pos, Pos32.new(0u, 1u, 0u));

// TODO: change Mons.Game.cmd to receive 'pos' instead, and use this one for usr
// Mons.Game.cmd_usr(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game

// Update a Mons.Game by pushing a new obj to a pos
Mons.Game.map_push(pos: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.push(pos, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by setting a new obj to a pos
Mons.Game.map_set(pos: Pos32, idx: U32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by deleting an obj from a tile
Mons.Game.map_del(pos: Pos32, idx: U32, game: Mons.Game): Mons.Game 
  open game: 
  let map = Mons.Map.del(pos, idx, game.map)
  Mons.Game.set_map(map, game)



// Computes a command from an user
Mons.Game.cmd(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game
  let pos = Mons.Game.get_user_pos(usr, game)
  def set_stt_game = 
    ((game) Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game)) :: Mons.Game -> Mons.Game
  case pos:
  // New player
  | let pos = Pos32.new(2048u, 2048u, 0u)
    let obj = Mons.Object.hero
    let game = Mons.Game.map_push(pos, obj, game)
    let game = Mons.Game.set_user_pos(usr, pos, game)
    game;
  // Existing player
  | open game:
    let pos = pos.value
    let hero_pair = Mons.Map.get_hero(pos, game.map)
    let hero_obj  = Pair.fst<,>(hero_pair)
    let hero_idx  = Pair.snd<,>(hero_pair)
    let adve_idx  = 1u
    let adve_obj = Mons.Map.get(pos, adve_idx, game.map)
    let is_battling = Mons.Object.is_battling(adve_obj, hero_obj)
    let end_battle = Mons.Object.ended_battle(adve_obj, hero_obj)
    let curr_mon = Mons.Object.get_current_mon(hero_obj)
    open curr_mon: 
    let skills = Mons.Kind.get_skills(curr_mon.kin)
    // let game = Mons.test.add_bag(hero_obj, pos, 0u, game) // TEST - bag
    // let game = Mons.test.add_boss(hero_obj, pos, 0u, game) // TEST - boss

    open hero_obj:
    open adve_obj:
    // TODO let usr = Mons.Game.get_from_map(pos, game) // gets the object that used the command
    // TODO let atks = Mons.Game.get_attack_list(usr.kin)... // gets the attack list of that usr
    case game.stt as stt:
    | introduction =>
    // let can_walk = U32.eql(stt.step, 0u)
    // if Bool.and(can_walk, Mons.is_walk_cmd(cmd)) then
    //   Mons.Game.walk(cmd, pos, hero_idx, game)
    // else if U16.eql(cmd, 'c') then
    //   if U32.eql(stt.step, 0u) then // Go to Mon selection
    //     let game = Mons.test.add_bag(hero_obj, pos, 0u, game)
    //     Mons.Game.set_stt(Mons.Screen.intro_select(0u), game)
    //   if U32.eql(stt.step, 1u) then  // Initiate the game. The mage is removed from the scene.
    //     let game = Mons.Game.map_del(pos, adve_idx, game)
    //     let hero_obj = Mons.Object.delete_init_mons(hero_obj)
    //     let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    //     Mons.Game.set_stt(Mons.Screen.game('.'), game)
    //   else game
    // else game
    Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
    ;

    | Mons.Screen.intro_select => 
      if U16.eql(cmd, 'c') then Mons.Game.set_stt(Mons.Screen.introduction(1u), game)
      else // update current Mon using 'a' or 'd'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.intro_select(cmd),
          pos, hero_obj, hero_idx, game);

    | game =>
    if U16.eql(cmd, 'U') then
      Mons.Game.exec_turn(hero_obj, adve_obj, pos, hero_idx, adve_idx, 0, stt.turn, game)
    else if U16.eql(cmd, 'I') then
      Mons.Game.exec_turn(hero_obj, adve_obj, pos, hero_idx, adve_idx, 1, stt.turn, game)
    else if U16.eql(cmd, 'J') then
      Mons.Game.exec_turn(hero_obj, adve_obj, pos, hero_idx, adve_idx, 2, stt.turn, game)
    else if U16.eql(cmd, 'K') then
      Mons.Game.exec_turn(hero_obj, adve_obj, pos, hero_idx, adve_idx, 3, stt.turn, game)
    else if Mons.is_walk_cmd(cmd) then
      Mons.Game.walk(cmd, pos, hero_idx, game)

    else if U16.eql(cmd, 'e') then // Open hero's bag
      if Bool.or(is_battling, end_battle) then game
      else 
        Mons.Game.set_stt(Mons.Screen.inventory(0u), game)

    else if U16.eql(cmd, 'c') then
      case adve_obj.kin as kind:
      | mon => 
        if Mons.Object.is_obj_defeated(adve_obj) then // Battle ended
          let game = Mons.Skill.clear_after_battle(hero_idx, adve_idx, pos, game)
          let hero_obj = Mons.Object.add_defeated_mon(adve_obj, hero_obj)
          if kind.boss then
            let hero_obj = Mons.Object.capture_boss(adve_obj, hero_obj)
            Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
          else
            if Mons.Object.is_full_bag(hero_obj) then
              let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
              Mons.Game.set_stt(Mons.Screen.capture_mon(0u, Bool.true), game)
            else
              let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
              Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
        else if Mons.Object.is_obj_defeated(curr_mon) then // Battle ended
          let game = Mons.Skill.clear_after_battle(hero_idx, adve_idx, pos, game)
          if Mons.Kind.is_hero(curr_mon.kin) then
            let hero_obj = Mons.Object.set_dmg(hero_obj, 0u)
            let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
            let game = Mons.Game.move_hero_down(usr, hero_obj, pos, hero_idx, game)
            Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
          else
            let adve_obj = Mons.Object.set_dmg(adve_obj, 0u) // adve heals all hp
            let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
            let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
            let game = Mons.Game.map_set(pos, adve_idx, adve_obj, game)
            let game = Mons.Game.move_hero_down(usr, hero_obj, pos, hero_idx, game)
            Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
        else // Turn ended

        open stt.turn as turn:
        if Mons.Turn.is_active(stt.turn) then
          if Mons.Turn.is_last_player_move(stt.turn) then
            let game = Mons.Skill.apply_end_turn_eff(hero_idx, adve_idx, pos, game)
            set_stt_game(game)
          else 
          let turn = Mons.Turn.new(
            Bool.not(turn.exec_hero),
            turn.hero_skill, turn.adve_skill, U32.sub(turn.play, 1u))
          Mons.Game.set_stt(Mons.Screen.game('.', turn), game)
        else Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)

      ;

      | construction =>
        let qtd_boss = Nat.to_u32(List.length<>(hero_obj.bos))
        let lvl_mons = Bool.or(
          Bool.not(U32.eql(U32.div(Mons.Game.dim(game), 2u), 0u)), 
          U32.eql(Mons.Game.dim(game), 0u)) // TODO: Update to 1u when lvl 0 is ready
        let defeated_boss = U32.eql(U32.add(hero_idx, 1u), qtd_boss)
        let can_use_portal = Bool.or(defeated_boss, lvl_mons)
        if can_use_portal then
          let new_pos = Pos32.add(pos, Pos32.new(0u,0u,1u)) 
          let game    = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game)  
          Mons.Game.set_user_pos(usr, new_pos, game)
        else game
      ;

      | terrain => // Hero can only move objects if he is in a terrain
        if Mons.Object.hero_can_push_obj(pos, hero_obj.dir, game.map) then
          let adjacent_obj = Mons.Object.get_adjacent_obj(pos, hero_obj.dir, game.map)
          open adjacent_obj:
          Mons.Kind.exec_eff(adjacent_obj.kin, game)
        else Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game); //set_stt_game(game);

      | inter => 
        let inter_obj = Mons.Object.update_interactive(adve_obj, Mons.Kind.swap_interactive)
        let game = Mons.Game.map_set(pos, adve_idx, inter_obj, game)
        open inter_obj:
        Mons.Kind.exec_eff(inter_obj.kin, game)
      ;

    else if U16.eql(cmd, 'z') then // Free Mon
      case adve_obj.kin as kind:
      | mon =>
        if Mons.Object.is_obj_defeated(adve_obj) then
          let hero_obj = Mons.Object.add_defeated_mon(adve_obj, hero_obj)
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
        else game;
      | const => Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game); //set_stt_game(game);
      | terrain => Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game); //set_stt_game(game);
      | inter => Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game); //set_stt_game(game);

    else game ;

    | inventory => 
      if U16.eql(cmd, 'e') then
        Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
      
      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.inventory(cmd),
          pos, hero_obj, hero_idx, game);

    | capture => // accessed by pressing "c" after battle
      if U16.eql(cmd, 'c') then
        let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
        let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
        let hero_obj = Mons.Object.set_mon(2u, hero_obj) // TODO: why 2u? review
        let game = Mons.Game.map_del(pos, adve_idx, game)
        let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
        Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)

      else if U16.eql(cmd, 'z') then // Free Mon
        if Mons.Object.is_obj_defeated(adve_obj) then
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.', Mons.Turn.empty), game) //set_stt_game(game)
        else game

      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.capture_mon(cmd, Bool.true),
          pos, hero_obj, hero_idx, game)
    ;
  ;

Mons.Game.exec_turn(
  hero_obj: Mons.Object, 
  adve_obj: Mons.Object,
  pos: Pos32,
  hero_idx: U32,
  adve_idx: U32,
  code_skill: Nat,
  turn: Mons.Turn,
  game: Mons.Game) : Mons.Game
  open game:
  
  let hero_mon_obj = Mons.Object.get_current_mon(hero_obj)
  open hero_mon_obj:
  open adve_obj:

  let hero_skill = Mons.Game.get_skills_at(code_skill, hero_mon_obj)
  let adve_skill_code = Mons.Game.adve_turn(hero_obj, adve_obj, game)
  let adve_skill = Mons.Game.get_skills_at(adve_skill_code, adve_obj)

  if Bool.not(Mons.Turn.is_active(turn)) then
    let game = Mons.Skill.apply_inital_eff(hero_idx, adve_idx, pos, game)
    if Mons.Game.hero_start_attacking(hero_mon_obj.kin, adve_obj.kin) 
    then
      let game = Mons.Skill.cast(pos, hero_idx, adve_idx, hero_skill, game) // hero cast
      let game = Mons.Skill.cast(pos, adve_idx, hero_idx, adve_skill, game)
      let turn = Mons.Turn.new(Bool.true, hero_skill, adve_skill, 2u)  
      Mons.Game.set_stt(Mons.Screen.game('.', turn), game)
    else 
      let game = Mons.Skill.cast(pos, adve_idx, hero_idx, adve_skill, game)
      let game = Mons.Skill.cast(pos, hero_idx, adve_idx, hero_skill, game) // hero cast
      
      let turn = Mons.Turn.new(Bool.false, hero_skill, adve_skill, 2u)
      Mons.Game.set_stt(Mons.Screen.game('.', turn), game)
  else game

Mons.Game.hero_start_attacking(hero_kin: Mons.Kind, adve_kin: Mons.Kind) : Bool
  let hero_agi = Mons.Kind.get_agi(hero_kin)
  let adve_agi = Mons.Kind.get_agi(adve_kin)
  if Bool.or(U32.ltn(hero_agi, adve_agi), U32.eql(hero_agi, adve_agi)) 
  then Bool.true
  else Bool.false

// 0-U: hit, 1-I: hit, 2-J: heal, 3-K: hit
// Reads the game and returns a code for the skills that the adve will use
Mons.Game.adve_turn(hero_obj: Mons.Object, adve_obj: Mons.Object, game: Mons.Game): Nat
  open game:
  open hero_obj:
  open adve_obj:
  let adve_hp = Mons.Object.remaining_hp(adve_obj)
  let hero_hp = Mons.Object.remaining_hp(hero_obj)
  let qtd_mon_bag = Nat.to_u32(List.length<>(hero_obj.bag))
  let hero_pos = Mons.Game.get_hero_pos(game)
  let pos_x = 
    case hero_pos:
    | 80u;
    | Pos32.get_x(hero_pos.value);

  // hp difference more than 10
  if U32.gtn(U32.sub(hero_hp, adve_hp), 15u) then 2 // heal
  else if Bool.and(U32.gtn(hero_hp, 30u), U32.ltn(hero_hp, 25u)) then 2 // heal

  else if U32.gte(U32.sub(adve_hp, hero_hp), 8u) then 1 // none
  else if Bool.and(U32.gtn(qtd_mon_bag, 1u), U32.gtn(hero_hp, 30u)) then 1 // none
  else if U32.eql(hero_hp, adve_hp) then 3 // none
  else if Bool.and(Bool.not(U32.eql(U32.mod(pos_x, 2u), 0u)), U32.ltn(hero_hp, 15u)) then 3 // n

  else if U32.gtn(U32.sub(adve_hp, hero_hp), 15u) then 0 // heal
  else if Bool.and(U32.gtn(adve_hp, hero_hp), U32.gtn(hero_hp, 30u)) then 0 //hit
  else if U32.gtn(hero_hp, 20u) then 1 // hit
  
  else if Bool.and(U32.eql(U32.mod(pos_x, 2u), 0u), U32.ltn(hero_hp, 15u)) then 1 // hit
  else if U32.ltn(hero_hp, 5u) then 0

  else 0

Mons.Game.get_skills_at(idx: Nat, obj: Mons.Object): Mons.Skill
  open obj:
  let skills = Mons.Kind.get_skills(obj.kin)
  case List.at<>(idx, skills) as skill:
  | none => Mons.Skill.none;
  | some => skill.value;

// Update the current Mon by changing it with the keys 'w' (up) and 's' (down)
Mons.Object.change_curr_mon(
  cmd: Char,
  stt: U32 -> Mons.Screen,
  pos: Pos32,
  hero_obj: Mons.Object,
  hero_idx: U32,
  game: Mons.Game): Mons.Game
  // open game:
  open hero_obj:
  if Bool.or(U16.eql(cmd, 'a'), U16.eql(cmd, 'w')) then
    let hero_obj = Mons.Object.set_mon(U32.sub(hero_obj.mon, 1u), hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(1u), game)
  else if Bool.or(U16.eql(cmd, 'd'), U16.eql(cmd, 's')) then
    let hero_obj =
      let qtd_mon = Nat.to_u32(List.length<>(hero_obj.bag))
      if U32.ltn(hero_obj.mon, U32.sub(qtd_mon, 1u)) then
        Mons.Object.set_mon(U32.add(hero_obj.mon, 1u), hero_obj)
      else Mons.Object.set_mon(hero_obj.mon, hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(2u), game)
  else game

Mons.Object.is_full_bag(obj: Mons.Object): Bool
  open obj:
  let len = List.length<>(obj.bag)
  Nat.eql(len, 3)

// Mons.test.add_bag(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
//   open hero_obj:
//   let hero_obj = Mons.Object.set_bag([], hero_obj)
//   let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.CRONI, Bool.false, Mons.Type.earth, 2u))
//   let mon1_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.LAMURIA, Bool.false, Mons.Type.fire, 2u))
//   let mon2_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.ELLIOT, Bool.false, Mons.Type.water, 2u))
//   let hero_obj = Mons.Object.push_to_bag(mon0_bag, hero_obj)
//   let hero_obj = Mons.Object.push_to_bag(mon1_bag, hero_obj)
//   let hero_obj = Mons.Object.push_to_bag(mon2_bag, hero_obj)
//   Mons.Game.map_set(pos, hero_idx, hero_obj, game)

Mons.Screen.initial_mons: List(Mons.Object)
  let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.earth, 2u))
  let mon1_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.fire, 2u))
  let mon2_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.water, 2u))
  [mon0_bag, mon1_bag, mon2_bag]

// Mons.test.add_boss(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
//   open hero_obj:
//   let hero_obj = Mons.Object.set_bos([], hero_obj)
//   let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.BUFF, Bool.true, Mons.Type.earth, 0u))
//   let hero_obj = Mons.Object.capture_boss(mon0_bag, hero_obj)
//   Mons.Game.map_set(pos, hero_idx, hero_obj, game)

// Converts a keyboard key to a direction:
// A = [-1,  0,  0]
// D = [ 1,  0,  0]
// W = [ 0, -1,  0]
// S = [ 0,  1,  0]
// * = [ 0,  0,  0]a
Mons.key_to_dir(key_code: U16): Maybe(Mons.Dir)
  if Bool.or(U16.eql(key_code, 'A'),U16.eql(key_code, 'a')) then
    Maybe.some<>(Mons.Dir.left)
  else if Bool.or(U16.eql(key_code, 'D'), U16.eql(key_code, 'd')) then
    Maybe.some<>(Mons.Dir.right)
  else if Bool.or(U16.eql(key_code, 'W'), U16.eql(key_code, 'w')) then
    Maybe.some<>(Mons.Dir.up)
  else if Bool.or(U16.eql(key_code, 'S'), U16.eql(key_code, 's')) then
    Maybe.some<>(Mons.Dir.down)
  else
    Maybe.none<>

Mons.dir_to_set_pad(dir: Mons.Dir): Mons.Object -> Bool -> Mons.Object
  case dir:
  | r => Mons.Object.set_pad_r;
  | u => Mons.Object.set_pad_u;
  | l => Mons.Object.set_pad_l;
  | d => Mons.Object.set_pad_d;

Mons.is_walk_cmd(cmd: Char): Bool
  List.elem<>(Char.eql, cmd, ['W','A','S','D','w','a','s','d'])

Mons.Game.walk(cmd: Char, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  case Mons.key_to_dir(cmd) as maybe_dir:
  | none => game; //unreachable
  | some => 
    let dir     = maybe_dir.value
    let set_pad = Mons.dir_to_set_pad(dir)
    let flag    = Char.is_upper(cmd)
    Mons.Game.update((obj) set_pad(obj, flag), pos, idx, game);

//Mons.game_sprites.push_obj(t_x: U32, t_y: U32, obj: Mons.Object, sprs: List(Mons.Sprite)): List(Mons.Sprite)
  //for img in Mons.Object.get_images(t_x, t_y, obj) with sprs:
    //let ani = Mons.Object.get_ani(obj)
    //let dir = Mons.Object.get_dir(obj)
    //get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
    //let s_z = t_z
    //let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
    //List.cons<>(spr, sprs)

// Converts the game state to a list of sprites to be rendered
// TODO: for some reason, using a `case obj` here causes the
// function not to type check anymore. Investigate why.
Mons.game_sprites(game: Mons.Game): List(Mons.Sprite)
  open game:
  let sprs = []
  case Mons.Game.get_hero_pos(game) as cam_pos:
  | [];
  | let c_x = Pos32.get_x(cam_pos.value)
    let c_y = Pos32.get_y(cam_pos.value)
    let c_z = Pos32.get_z(cam_pos.value)
    for x : U32 = 0u .. 17u with sprs:
      for y : U32 = 0u .. 13u with sprs:
        let t_x = U32.add(U32.sub(c_x, 8u), x)
        let t_y = U32.add(U32.sub(c_y, 6u), y)
        let t_z = c_z
        let pos = Pos32.new(t_x, t_y, t_z) // tile position
        let got = Map.get<>(U32.to_bits(pos), game.map)
        let objs
          = case got:
          | [Mons.Object.void];
          | List.reverse<>(got.value);
        for obj in objs with sprs: // every obj in the tile
          open obj:
          open Mons.Kind.attr(obj.kin) as obj_attr:
          let sprites = obj_attr.wlk(t_x, t_y, obj.ani, obj.dir) // walk sprites
          get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
          let s_z = t_z
          if Mons.Kind.animate_idle(obj.kin) then // TODO: check if is idle
            let cur_spr = Mons.draw.cur_sprite(game.tik, sprites) // get the sprite
            let spr = Mons.Sprite.new(s_x, s_y, s_z, cur_spr)
            List.cons<>(spr, sprs)
          else
          for img in sprites with sprs: // Get the walk sprites
            let ani = Mons.Object.get_ani(obj)
            let dir = Mons.Object.get_dir(obj)
            let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
            List.cons<>(spr, sprs);


// Build sprites around the hero
Mons.Map.build_sprites(game: Mons.Game, scr: Image3D, hero_pos: Pos32, hero_obj: Mons.Object): Image3D
  let sprs = Mons.game_sprites(game)
  for spr in sprs with scr:
  // For each pixel of the sprite...
  open spr:
  let len = Image3D.get_length(spr.img)
  for i : U32 = 0u .. len with scr:
    let s_w = Pos32.get_x(Mons.scr_mid)
    let s_h = Pos32.get_y(Mons.scr_mid)
    // The origin global position (centered on hero)
    let h_x = Pos32.get_x(hero_pos)
    let h_y = Pos32.get_y(hero_pos)
    //let o_x = U32.mul(Pos32.get_x(hero_pos.value), 16u)
    //let o_y = U32.mul(Pos32.get_y(hero_pos.value), 16u)
    get o_x o_y = Mons.draw.global_xy(h_x, h_y, hero_obj)
    // Gets the spr global position
    let s_x = spr.x
    let s_y = spr.y
    let s_z = spr.z
    // Gets the pixel global position (its cpos on img is x=128, y=128)
    let xyz = Image3D.get_pos(i, spr.img)
    let v_x = U32.sub(U32.add(Pos32.get_x(xyz),s_x),Pos32.get_x(Mons.vox_mid))
    let v_y = U32.sub(U32.add(Pos32.get_y(xyz),s_y),Pos32.get_y(Mons.vox_mid))
    let v_z = Pos32.get_z(xyz)
    // Temporary: if pixel is out of screen, make it invisible
    let ok0 = U32.lte(U32.sub(o_x, s_w), v_x) // o_x - s_w <= v_x
    let ok1 = U32.ltn(v_x, U32.add(o_x, s_w)) // v_x < o_x + s_w
    let ok2 = U32.lte(U32.sub(o_y, s_h), v_y) // o_y - s_h <= v_y
    let ok3 = U32.ltn(v_y, U32.add(o_y, s_h)) // v_y < o_y + s_h
    //let ok  = List.and([ok0, ok1, ok2, ok3])
    let ok  = Bool.and(ok0, Bool.and(ok1, Bool.and(ok2, ok3)))
    // Computes the pixel position on the final canvas
    let c_x = U32.sub(U32.add(v_x, Pos32.get_x(Mons.scr_mid)), o_x)
    let c_y = U32.sub(U32.add(v_y, Pos32.get_y(Mons.scr_mid)), o_y)
    let c_z = Bool.if<>(ok, v_z, 0u)
    // Pushes the pixel to the scr
    let pos = Pos32.new(c_x, c_y, c_z) // final pixel pos
    let col = Image3D.get_col(i, spr.img) // final pixel col
    Image3D.push(pos, col, scr) // pushes to scr

// For each tick, updates an object
Mons.Object.tick(obj: Mons.Object): Mons.Object
  open obj:
  // Configs the walk animation
  let obj = Mons.Object.set_ani(obj)
    | if U32.gtn(obj.ani, 0u)
      then U32.sub(obj.ani, 2u)
      else obj.ani;
  // Sets the direction based on pad
  let obj = Mons.Object.set_dir(obj)
    | if Mons.Object.is_free_to_move(obj) then
        open obj.pad:
        if obj.pad.u then
          Mons.Dir.up
        else if obj.pad.l then
          Mons.Dir.left
        else if obj.pad.d then
          Mons.Dir.down
        else if obj.pad.r then
          Mons.Dir.right
        else
          obj.dir
      else
        obj.dir;
  obj

Mons.Object.tick_idle(obj: Mons.Object): Mons.Object
  open obj:
  let len_idle = 4u // qtd of frames in idle. Using 4u for testing
  Mons.Object.set_idl
    | if U32.gtn(obj.idl, 0u)
      then U32.sub(obj.idl, 1u)
      else U32.mul(len_idle, 4u); // fountain has 4 sprites
    | obj;

Mons.Game.dim(game: Mons.Game): U32
  let pos = Mons.Game.get_hero_pos(game)
  case pos:
  | 0u;
  | Pos32.get_z(pos.value);

// Moves an object towards a given direction
Mons.Game.tick_user(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let map = game.map
  let obj_idx = Mons.Map.get_hero(pos, map)
  let obj = Pair.fst<,>(obj_idx)
  let idx = Pair.snd<,>(obj_idx)
  let obj = Mons.Object.tick(obj)
  open obj:
  let old_pos = pos
  let new_pos = Mons.Dir.move(obj.dir, pos)
  let trg = Mons.Map.get_top(new_pos, map)
  open trg:
  let is_walking = Mons.Object.is_walking(obj)
  let is_movfree = Mons.Object.is_free_to_move(obj)
  let is_blocked = Mons.Kind.get_blocks(trg.kin)
  if Bool.and(is_walking, Bool.and(is_movfree, Bool.not(is_blocked))) then
    let obj = Mons.Object.set_ani(obj, 16u)
    let game = Mons.Game.move_obj(old_pos, idx, new_pos, obj, game)
    let game = Mons.Game.set_user_pos(user, new_pos, game)
    game
  else
    Mons.Game.map_set(pos, idx, obj, game)

Mons.Game.tick_game(game: Mons.Game): Mons.Game
  open game:
  Mons.Game.set_tik(U32.add(game.tik, 1u), game)

// Tick player for idle and ticks the game
Mons.Game.tick(game: Mons.Game, time: U64): Mons.Game
  open game:
  // Online mode, update all players
  // for obj_pos in Map.to_list<>(game.pos) with game:
  //   get key pos = obj_pos
  //   let user = Word.from_bits(160, key)
  //   let game = Mons.Game.tick_user(user, pos, game)
  //   game
  let pos = 
    case Mons.Game.get_user_pos(game.usr, game) as hero_pos:
    | Mons.scr_mid;
    | hero_pos.value;
  let game = Mons.Game.tick_user(game.usr, pos, game)
  let game = Mons.Game.tick_game(game)
  game

  

// Mons.Game.animate(obj: Mons.Object, pos: Pos32, idx: U32,game: Mons.Game): Mons.Game
//   open obj:
//   open Mons.Kind.attr(obj.kin) as attr:
//   let ani = // each sprite has durantion of 16 ticks
//     if U32.eql(obj.ani, 0u) then
//       let qtd_spr = List.length<>(attr.spr)
//       U32.mul(qtd_spr, 16u)
//     else U32.sub(obj.ani, 1u)
//   let obj = Mons.Object.set_ani(obj, ani)
//   Mons.Game.map_set(pos, idx, obj, game)

// All valid inputs and its code
Mons.Input.list: List(Pair(Char, Bits))
  let b0 = Bits.0
  let b1 = Bits.1
  let bn = Bits.nil
  [
    {'D', b0(b0(b0(b0(b0(b0(b0(b0(bn))))))))},
    {'W', b0(b0(b0(b0(b0(b0(b0(b1(bn))))))))},
    {'A', b0(b0(b0(b0(b0(b0(b1(b0(bn))))))))},
    {'S', b0(b0(b0(b0(b0(b0(b1(b1(bn))))))))},
    {'U', b0(b0(b0(b0(b0(b1(b0(b0(bn))))))))},
    {'I', b0(b0(b0(b0(b0(b1(b0(b1(bn))))))))},
    {'J', b0(b0(b0(b0(b0(b1(b1(b0(bn))))))))},
    {'K', b0(b0(b0(b0(b0(b1(b1(b1(bn))))))))},
    {'d', b0(b0(b0(b0(b1(b0(b0(b0(bn))))))))},
    {'w', b0(b0(b0(b0(b1(b0(b0(b1(bn))))))))},
    {'a', b0(b0(b0(b0(b1(b0(b1(b0(bn))))))))},
    {'s', b0(b0(b0(b0(b1(b0(b1(b1(bn))))))))},
    {'u', b0(b0(b0(b0(b1(b1(b0(b0(bn))))))))},
    {'i', b0(b0(b0(b0(b1(b1(b0(b1(bn))))))))},
    {'j', b0(b0(b0(b0(b1(b1(b1(b0(bn))))))))},
    {'k', b0(b0(b0(b0(b1(b1(b1(b1(bn))))))))},
    {'P', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'O', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'e', b0(b0(b0(b1(b0(b0(b0(b0(bn))))))))},
    {'E', b0(b0(b0(b1(b0(b0(b0(b1(bn))))))))},
    {'c', b0(b0(b0(b1(b0(b0(b1(b1(bn))))))))},
    {'C', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))},
    {'z', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))},
    {'Z', b0(b0(b1(b0(b0(b0(b0(b0(bn))))))))},
    {'T', b0(b0(b1(b0(b0(b0(b0(b1(bn))))))))} //TODO remove! just using to test heal
  ]

// Maps from chars to their codes
Mons.Input.char_to_code_map: Map(Bits)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(U16.to_bits(char), code, map)

// Maps from codes to their chars
Mons.Input.code_to_char_map: Map(Char)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(code, char, map)

// Serializes an input to its code
Mons.Input.serialize(char: Char): Maybe(Word(256))
  case Map.get<>(U16.to_bits(char), Mons.Input.char_to_code_map) as code:
  | Maybe.none<>;
  | Maybe.some<>(Word.from_bits(256, code.value));

// Deserializes a code to its input
Mons.Input.deserialize(code: Word(256)): Maybe(Char)
  Map.get<>(Bits.slice(8, Word.to_bits<256>(code)), Mons.Input.code_to_char_map)

// Generates an input char from the event down/code info
Mons.Input.char(down: Bool, code: Char): Char
  if down
  then Char.to_upper(code)
  else Char.to_lower(code)

// Online mode room name
Mons.App.room: Word(48)
  Word.from_bits(48, String.to_bits("MON"))

// Startup
Mons.start(online: Bool): App(Mons.Game)
  let screen = Image3D.alloc_capacity(524288u)
  App.new<>
  // Initial state
  | let game_usr = Word.zero(160)
    let game_pos = Map.new<>
    let game_map = Mons.Map.build(Mons.map_source)
    let game = Mons.Game.new(
      game_usr, 
      game_pos, 
      game_map, 
      Mons.Screen.introduction(0u),
      0u
    )
    // let game = Mons.Game.add_animated_obj(game)
    game;
  // Render function
  | (game) App.Render.vox(Mons.draw(game, screen));
  // Event handlers
  | (event, game)
    if online then // online mode
      case event:
      | init => [
        App.Action.print<>("Starting app."),
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        App.Action.state<>(Mons.Game.set_usr(event.addr, game)),
        App.Action.watch<>(Mons.App.room),
        // Sends a J to init our char. TODO: better initialization.
        let chr = Mons.Input.char(Bool.true, '.')
        case Mons.Input.serialize(chr) as data:
        | App.Action.print<>(""); // unreachable
        | App.Action.post<>(Mons.App.room, data.value);
      ];
      | tick => [
        App.Action.state<>(Mons.Game.tick(game, event.time)),
      ];
      | xkey => // send input to server
        let chr = Mons.Input.char(event.down, event.code)
        case Mons.Input.serialize(chr) as data:
        | [];
        | [App.Action.post<>(Mons.App.room, data.value)];;
      | post => // applies input to this post's hero
        // use skp = Debug.log<>("Got post.")
        // use skp = Debug.log<>(Bits.to_string(Word.to_bits<256>(event.data)))
        case Mons.Input.deserialize(event.data) as input:
        | [];
        | [
          // use skp = Debug.log<>(String.concat("Got input:", String.pure(input.value)))
          // use skp = Debug.log<>(String.concat("From user:", Bits.to_string(Word.to_bits<160>(event.addr))))
          open game:
          App.Action.state<>(Mons.Game.cmd(input.value, event.addr, game))
        ];;
    else // offline mode
      case event:
      | init => [
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        let game = Mons.Game.set_usr(event.addr, game)
        let game = Mons.Game.cmd('d', event.addr, game) // inits hero
        open game:
        let pos = 
          case Mons.Game.get_hero_pos(game) as pos:
          | Mons.scr_mid;
          | pos.value;
        let hero_info = Mons.Map.get_hero(pos, game.map)
        let hero_obj = Pair.fst<,>(hero_info)
        let hero_idx = Pair.snd<,>(hero_info)
        let game = Mons.Game.hero_inital_position(game.usr, hero_obj, pos, 0u, game)
        // let game = Mons.test.add_obj(pos, game)
        App.Action.state<>(game),
      ];
      | tick => [App.Action.state<>(Mons.Game.tick(game, event.time))];
      | xkey => [
        open game:
        let chr = Mons.Input.char(event.down, event.code)
        App.Action.state<>(Mons.Game.cmd(chr, game.usr, game))
      ];
      | post => [];;

// Startup (online mode)
Mons.on: App(Mons.Game)
  Mons.start(Bool.true)

// Startup (offline mode)
Mons.off: App(Mons.Game)
  Mons.start(Bool.false)

// Startup (default mode = offline)
Mons: App(Mons.Game)
  Mons.off

//Mons: _
  //let map = Map.new<>
  //let map = Map.set<>(U16.to_bits('i'), 5, map)
  //Map.get<>(U16.to_bits('i'), map)
  //let map = Map.set<>(U16.to_bits('i'), 7)
  //U16.to_bits('i')
//0000000001100001
//0000000001101001
  //Map.get<>(U16.to_bits('h'), Mons.Input.char_to_code_map)
