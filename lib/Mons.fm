// GBA position: divide OpenEMU by 2.575

Mons.placa: Image3D
  Image3D.parse("")

// A Mons sprite
T Mons.Sprite
| Mons.Sprite.new(x: U32, y: U32, z: U32, img: Image3D);

// A direction
T Mons.Dir
| Mons.Dir.right;
| Mons.Dir.up;
| Mons.Dir.left;
| Mons.Dir.down;

T Mons.Map.Dir
| Mons.Map.Dir.right; // r
| Mons.Map.Dir.up; // u
| Mons.Map.Dir.left; // l
| Mons.Map.Dir.down; // d
| Mons.Map.Dir.middle; // m

T Mons.Map.Dir.expanded
| Mons.Map.Dir.expanded.right; // r
| Mons.Map.Dir.expanded.up; // u
| Mons.Map.Dir.expanded.left; // l
| Mons.Map.Dir.expanded.down; // d
| Mons.Map.Dir.expanded.middle; // m
| Mons.Map.Dir.expanded.right_up; // ru
| Mons.Map.Dir.expanded.right_down; // rd
| Mons.Map.Dir.expanded.left_up; // lu
| Mons.Map.Dir.expanded.left_down; // ld
// | Mons.Map.Dir.expanded.circle; // c

//T Mons.Action
//| Mons.Action.walk(dir: Mons.Dir);

//T Mons.Battle.Action
//| Mons.Battle.Action.atk;
//| Mons.Battle.Action.bag;
//| Mons.Battle.Action.mon;
//| Mons.Battle.Action.run;

T Mons.Sign
| Mons.Sign.minus;
| Mons.Sign.zero;
| Mons.Sign.plus;

T Mons.Pad
| Mons.Pad.new(r: Bool, u: Bool, l: Bool, d: Bool);

// A game object
T Mons.Object
| Mons.Object.new(
  kin: Mons.Kind, // represent the type of the object
  dir: Mons.Dir,  // direction the object is facing
  pad: Mons.Pad,  // movement key pad
  ani: U32,       // number of walk frames to animate
  dmg: U32,       // object's current health points
  bag: List(Mons.Object), // store normal Mons
  mon: U32, // idx of the current Mon. Default 0u
  bos: List(Mons.Object), // store Mons that are boss
  cap: Pair(U32, List(Mons.Object)) // store the quantity of Mons and a copy of the captured during game
);

// TODO add more skills
T Mons.Skill
| Mons.Skill.hit_4;
| Mons.Skill.hit_2;
| Mons.Skill.heal;
| Mons.Skill.none;

// TODO remove
Mons.dummy_skills: List(Mons.Skill)
  [ Mons.Skill.hit_4, Mons.Skill.hit_2,
   Mons.Skill.heal, Mons.Skill.none ]

T Mons.Attr
| Mons.Attr.new(
  blocks: Bool,
  battles: Bool,
  mhp: U32,
  atk: U32,
  name: String,
  spr: (x: U32) -> (y: U32) -> (obj_ani: U32) -> (obj_dir: Mons.Dir) -> List(Image3D),
  pic: Image3D,
  battle_spr: (is_up: Bool) -> Image3D,
  skills: List(Mons.Skill)
);
// TODO add:
// def: U32,
// spr: (x: U32) -> (y: U32) -> List(Image3D),
// ...)

// A 2d map of game tiles
Mons.Map: Type
  Map(List(Mons.Object))

//let map = Map.new<>
//let objs = [graminha, arbusto, heroi]
//let map = Map.set(Pos32.to_bits(Pos32.new(2000u,2000u,0u)), objs, map)
//map


// The global game state
T Mons.Game
| Mons.Game.new(
  usr: Word(160), // player name
  pos: Map(Pos32), // player positions
  map: Mons.Map, // the game map
  stt: Mons.Screen // the current state of the game
);

T Mons.Screen
| Mons.Screen.game(cmd: Char); // cmd: movement
| Mons.Screen.inventory(idx: U32);
| Mons.Screen.capture_mon(
  idx: U32, // idx of the Mon to be replaced
  full_bag: Bool);

T Mons.Type
| Mons.Type.normal;
| Mons.Type.earth;
| Mons.Type.fire;
| Mons.Type.water;
| Mons.Type.grass;
| Mons.Type.electric;
| Mons.Type.psychic;
| Mons.Type.ice;
| Mons.Type.light;
| Mons.Type.darkness;


// Sprites are centered at 128x128
Mons.vox_mid: Pos32
  Pos32.new(128u, 128u, 0u) 

// The game screen is 240x160 pixels
Mons.scr_mid: Pos32
  Pos32.new(120u, 80u, 0u)

// The game screen width
Mons.scr_w: U32
  U32.mul(Pos32.get_x(Mons.scr_mid), 2u)

// The game screen height
Mons.scr_h: U32
  U32.mul(Pos32.get_y(Mons.scr_mid), 2u)

// The null pad
Mons.Pad.null: Mons.Pad
  Mons.Pad.new(Bool.false, Bool.false, Bool.false, Bool.false)

// Sets the r field of a pad
Mons.Pad.set_r(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(val, pad.u, pad.l, pad.d)

// Sets the u field of a pad
Mons.Pad.set_u(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, val, pad.l, pad.d)

// Sets the l field of a pad
Mons.Pad.set_l(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, val, pad.d)

// Sets the d field of a pad
Mons.Pad.set_d(pad: Mons.Pad, val: Bool): Mons.Pad
  open pad: Mons.Pad.new(pad.r, pad.u, pad.l, val)

// The void tile
Mons.Object.void: Mons.Object
  let void = Mons.Kind.Terrain(Mons.Kind.terrain.VOID)
  Mons.Object.new(void, Mons.Dir.down, Mons.Pad.null, 0u, 0u, [], 0u, [], {33u, []})

// Gets an object's direction
Mons.Object.get_dir(obj: Mons.Object): Mons.Dir
  open obj: obj.dir

// Sets an object's direction
Mons.Object.set_dir(obj: Mons.Object, dir: Mons.Dir): Mons.Object
  open obj: Mons.Object.new(obj.kin, dir, obj.pad, obj.ani, obj.dmg, obj.bag, obj.mon, obj.bos, obj.cap)

// Gets an object's pad
Mons.Object.get_pad(obj: Mons.Object): Mons.Pad
  open obj: obj.pad

// Sets an object's pad
Mons.Object.set_pad(obj: Mons.Object, pad: Mons.Pad): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, pad, obj.ani, obj.dmg, obj.bag, obj.mon, obj.bos, obj.cap)

// Gets an object's walk animation frames
Mons.Object.get_ani(obj: Mons.Object): U32
  open obj: obj.ani

// Sets an object's walk animation frames
Mons.Object.set_ani(obj: Mons.Object, ani: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, ani, obj.dmg, obj.bag, obj.mon, obj.bos, obj.cap)

// Gets an object's current HP
Mons.Object.get_dmg(obj: Mons.Object): U32
  open obj: obj.dmg

// Gets an object's kind 
Mons.Object.get_kin(obj: Mons.Object): Mons.Kind
  open obj: obj.kin

// Sets an object's current HP
Mons.Object.set_dmg(obj: Mons.Object, dmg: U32): Mons.Object
  open obj: Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, dmg, obj.bag, obj.mon, obj.bos, obj.cap)

// Sets an object's pad.r
Mons.Object.set_pad_r(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_r(obj.pad, val))

// Sets an object's pad.u
Mons.Object.set_pad_u(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_u(obj.pad, val))

// Sets an object's pad.l
Mons.Object.set_pad_l(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_l(obj.pad, val))

// Sets an object's pad.d
Mons.Object.set_pad_d(obj: Mons.Object, val: Bool): Mons.Object
  open obj: Mons.Object.set_pad(obj, Mons.Pad.set_d(obj.pad, val))

Mons.Object.set_bag(bag: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj:
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, bag, obj.mon, obj.bos, obj.cap)

Mons.Object.set_mon(idx: U32, obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, idx, obj.bos, obj.cap)

Mons.Object.set_bos(bos: List(Mons.Object), obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, obj.mon, bos, obj.cap)

Mons.Object.set_cap(cap: Pair(U32, List(Mons.Object)), obj: Mons.Object): Mons.Object
  open obj: 
  Mons.Object.new(obj.kin, obj.dir, obj.pad, obj.ani, obj.dmg, obj.bag, obj.mon, obj.bos, cap)

Mons.Object.qtd_mons_defeated(obj: Mons.Object): U32
  open obj:
  Nat.to_u32(List.length<>(Pair.snd<,>(obj.cap)))

// Hits an object, damaging it
Mons.Object.hit(obj: Mons.Object, dmg: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.add(Mons.Object.get_dmg(obj), dmg))

// Heals an object
Mons.Object.heal(obj: Mons.Object, val: U32): Mons.Object
  Mons.Object.set_dmg(obj, U32.sub(Mons.Object.get_dmg(obj), val))

// Returns true if any of the object's pad is non-zero (it is walking)
Mons.Object.is_walking(obj: Mons.Object): Bool
  open obj:
  open obj.pad:
  let is_walking_x = Bool.or(obj.pad.u, obj.pad.d)
  let is_walking_y = Bool.or(obj.pad.l, obj.pad.r)
  Bool.or(is_walking_x, is_walking_y)

// Is this object free to move?
Mons.Object.is_free_to_move(obj: Mons.Object): Bool
  open obj:
  U32.eql(obj.ani, 0u)

Mons.Object.is_standing(obj: Mons.Object): Bool
  U32.eql(Mons.Object.get_ani(obj),0u)

Mons.walk_char_pack(
  t_x: U32,
  t_y: U32,
  ani: U32,
  dir: Mons.Dir,
  r_0: Image3D,
  u_0: Image3D,
  l_0: Image3D,
  d_0: Image3D,
  r_1: Image3D,
  u_1: Image3D,
  l_1: Image3D,
  d_1: Image3D,
  r_2: Image3D,
  u_2: Image3D,
  l_2: Image3D,
  d_2: Image3D
): List(Image3D)
  //0 = parado
  //1 = pe direito pra frente
  //2 = pe esquerdo pra frente
  if U32.eql(ani, 0u) then
    case dir:
    | right => [r_0];
    | up    => [u_0];
    | left  => [l_0];
    | down  => [d_0];
  else
    if U32.eql(U32.mod(U32.add(t_x,t_y),2u), 0u) then
      case dir:
      | right => [r_1];
      | up    => [u_1];
      | left  => [l_1];
      | down  => [d_1];
    else
      case dir:
      | right => [r_2];
      | up    => [u_2];
      | left  => [l_2];
      | down  => [d_2];
  
// An empty map
Mons.Map.new: Mons.Map
  Map.new<>

// Adds a tile to a position on the map
Mons.Map.set_list(pos: Pos32, objs: List(Mons.Object), map: Mons.Map): Mons.Map
  Map.set<>(U32.to_bits(pos), objs, map)

// Gets the tile stored on a position on the map
Mons.Map.get_list(pos: Pos32, map: Mons.Map): List(Mons.Object)
  case Map.get<>(U32.to_bits(pos), map) as got:
  | [];
  | got.value;

// Gets the nth object of a tile
Mons.Map.get(pos: Pos32, idx: U32, map: Mons.Map): Mons.Object
  let list = Mons.Map.get_list(pos, map)
  case List.at<>(U32.to_nat(idx), list) as got:
  | Mons.Object.void;
  | got.value;

// Sets the nth object of a tile
Mons.Map.set(pos: Pos32, idx: U32, val: Mons.Object, map: Mons.Map): Mons.Map
  let list = Mons.Map.get_list(pos, map)
  let list = List.update_at<>(U32.to_nat(idx), () val, list)
  Mons.Map.set_list(pos, list, map)

// Pushes an object to the top of a tile
Mons.Map.push(pos: Pos32, obj: Mons.Object, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.cons<>(obj, objs)
  Mons.Map.set_list(pos, objs, map)

// Pops an object from the top of a tile
Mons.Map.pop(pos: Pos32, map: Mons.Map): Pair(Mons.Map, Mons.Object)
  let objs = Mons.Map.get_list(pos, map)
  case objs:
  | Pair.new<,>(map, Mons.Object.void);
  | let map = Mons.Map.set_list(pos, objs.tail, map)
    Pair.new<,>(map, objs.head);

// Gets the the object on top of a tile
Mons.Map.get_top(pos: Pos32, map: Mons.Map): Mons.Object 
  Pair.snd<,>(Mons.Map.pop(pos,map))

// Gets the hero's object and its index from a tile
Mons.Map.get_hero(pos: Pos32, map: Mons.Map): Pair(Mons.Object, U32)
  let tile = Mons.Map.get_list(pos, map)
  let obj_is_hero = ((obj) Mons.Kind.is_hero(Mons.Object.get_kin(obj))) :: Mons.Object -> Bool 
  let fun = ((obj, idx) obj_is_hero(obj)) :: Mons.Object -> Nat -> Bool
  let both = List.ifind<>(tile, fun)
  case both: 
  | none => Pair.new<,>(Mons.Object.void, 0u);
  | some => 
    let hero = Pair.fst<,>(both.value)
    let idx = Nat.to_u32(Pair.snd<,>(both.value))
    Pair.new<,>(hero, idx);

// Deletes an object from a tile
Mons.Map.del(pos: Pos32, idx: U32, map: Mons.Map): Mons.Map
  let objs = Mons.Map.get_list(pos, map)
  let objs = List.delete_at.u32<>(idx, objs)
  Mons.Map.set_list(pos, objs, map)

// Each theme will have 2 levels: one of Mons and other for the boss.
// The boss will have a different background.
// TODO: adjust images for each level;
Mons.Map.background(idx: U32): Pair(Image3D, Image3D)
  if U32.eql(idx, 0u) then
    {Mons.Assets.battle_grass_bg, Mons.Assets.battle_grass_full_bg}
  else if U32.eql(idx, 1u) then
    {Mons.Assets.battle_snow_bg, Mons.Assets.battle_snow_full_bg}
  else
    {Mons.Assets.battle_grass_bg, Mons.Assets.battle_grass_full_bg}

Mons.Map.get_battle_bg(idx: U32): Image3D
  Pair.fst<,>(Mons.Map.background(idx))

Mons.Map.get_full_bg(idx: U32): Image3D
  Pair.snd<,>(Mons.Map.background(idx))

Mons.Object.push_to_bag(obj: Mons.Object, hero: Mons.Object): Mons.Object
  open obj:
  open hero:
  let qtd = List.length<>(hero.bag)
  case obj.kin as kind:
  | mon =>
    let obj = Mons.Object.set_dmg(obj, 0u)
    if Nat.ltn(qtd, 3) then
      let new_bag = List.append<>(hero.bag, obj)
      Mons.Object.set_bag(new_bag, hero)
    else
      hero;
  | const => hero;
  | terrain => hero;

Mons.Object.add_defeated_mon(obj: Mons.Object, hero: Mons.Object): Mons.Object
  open obj:
  open hero:
   case obj.kin as kind:
  | mon =>
    let qtd_mons = Pair.fst<,>(hero.cap)
    let mons_defeated = Pair.snd<,>(hero.cap)
    let new_cap = {qtd_mons, List.append<>(mons_defeated, obj)}
    Mons.Object.set_cap(new_cap, hero)
  ;
  | const => hero;
  | terrain => hero;

Mons.Object.capture_boss(boss: Mons.Object, hero: Mons.Object): Mons.Object
  open boss:
  open hero:
  case boss.kin as kind:
  | mon => 
    let new_boss_bag = List.append<>(hero.bos, boss)
    Mons.Object.set_bos(new_boss_bag, hero);
  | const => hero;
  | terrain => hero;

Mons.Object.pop_from_bag(obj: Mons.Object): Mons.Object
  open obj:
  let qtd = List.length<>(obj.bag)
  if Nat.eql(qtd, 1) then
    obj
  else
    let new_bag = List.drop<>(1, obj.bag)
    Mons.Object.set_bag(new_bag, obj)

Mons.Object.delete_from_bag(idx: U32, hero_obj: Mons.Object): Mons.Object
  let idx_nat = U32.to_nat(idx)
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then hero_obj
  else
    let new_bag = List.delete_at<>(idx_nat, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj)
    Mons.Object.set_mon(0u, hero_obj)

Mons.Object.is_bag_full(obj: Mons.Object): Bool
  open obj:
  let size = List.length<>(obj.bag)
  Nat.eql(size, 3)

// Get names in a list of Mons.Objects
Mons.Object.get_names(bag: List(Mons.Object)): List(String)
  let names = List.nil<String>
  for mon in bag with names:
    open mon:
    let name = Mons.Kind.get_name(mon.kin);
    List.cons<>(name, names)

// Get images in a list of Mons.Objects
Mons.Object.get_images(bag: List(Mons.Object)): List(Image3D)
  let images = List.nil<Image3D>
  for mon in bag with images:
    open mon:
    let mon_attr = Mons.Kind.attr(mon.kin)
    open mon_attr:
    List.cons<Image3D>(mon_attr.pic, images)

Mons.Object.hero: Mons.Object
  Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.HERO, Bool.false, Mons.Type.fire, 1u))

Mons.Object.is_battleable(obj: Mons.Object): Bool
  open obj:
  case obj.kin as mon:
  | mons => Bool.true;
  | const => Bool.false;
  | terrain => Bool.false;

// Calculate the damage received depending on the type of the Mon
Mons.Type.skill_n_type(val: U32, source_obj: Mons.Object, target_obj: Mons.Object): U32
  open source_obj:
  case source_obj.kin as s_kind:
  | mon =>
    open target_obj:
    case target_obj.kin as t_kind:
    | mon => 
      case s_kind.pri_type as s_type:
      | s_normal =>
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => val; // 1x
        | t_water  => val; // 1x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x 
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); // 0,5x
        | t_darkness => val; // 1x
      ;
      | s_earth => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => U32.mul(val, 2u); //2x
        | t_water  => val; //1x
        | t_grass  => U32.div(val, 2u); // 0,5x
        | t_electric => U32.mul(val, 2u); // 2x
        | t_psychic  => val;
        | t_ice   => val;
        | t_light => U32.mul(val, 2u); // 2x
        | t_darkness => val;
      ;
      | s_fire => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => val; // 1x
        | t_fire   => U32.div(val, 2u); // 0,5x
        | t_water  => U32.div(val, 2u); // 0,5x
        | t_grass  => U32.mul(val, 2u); // 2x
        | t_electric => val;
        | t_psychic  => val;
        | t_ice   => U32.mul(val, 2u); // 2x
        | t_light => U32.mul(val, 2u); // 2x
        | t_darkness => val;
      ;
      | s_water => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_grass => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_electric => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.div(val, 2u); //0,5x
        | t_electric => U32.div(val, 2u); //0,5x
        | t_psychic  => val; // 1x
        | t_ice   => val; // 1x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_psychic=> 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => U32.div(val, 2u); //0,5x
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => val; // 1x
      ;
      | s_ice => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => U32.mul(val, 2u); // 2x
        | t_electric => val; // 1x
        | t_psychic  => val; // 1x
        | t_ice   => U32.div(val, 2u); //0,5x
        | t_light => val; // 1x
        | t_darkness => val; // 1x
      ;
      | s_light => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val; // 1x
        | t_electric => val; // 1x
        | t_psychic  => U32.mul(val, 2u); // 2x
        | t_ice   => val; // 1x
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => U32.mul(val, 2u); // 2x
      ;
      | s_darkness => 
        case t_kind.pri_type as t_type:
        | t_normal => val; // 1x
        | t_earth  => U32.mul(val, 2u); // 2x
        | t_fire   => U32.mul(val, 2u); // 2x
        | t_water  => U32.div(val, 2u); //0,5x
        | t_grass  => val;
        | t_electric => val;
        | t_psychic  => U32.mul(val, 2u); // 2x
        | t_ice   => val;
        | t_light => U32.div(val, 2u); //0,5x
        | t_darkness => U32.div(val, 2u); //0,5x
      ;
    ;
    | construction => 0u;
    | terrain => 0u;
  ;
  | construction => 0u;
  | terrain => 0u;

Mons.Type.name(obj: Mons.Object): String
  open obj:
  case obj.kin as kind:
  | mon =>
    case kind.pri_type as type:
    | normal => "normal";
    | earth => "earth";
    | fire => "fire";
    | water => "water";
    | grass  => "grass";
    | electric => "electric";
    | psychic  => "psychic";
    | ice   => "ice";
    | light => "light";
    | darkness => "darkness";
  ;
  | construction => "none";
  | terrain => "none";

// Creates a new object with a given kind
Mons.Object.new_of_kind(kin: Mons.Kind): Mons.Object
  // kin, dir, pad, ani, dmg, bag, mon, bos, cap
  Mons.Object.new(kin, Mons.Dir.down, Mons.Pad.null, 1u, 0u, [], 0u, [], {33u, []})

Mons.Map.code_to_tile.aux(code: String, cond: List(Pair(String, List(Mons.Object)))) : List(Mons.Object)
  case cond:
  | nil  => [];
  | cons =>
    get str objs = cond.head
    if String.eql(code, str) then 
      objs 
    else 
     Mons.Map.code_to_tile.aux(code, cond.tail);

// Converts a tile code (ex: ".g") into a list of obs
Mons.Map.code_to_tile(code: String): List(Mons.Object)
  let grass = Mons.Object.new_of_kind(Mons.Kind.Terrain(Mons.Kind.terrain.GRASS))
  let rock_path = Mons.Object.new_of_kind(Mons.Kind.Const(Mons.Kind.const.ROCK_PATH_M, Bool.false))

  Mons.Map.code_to_tile.aux(code,[
    { ".g", [ grass ]},
    { ".d", [ Mons.Kind.new_terrain(Mons.Kind.terrain.GRASS_PLANT) ]},
    { "bg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.BUSH), grass ]},
    { "pg", [ Mons.Kind.new_terrain(Mons.Kind.terrain.PLANT_0), grass ]},
    { "t0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_00) ]},
    { "t1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_01) ]},
    { "t2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ELV_TERRAIN_02) ]},
    { "w0", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.up)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "wm", [ Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.middle)) ]},
    { "w1", [ 
      Mons.Object.new_of_kind( Mons.Kind.Terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.left))),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "w2", [ 
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.right)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0)
     ]},
    { "w3", [
      Mons.Kind.new_terrain(Mons.Kind.terrain.OCEAN(Mons.Map.Dir.down)),
      Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "T0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 0)), grass]},
    { "T1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(0, 1)), grass ]},
    { "/0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 0)), grass ]},
    { "/1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 1)) ]},
    { "/2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(1, 2)), grass ]},
    { "B0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 0)), grass ]},
    { "B1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(1, 1)), grass ]},
    { "P0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(2, 0)), grass ]},
    { "P1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(2, 1)), grass ]},
    { "P2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(3, 0)), grass ]},
    { "P3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(3, 1)), grass ]},
    { "P4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(4, 0)), grass ]},
    { "P5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(4, 1)), grass ]},
    { "P6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(5, 0)), grass ]},
    { "P7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(5, 1)), grass ]},
    { "P8", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(6, 0)), grass ]},
    { "P9", [ Mons.Kind.new_terrain(Mons.Kind.terrain.TREE(7, 0)), grass ]},    
    { ".s", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_C), grass ]},
    { ".r", [ Mons.Kind.new_const(Mons.Kind.const.ROCK_PATH_M) ]},

    { "30", Mons.Kind.new_mons(Mons.Kind.mons.BATH, Mons.Type.normal, 2u) },
    { "31", Mons.Kind.new_mons(Mons.Kind.mons.BEHOLDER, Mons.Type.water, 2u) },
    { "32", Mons.Kind.new_mons(Mons.Kind.mons.CRONI, Mons.Type.fire, 2u) },
    { "33", Mons.Kind.new_mons(Mons.Kind.mons.ELLIOT, Mons.Type.water, 2u) },
    { "34", Mons.Kind.new_mons(Mons.Kind.mons.ESPECTRONUS, Mons.Type.water, 2u) },
    { "35", Mons.Kind.new_mons(Mons.Kind.mons.GAKI, Mons.Type.water, 2u) },
    { "36", Mons.Kind.new_mons(Mons.Kind.mons.GORR, Mons.Type.fire, 2u) },
    { "37", Mons.Kind.new_mons(Mons.Kind.mons.LAMURIA, Mons.Type.water, 2u) },
    { "38", Mons.Kind.new_mons(Mons.Kind.mons.RAFIRE, Mons.Type.fire, 2u) },
    { "39", Mons.Kind.new_mons(Mons.Kind.mons.VARGOULI, Mons.Type.earth, 2u) },
    { "40", Mons.Kind.new_mons(Mons.Kind.mons.TUPITREE, Mons.Type.earth, 2u) },
    { "41", Mons.Kind.new_mons(Mons.Kind.mons.LELA, Mons.Type.fire, 2u) },
    { "42", Mons.Kind.new_mons(Mons.Kind.mons.MOSHY, Mons.Type.earth, 2u) },
    { "43", Mons.Kind.water_with_kin(Mons.Kind.mons.ESPECTRONUS, Mons.Type.water, 2u) },
    { "44", Mons.Kind.water_with_kin(Mons.Kind.mons.LAMURIA, Mons.Type.water, 2u)},
    { "45", Mons.Kind.new_mons(Mons.Kind.mons.POISOLICK, Mons.Type.water, 2u) },
    { "46", Mons.Kind.new_boss(Mons.Kind.mons.BUFF, Mons.Type.fire, 0u) },
    { "47", Mons.Kind.new_boss(Mons.Kind.mons.LAUGH, Mons.Type.water, 0u) },
    { "48", Mons.Kind.new_mons(Mons.Kind.mons.COBE_ORN, Mons.Type.water, 2u) },
    { "49", Mons.Kind.new_mons(Mons.Kind.mons.SANDY, Mons.Type.water, 2u) },
    { "50", Mons.Kind.new_mons(Mons.Kind.mons.SLIME, Mons.Type.water, 2u) },
    { "51", Mons.Kind.new_mons(Mons.Kind.mons.MIMIC, Mons.Type.fire, 2u) },
    { "52", Mons.Kind.new_mons(Mons.Kind.mons.SPARKY, Mons.Type.earth, 2u) },
    { "53", Mons.Kind.new_mons(Mons.Kind.mons.DOOMFIRE, Mons.Type.fire, 2u) },
    { "54", Mons.Kind.new_mons(Mons.Kind.mons.BEANSTRONG, Mons.Type.earth, 2u) },
    { "55", Mons.Kind.new_mons(Mons.Kind.mons.NAMELESS, Mons.Type.earth, 2u) },
    { "56", Mons.Kind.new_boss(Mons.Kind.mons.OCTOKING, Mons.Type.water, 0u) },
    { "57", Mons.Kind.new_mons(Mons.Kind.mons.INPUBU, Mons.Type.earth, 2u) },
    { "58", Mons.Kind.new_mons(Mons.Kind.mons.EMERELDER, Mons.Type.earth, 2u) },
    { "59", Mons.Kind.new_mons(Mons.Kind.mons.ZOIO, Mons.Type.earth, 2u) },
    { "60", Mons.Kind.new_mons(Mons.Kind.mons.IGNITE, Mons.Type.fire, 2u) },
    { "61", Mons.Kind.new_mons(Mons.Kind.mons.FROST, Mons.Type.earth, 2u) },
    { "62", Mons.Kind.new_mons(Mons.Kind.mons.FRAB, Mons.Type.earth, 2u) },
    { "63", Mons.Kind.new_mons(Mons.Kind.mons.ELECTROWL, Mons.Type.earth, 2u) },
    { "64", Mons.Kind.new_mons(Mons.Kind.mons.NOCTUBRIGHT, Mons.Type.earth, 2u) },

    { "K0", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 0)), rock_path ]},
    { "K1", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 1)) ]},
    { "K2", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 2)) ]},
    { "K3", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 3)) ]},
    { "K4", [ Mons.Kind.new_const(Mons.Kind.const.HOUSE(0, 4)), rock_path ]},
    { "C0", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 0)) rock_path ]},
    { "C1", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 1)) rock_path ]},
    { "C2", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 2)), rock_path ]},
    { "C3", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 3)), rock_path ]},
    { "C4", [ Mons.Kind.new_const(Mons.Kind.const.CASTLE(0, 4)), rock_path ]},
    { "W0", [ Mons.Kind.new_const(Mons.Kind.const.WELL(0, 0)), grass ]},
    { "W1", [ Mons.Kind.new_const(Mons.Kind.const.WELL(0, 1)), grass ]},
    { "A0", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 0)), rock_path ]},
    { "A1", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 1)), rock_path ]},
    { "A2", [ Mons.Kind.new_const(Mons.Kind.const.FONTAIN(0, 2)), rock_path ]},
    { "p1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(0, 0)), grass ]},
    { "p2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(0, 1)), grass ]},
    { "p3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(1, 0)), grass ]},
    { "p4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(2, 0)), grass ]},
    { "p5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(2, 1)), grass ]},
    { "p6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(3, 0)), grass ]},
    { "p7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(4, 0)), grass ]},
    { ".p", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(5, 0)), grass ]},
    { "p8", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(6, 0)), grass ]},
    { "pp", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(7, 0)), grass ]},
    { "po", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(8, 0)), grass ]},
    { "p9", [ Mons.Kind.new_terrain(Mons.Kind.terrain.ROCK(9, 0)), grass ]},    
    { "S0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_0) ]},
    { "S1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.SAND_1) ]},
    { "ch", [ Mons.Kind.new_portal(Mons.Kind.const.CHEST) ]},
    { "s0", [ Mons.Kind.new_const(Mons.Kind.const.SIGN_0), grass ]},
    { "s1", [ Mons.Kind.new_const(Mons.Kind.const.SIGN_1), grass ]},
    { "om", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.middle))]},
    { "on", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER1_M) ]},
    { "o0", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right)), grass ]},
    { "o1", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.up)), grass ]},
    { "o2", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left)), grass ]},
    { "o3", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.down)), grass ]},
    { "o4", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_up)), grass]},
    { "o5", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_up)), grass ]},
    { "o6", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.left_down)), grass ]},
    { "o7", [ Mons.Kind.new_terrain(Mons.Kind.terrain.WATER(Mons.Map.Dir.expanded.right_down)), grass ]},
    { "xx", [ Mons.Kind.new_const(Mons.Kind.const.PATH_BLOCKER) ]},
    { "f0", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right)), grass ]},
    { "f1", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.middle)), grass ]},
    { "f2", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left)), grass ]},
    { "f3", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_up)), grass ]},
    { "f4", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_up)), grass ]},
    { "f5", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.left_down)), grass ]},
    { "f6", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(0, Mons.Map.Dir.expanded.right_down)), grass ]},
    { "fa", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right)), grass ]},
    { "fb", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.middle)), grass ]},
    { "fc", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left)), grass ]},
    { "fd", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right_up)), grass ]},
    { "fe", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left_up)), grass ]},
    { "ff", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.left_down)), grass ]},
    { "fg", [ Mons.Kind.new_const(Mons.Kind.const.FENCE(1, Mons.Map.Dir.expanded.right_down)), grass ]},    
  ])

// Converts a string map source to an actual map
Mons.Map.build(code: List(List(String))): Mons.Map
  List.ifor.u32<>(code)<>
  | Mons.Map.new;
  | (z, plane, map) 
    let size = List.length.u32<>(plane) // NOTE: assumes width == height
    List.ifor.u32<>(plane)<>
    | map;
    | (j, row, map)
      for i : U32 = 0u .. size with map:
        let t_x = U32.add(U32.sub(2048u, U32.div(size, 2u)), i)
        let t_y = U32.add(U32.sub(2048u, U32.div(size, 2u)), j)
        let t_z = z
        let pos = Pos32.new(t_x, t_y, t_z)
        let ini = U32.to_nat(U32.mul(i,2u)) // slice start index
        let end = U32.to_nat(U32.add(U32.mul(i,2u),2u)) // slice end index
        let sli = String.slice(ini, end, row) // slice with tile code
        Mons.Map.set_list(pos, Mons.Map.code_to_tile(sli), map);;   

// Get the game user
Mons.Game.get_usr(game: Mons.Game): Word(160)
  open game: game.usr

// Set the game user
Mons.Game.set_usr(usr: Word(160), game: Mons.Game): Mons.Game
  open game: Mons.Game.new(usr, game.pos, game.map, game.stt)

Mons.Game.set_stt(stt: Mons.Screen, game: Mons.Game): Mons.Game
  open game: Mons.Game.new(game.usr, game.pos, game.map, stt)

// Gets an user's position
Mons.Game.get_user_pos(user: Word(160), game: Mons.Game): Maybe(Pos32)
  open game:
  Map.get<>(Word.to_bits<160>(user), game.pos)

// Sets an user's position
Mons.Game.set_user_pos(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, Map.set<>(Word.to_bits<160>(user), pos, game.pos), game.map, game.stt)

// Gets the hero's position
Mons.Game.get_hero_pos(game: Mons.Game): Maybe(Pos32)
  open game: Mons.Game.get_user_pos(game.usr, game)

// Sets the game map
Mons.Game.set_map(map: Mons.Map, game: Mons.Game): Mons.Game
  open game:
  Mons.Game.new(game.usr, game.pos, map, game.stt)

Mons.Game.update_obj(obj: Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Updates the object at given position on the game map
Mons.Game.update(fn: Mons.Object -> Mons.Object, pos: Pos32, idx: U32, game: Mons.Game): Mons.Game
  open game:
  let obj = fn(Mons.Map.get(pos, idx, game.map))
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

Mons.Game.get_tile(pos: Pos32, game: Mons.Game): List(Mons.Object)
  open game:
  Mons.Map.get_list(pos, game.map)

Mons.Game.move_obj(from: Pos32, idx: U32, to: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game 
  let game = Mons.Game.map_del(from, idx, game)
  let game = Mons.Game.map_push(to, obj, game)
  game

Mons.Game.delete_adve_obj(
  adve_obj: Mons.Object, 
  hero_obj: Mons.Object, 
  pos: Pos32,
  hero_idx: U32,
  adve_idx: U32,
  game: Mons.Game): Mons.Game
  let game = Mons.Game.map_del(pos, adve_idx, game)
  let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
  Mons.Game.set_stt(Mons.Screen.game('.'), game)
  
Mons.Game.move_hero_down(
  usr: Word(160), 
  hero_obj: Mons.Object, 
  pos: Pos32, 
  hero_idx: U32, 
  game: Mons.Game): Mons.Game
  let y = Pos32.get_y(pos)
  let x = Pos32.get_x(pos)
  let z = Pos32.get_z(pos)
  let new_pos = Pos32.new(x,U32.add(y, 1u),z)
  let game = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game) 
  Mons.Game.set_user_pos(usr, new_pos, game)

// hero and adve have some hp
Mons.Object.is_battling(adve: Mons.Object, hero_or_mon: Mons.Object): Bool
  let is_adve_alive = Bool.not(Mons.Object.is_obj_defeated(adve))
  let is_hero_alive = Bool.not(Mons.Object.is_obj_defeated(hero_or_mon))
  Bool.and(is_adve_alive, is_hero_alive)
  

Mons.Object.ended_battle(adve: Mons.Object, hero: Mons.Object): Bool
  open adve:
  open hero:
  case adve.kin:
  | mon => 
    let adve_kin = Mons.Kind.attr(adve.kin)
    let hero_kin = Mons.Kind.attr(hero.kin)
    open adve_kin:
    open hero_kin:
    let adve_status = Mons.Object.is_obj_defeated(adve)
    let hero_status = Mons.Object.is_obj_defeated(hero)
    Bool.or(adve_status, hero_status)  
  ;
  | const => Bool.false;
  | terrain => Bool.false;
  
Mons.Object.is_obj_defeated(obj: Mons.Object): Bool
  if U32.eql(Mons.Object.remaing_hp(obj), 0u) 
  then Bool.true 
  else Bool.false

Mons.Object.remaing_hp(obj: Mons.Object): U32
  open obj:
  case obj.kin as kind:
  | mons => 
    open Mons.Kind.attr(obj.kin) as kind:
    U32.sub(kind.mhp, obj.dmg);
  | const => obj.dmg;
  | terrain => obj.dmg;

Mons.Object.get_current_mon(obj: Mons.Object): Mons.Object
  open obj:
  let idx = U32.to_nat(obj.mon)
  case List.at<>(idx, obj.bag) as mon:
  | obj;
  | mon.value;

// When hero wins a battle, adds the adversary to hero's game
// and updates de game status
Mons.Game.hero_won_batle(
  adve_obj: Mons.Object,
  hero_obj: Mons.Object,
  hero_pos: Pos32,
  hero_idx: U32,
  game: Mons.Game
): Mons.Game
  open game:
  let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
  let game = Mons.Game.update((hero_obj) hero_obj, hero_pos, hero_idx, game)
  game

// Mons.Attr with "battles" equals to Bool.true
Mons.Attr.new_battleable(
  pic: Image3D,
  spr: List(Image3D),
  name: String,
  battle_spr: Bool -> Image3D
  ): Mons.Attr
  Mons.Attr.new(
    Bool.false, Bool.true, 40u, 0u, name,
    Mons.Kind.set_static_sprites(spr),
    pic,
    battle_spr, Mons.dummy_skills)

// Mons.Attr with "block" equals to Bool.true
Mons.Attr.new_blockable(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.true, Bool.false, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

// Mons.Attr with "block" and "batlles" equals to Bool.false
Mons.Attr.new_neutral(spr: List(Image3D)): Mons.Attr
  Mons.Attr.new(
    Bool.false, Bool.false, 0u, 0u, "",
    Mons.Kind.set_static_sprites(spr),
    Mons.Kind.set_pic(spr),
    Mons.Kind.set_default_battle_spr, [])

Mons.Attr.new_hero: Mons.Attr
  Mons.Attr.new(Bool.false, Bool.false, 40u, 0u, "HERO",
    (x,y,obj_ani,obj_dir) 
      Mons.walk_char_pack(
        x, y, obj_ani, obj_dir,
        Mons.Assets.boy_r_0, Mons.Assets.boy_u_0, 
        Mons.Assets.boy_l_0, Mons.Assets.boy_d_0,

        Mons.Assets.boy_r_1, Mons.Assets.boy_u_1,
        Mons.Assets.boy_l_1, Mons.Assets.boy_d_1,

        Mons.Assets.boy_r_2, Mons.Assets.boy_u_2,
        Mons.Assets.boy_l_2, Mons.Assets.boy_d_2),
        Mons.Assets.boy_d_0,
      (is_up) Bool.if<>(is_up,Mons.Assets.battle_hero_u,Mons.Assets.battle_hero_u),
      Mons.dummy_skills 
  )

Mons.Dir.move(dir: Mons.Dir, pos: Pos32): Pos32
  case dir:
  | Pos32.add(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.sub(pos, Pos32.new(0u, 1u, 0u));
  | Pos32.sub(pos, Pos32.new(1u, 0u, 0u));
  | Pos32.add(pos, Pos32.new(0u, 1u, 0u));

Mons.Skill.get_name(skill: Mons.Skill): String
  case skill:
  | hit_4  => "hit 4";
  | hit_2  => "hit 2";
  | heal   => "heal"; 
  | dummu_none => "none";

Mons.update_mon_obj(
  hero_obj: Mons.Object,
  obj_updated: Mons.Object,
  pos: Pos32,
  idx: U32,
  game: Mons.Game) : Mons.Game
  open hero_obj:
  let qtd = List.length<>(hero_obj.bag)
  if Nat.eql(qtd, 0) then
    Mons.Game.map_set(pos, idx, obj_updated, game) // hero_obj
  else //game
    let idx_nat = U32.to_nat(hero_obj.mon)
    let new_bag = List.update_at<>(idx_nat, (a) obj_updated, hero_obj.bag)
    let hero_obj = Mons.Object.set_bag(new_bag, hero_obj) 
    Mons.Game.map_set(pos, idx, hero_obj, game)

Mons.damage(obj: Mons.Object, pos: Pos32, idx: U32, dmg: U32, game: Mons.Game): Mons.Game
  let obj_updated = Mons.Object.hit(Mons.Object.get_current_mon(obj), dmg)
  Mons.update_mon_obj(obj, obj_updated, pos, idx, game)

Mons.heal(obj: Mons.Object, pos: Pos32, idx: U32, val: U32, game: Mons.Game): Mons.Game 
  let obj_updated = Mons.Object.heal(Mons.Object.get_current_mon(obj), val)
  if Mons.Object.is_obj_defeated(obj_updated) then game
  else Mons.update_mon_obj(obj, obj_updated, pos, idx, game)

// pos    : position of the map in which the battle is taking place
// source : index of the object which is casting a skill
// target : index of the object which is receiving the effect 
Mons.cast(pos: Pos32, source: U32, target: U32, skill: Mons.Skill, game: Mons.Game): Mons.Game 
  open game:
  let source_obj = Mons.Map.get(pos, source, game.map)
  let source_mon = Mons.Object.get_current_mon(source_obj)
  let target_obj = Mons.Map.get(pos, target, game.map)
  let target_mon = Mons.Object.get_current_mon(target_obj)
  case skill:
  | hit_4  =>
    let val = Mons.Type.skill_n_type(4u, source_mon, target_mon)
    Mons.damage(target_obj, pos, target, val, game);
  | hit_2 => 
    let val = Mons.Type.skill_n_type(2u, source_mon, target_mon)
    Mons.damage(target_obj, pos, target, val, game);
  | heal => Mons.heal(source_obj, pos, source, 3u, game);
  | none => game;

// TODO: change Mons.Game.cmd to receive 'pos' instead, and use this one for usr
// Mons.Game.cmd_usr(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game

// Update a Mons.Game by pushing a new obj to a pos
Mons.Game.map_push(pos: Pos32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.push(pos, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by setting a new obj to a pos
Mons.Game.map_set(pos: Pos32, idx: U32, obj: Mons.Object, game: Mons.Game): Mons.Game
  open game:
  let map = Mons.Map.set(pos, idx, obj, game.map)
  Mons.Game.set_map(map, game)

// Update a Mons.Game by deleting an obj from a tile
Mons.Game.map_del(pos: Pos32, idx: U32, game: Mons.Game): Mons.Game 
  open game: 
  let map = Mons.Map.del(pos, idx, game.map)
  Mons.Game.set_map(map, game)

// Computes a command from an user
Mons.Game.cmd(cmd: Char, usr: Word(160), game: Mons.Game): Mons.Game
  let pos = Mons.Game.get_user_pos(usr, game)
  case pos:
  // New player
  | let pos = Pos32.new(2048u, 2048u, 0u)
    let obj = Mons.Object.hero
    let game = Mons.Game.map_push(pos, obj, game)
    let game = Mons.Game.set_user_pos(usr, pos, game)
    game;
  // Existing player
  | open game:
    let pos = pos.value
    let hero_pair = Mons.Map.get_hero(pos, game.map)
    let hero_obj  = Pair.fst<,>(hero_pair)
    let hero_idx  = Pair.snd<,>(hero_pair)
    let adve_idx  = 1u
    let adve_obj = Mons.Map.get(pos, adve_idx, game.map)
    let is_battling = Mons.Object.is_battling(adve_obj, hero_obj)
    let end_battle = Mons.Object.ended_battle(adve_obj, hero_obj)
    let curr_mon = Mons.Object.get_current_mon(hero_obj)
    open curr_mon: 
    let skills = Mons.Kind.get_skills(curr_mon.kin)
    // let game = Mons.test.add_bag(hero_obj, pos, 0u, game) // TEST - bag
    // let game = Mons.test.add_boss(hero_obj, pos, 0u, game) // TEST - boss

    open hero_obj:
    open adve_obj:
    // TODO let usr = Mons.Game.get_from_map(pos, game) // gets the object that used the command
    // TODO let atks = Mons.Game.get_attack_list(usr.kin)... // gets the attack list of that usr
    case game.stt as stt:
    | game =>
    // TODO remove - just testing dmg to hero to check heal eff
    if U16.eql(cmd, 'T') then
      if Mons.Object.is_obj_defeated(hero_obj) then
        let hero_obj = Mons.Object.set_dmg(hero_obj, 0u)
        Mons.Game.map_set(pos, hero_idx, hero_obj, game)
      else if Mons.Object.is_obj_defeated(curr_mon) then game
      else Mons.cast(pos, hero_idx, hero_idx, Mons.Skill.hit_4, game)

    else if U16.eql(cmd, 'U') then
      Mons.Game.exec_skills(hero_obj, adve_obj, pos, hero_idx, 0, game)
    else if U16.eql(cmd, 'I') then
      Mons.Game.exec_skills(hero_obj, adve_obj, pos, hero_idx, 1, game)
    else if U16.eql(cmd, 'J') then
      Mons.Game.exec_skills(hero_obj, adve_obj, pos, hero_idx, 2, game)
    else if U16.eql(cmd, 'K') then
      Mons.Game.exec_skills(hero_obj, adve_obj, pos, hero_idx, 3, game)
    else if U16.eql(cmd, 'D') then
      Mons.Game.update((obj) Mons.Object.set_pad_r(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'W') then
      Mons.Game.update((obj) Mons.Object.set_pad_u(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'A') then
      Mons.Game.update((obj) Mons.Object.set_pad_l(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'S') then
      Mons.Game.update((obj) Mons.Object.set_pad_d(obj, Bool.true), pos, hero_idx, game)
    else if U16.eql(cmd, 'd') then
      Mons.Game.update((obj) Mons.Object.set_pad_r(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 'w') then
      Mons.Game.update((obj) Mons.Object.set_pad_u(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 'a') then
      Mons.Game.update((obj) Mons.Object.set_pad_l(obj, Bool.false), pos, hero_idx, game)
    else if U16.eql(cmd, 's') then
      Mons.Game.update((obj) Mons.Object.set_pad_d(obj, Bool.false), pos, hero_idx, game)

    else if U16.eql(cmd, 'e') then // Open hero's bag
      if Bool.or(is_battling, end_battle) then game
      else 
        Mons.Game.set_stt(Mons.Screen.inventory(0u), game)

    // --------- End battle
    else if U16.eql(cmd, 'c') then // Action to capture a Mon
      case adve_obj.kin as kind:
      | mon =>
        if Mons.Object.is_obj_defeated(adve_obj) then
          let hero_obj = Mons.Object.add_defeated_mon(adve_obj, hero_obj)
          if kind.boss then
            let hero_obj = Mons.Object.capture_boss(adve_obj, hero_obj)
            Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
          else
            if Mons.Object.is_full_bag(hero_obj) then
              Mons.Game.set_stt(Mons.Screen.capture_mon(0u, Bool.true), game)
            else
              let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
              Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
        else if Mons.Object.is_obj_defeated(curr_mon) then
            if Mons.Kind.is_hero(curr_mon.kin) then
              let hero_obj = Mons.Object.set_dmg(hero_obj, 0u)
              let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
              let game = Mons.Game.move_hero_down(usr, hero_obj, pos, hero_idx, game)
              Mons.Game.set_stt(Mons.Screen.game('.'), game)
            else
              let adve_obj = Mons.Object.set_dmg(adve_obj, 0u) // adve heals all hp
              let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
              let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
              let game = Mons.Game.map_set(pos, adve_idx, adve_obj, game)
              let game = Mons.Game.move_hero_down(usr, hero_obj, pos, hero_idx, game)
              Mons.Game.set_stt(Mons.Screen.game('.'), game)
        else game
      ;
      | construction =>
        let qtd_boss = Nat.to_u32(List.length<>(hero_obj.bos))
        let can_use_portal = U32.eql(U32.add(hero_idx, 1u), qtd_boss)
        if can_use_portal then
          let new_pos = Pos32.add(pos, Pos32.new(0u,0u,1u)) 
          let game    = Mons.Game.move_obj(pos, hero_idx, new_pos, hero_obj, game)  
          Mons.Game.set_user_pos(usr, new_pos, game)
        else game
      ;
      | terrain => Mons.Game.set_stt(Mons.Screen.game('.'), game);

    else if U16.eql(cmd, 'z') then // Free Mon
      case adve_obj.kin as kind:
      | mon =>
        if Mons.Object.is_obj_defeated(adve_obj) then
          let hero_obj = Mons.Object.add_defeated_mon(adve_obj, hero_obj)
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
        else game;
      | const => Mons.Game.set_stt(Mons.Screen.game('.'), game);
      | terrain => Mons.Game.set_stt(Mons.Screen.game('.'), game);

    else game ;

    | inventory => 
      if U16.eql(cmd, 'e') then
        Mons.Game.set_stt(Mons.Screen.game('.'), game)
      
      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.inventory(cmd),
          pos, hero_obj, hero_idx, game);

    | capture => // accessed by pressing "c" after battle
      if U16.eql(cmd, 'c') then
        // if stt.full_bag then // Update the current mon by the new one
          let hero_obj = Mons.Object.delete_from_bag(hero_obj.mon, hero_obj)
          let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
          let hero_obj = Mons.Object.set_mon(2u, hero_obj) // TODO: why 2u? review
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
        // else
        //   let hero_obj = Mons.Object.push_to_bag(adve_obj, hero_obj)
        //   let game = Mons.Game.delete_adve_obj(adve_obj, hero_obj, pos, hero_idx, adve_idx, game)
        //   Mons.Game.set_stt(Mons.Screen.game('.'), game)

      else if U16.eql(cmd, 'z') then // Free Mon
        if Mons.Object.is_obj_defeated(adve_obj) then
          let game = Mons.Game.map_del(pos, adve_idx, game)
          let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
          Mons.Game.set_stt(Mons.Screen.game('.'), game)
        else game

      else // update current Mon using 'w' or 's'
        Mons.Object.change_curr_mon(
          cmd, (cmd: U32) Mons.Screen.capture_mon(cmd, Bool.true),
          pos, hero_obj, hero_idx, game)
    ;
  ;

// TODO: probably similar to "exec turn"
Mons.Game.exec_skills(
  hero_obj: Mons.Object, 
  adve_obj: Mons.Object,
  pos: Pos32,
  hero_idx: U32,
  code_skill: Nat,
  game: Mons.Game)
  : Mons.Game
  let is_battling = Mons.Object.is_battling(adve_obj, hero_obj)
  if is_battling then
    open hero_obj:
    open adve_obj:
    let adve_idx = 1u
    let hero_agi = Mons.Kind.get_agi(hero_obj.kin)
    let adve_agi = Mons.Kind.get_agi(adve_obj.kin)
    let hero_skill = Mons.Game.get_skills_at(code_skill, hero_obj)
    let adve_skill_idx = Mons.Game.adve_turn(hero_obj, adve_obj, game)
    let adve_skill = Mons.Game.get_skills_at(adve_skill_idx, adve_obj)
    // TODO: still need to test
    if Bool.or(U32.ltn(hero_agi, adve_agi), U32.eql(hero_agi, adve_agi)) then // hero attack first
      let game = Mons.cast(pos, hero_idx, adve_idx, hero_skill, game)
      Mons.cast(pos, adve_idx, hero_idx, adve_skill, game)
    else 
      let game = Mons.cast(pos, adve_idx, hero_idx, adve_skill, game)
      Mons.cast(pos, hero_idx, adve_idx, hero_skill, game)
  else game


// 0-U: hit, 1-I: hit, 2-J: heal, 3-K: hit
// Reads the game and returns a code for the skills that the adve will use
Mons.Game.adve_turn(hero_obj: Mons.Object, adve_obj: Mons.Object, game: Mons.Game): Nat
  open game:
  open hero_obj:
  open adve_obj:
  let adve_hp = Mons.Object.remaing_hp(adve_obj)
  let hero_hp = Mons.Object.remaing_hp(hero_obj)
  let qtd_mon_bag = Nat.to_u32(List.length<>(hero_obj.bag))
  let hero_pos = Mons.Game.get_hero_pos(game)
  let pos_x = 
    case hero_pos:
    | 80u;
    | Pos32.get_x(hero_pos.value);

  // hp difference more than 10
  if U32.gtn(U32.sub(hero_hp, adve_hp), 15u) then 2 // heal
  else if Bool.and(U32.gtn(hero_hp, 30u), U32.ltn(hero_hp, 25u)) then 2 // heal

  else if U32.gte(U32.sub(adve_hp, hero_hp), 8u) then 1 // none
  else if Bool.and(U32.gtn(qtd_mon_bag, 1u), U32.gtn(hero_hp, 30u)) then 1 // none
  else if U32.eql(hero_hp, adve_hp) then 3 // none
  else if Bool.and(Bool.not(U32.eql(U32.mod(pos_x, 2u), 0u)), U32.ltn(hero_hp, 15u)) then 3 // n

  else if U32.gtn(U32.sub(adve_hp, hero_hp), 15u) then 0 // heal
  else if Bool.and(U32.gtn(adve_hp, hero_hp), U32.gtn(hero_hp, 30u)) then 0 //hit
  else if U32.gtn(hero_hp, 20u) then 1 // hit
  
  else if Bool.and(U32.eql(U32.mod(pos_x, 2u), 0u), U32.ltn(hero_hp, 15u)) then 1 // hit
  else if U32.ltn(hero_hp, 5u) then 0

  else 0

Mons.Game.get_skills_at(idx: Nat, obj: Mons.Object): Mons.Skill
  open obj:
  let skills = Mons.Kind.get_skills(obj.kin)
  case List.at<>(idx, skills) as skill:
  | none => Mons.Skill.none;
  | some => skill.value;

// Update the current Mon by changing it with the keys 'w' (up) and 's' (down)
Mons.Object.change_curr_mon(
  cmd: Char,
  stt: U32 -> Mons.Screen,
  pos: Pos32,
  hero_obj: Mons.Object,
  hero_idx: U32,
  game: Mons.Game): Mons.Game
  // open game:
  open hero_obj:
  if Bool.or(U16.eql(cmd, 'a'), U16.eql(cmd, 'w')) then
    let hero_obj = Mons.Object.set_mon(U32.sub(hero_obj.mon, 1u), hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(1u), game)
  else if Bool.or(U16.eql(cmd, 'd'), U16.eql(cmd, 's')) then
    let hero_obj =
      let qtd_mon = Nat.to_u32(List.length<>(hero_obj.bag))
      if U32.ltn(hero_obj.mon, U32.sub(qtd_mon, 1u)) then
        Mons.Object.set_mon(U32.add(hero_obj.mon, 1u), hero_obj)
      else Mons.Object.set_mon(hero_obj.mon, hero_obj)
    let game = Mons.Game.map_set(pos, hero_idx, hero_obj, game)
    Mons.Game.set_stt(stt(2u), game)
  else game

Mons.Object.is_full_bag(obj: Mons.Object): Bool
  open obj:
  let len = List.length<>(obj.bag)
  Nat.eql(len, 3)

Mons.test.add_bag(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
  open hero_obj:
  let hero_obj = Mons.Object.set_bag([], hero_obj)
  let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.CRONI, Bool.false, Mons.Type.earth, 2u))
  let mon1_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.LAMURIA, Bool.false, Mons.Type.fire, 2u))
  let mon2_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.ELLIOT, Bool.false, Mons.Type.water, 2u))
  let hero_obj = Mons.Object.push_to_bag(mon0_bag, hero_obj)
  let hero_obj = Mons.Object.push_to_bag(mon1_bag, hero_obj)
  let hero_obj = Mons.Object.push_to_bag(mon2_bag, hero_obj)
  Mons.Game.map_set(pos, hero_idx, hero_obj, game)

Mons.test.add_boss(hero_obj: Mons.Object, pos: Pos32, hero_idx: U32, game: Mons.Game): Mons.Game
  open hero_obj:
  let hero_obj = Mons.Object.set_bos([], hero_obj)
  let mon0_bag = Mons.Object.new_of_kind(Mons.Kind.Mons(Mons.Kind.mons.BUFF, Bool.true, Mons.Type.earth, 0u))
  let hero_obj = Mons.Object.capture_boss(mon0_bag, hero_obj)
  Mons.Game.map_set(pos, hero_idx, hero_obj, game)

// Converts a keyboard key to a direction:
// A = [-1,  0,  0]
// D = [ 1,  0,  0]
// W = [ 0, -1,  0]
// S = [ 0,  1,  0]
// * = [ 0,  0,  0]a
Mons.key_to_dir(key_code: U16): Maybe(Mons.Dir)
  if U16.eql(key_code, 'A') then
    Maybe.some<>(Mons.Dir.left)
  else if U16.eql(key_code, 'D') then
    Maybe.some<>(Mons.Dir.right)
  else if U16.eql(key_code, 'W') then
    Maybe.some<>(Mons.Dir.up)
  else if U16.eql(key_code, 'S') then
    Maybe.some<>(Mons.Dir.down)
  else
    Maybe.none<>

//Mons.game_sprites.push_obj(t_x: U32, t_y: U32, obj: Mons.Object, sprs: List(Mons.Sprite)): List(Mons.Sprite)
  //for img in Mons.Object.get_images(t_x, t_y, obj) with sprs:
    //let ani = Mons.Object.get_ani(obj)
    //let dir = Mons.Object.get_dir(obj)
    //get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
    //let s_z = t_z
    //let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
    //List.cons<>(spr, sprs)

// Converts the game state to a list of sprites to be rendered
// TODO: for some reason, using a `case obj` here causes the
// function not to type check anymore. Investigate why.
Mons.game_sprites(game: Mons.Game): List(Mons.Sprite)
  open game:
  let sprs = []
  case Mons.Game.get_hero_pos(game) as cam_pos:
  | [];
  | let c_x = Pos32.get_x(cam_pos.value)
    let c_y = Pos32.get_y(cam_pos.value)
    let c_z = Pos32.get_z(cam_pos.value)
    for x : U32 = 0u .. 17u with sprs:
      for y : U32 = 0u .. 13u with sprs:
        let t_x = U32.add(U32.sub(c_x, 8u), x)
        let t_y = U32.add(U32.sub(c_y, 6u), y)
        let t_z = c_z
        let pos = Pos32.new(t_x, t_y, t_z)
        let got = Map.get<>(U32.to_bits(pos), game.map)
        let objs
          = case got:
          | [Mons.Object.void];
          | List.reverse<>(got.value);
        for obj in objs with sprs:
          open obj:
          open Mons.Kind.attr(obj.kin) as hero_attr:
          let sprites = hero_attr.spr(t_x, t_y, obj.ani, obj.dir)
          for img in sprites with sprs:
            let ani = Mons.Object.get_ani(obj)
            let dir = Mons.Object.get_dir(obj)
            get s_x s_y = Mons.draw.global_xy(t_x, t_y, obj)
            let s_z = t_z
            let spr = Mons.Sprite.new(s_x, s_y, s_z, img)
            List.cons<>(spr, sprs);

// Build sprites around the hero
Mons.Map.build_sprites(game: Mons.Game, scr: Image3D, hero_pos: Pos32, hero_obj: Mons.Object): Image3D
  let sprs = Mons.game_sprites(game)
  for spr in sprs with scr:
  // For each pixel of the sprite...
  open spr:
  let len = Image3D.get_length(spr.img)
  for i : U32 = 0u .. len with scr:
    let s_w = Pos32.get_x(Mons.scr_mid)
    let s_h = Pos32.get_y(Mons.scr_mid)
    // The origin global position (centered on hero)
    let h_x = Pos32.get_x(hero_pos)
    let h_y = Pos32.get_y(hero_pos)
    //let o_x = U32.mul(Pos32.get_x(hero_pos.value), 16u)
    //let o_y = U32.mul(Pos32.get_y(hero_pos.value), 16u)
    get o_x o_y = Mons.draw.global_xy(h_x, h_y, hero_obj)
    // Gets the spr global position
    let s_x = spr.x
    let s_y = spr.y
    let s_z = spr.z
    // Gets the pixel global position (its cpos on img is x=128, y=128)
    let xyz = Image3D.get_pos(i, spr.img)
    let v_x = U32.sub(U32.add(Pos32.get_x(xyz),s_x),Pos32.get_x(Mons.vox_mid))
    let v_y = U32.sub(U32.add(Pos32.get_y(xyz),s_y),Pos32.get_y(Mons.vox_mid))
    let v_z = Pos32.get_z(xyz)
    // Temporary: if pixel is out of screen, make it invisible
    let ok0 = U32.lte(U32.sub(o_x, s_w), v_x) // o_x - s_w <= v_x
    let ok1 = U32.ltn(v_x, U32.add(o_x, s_w)) // v_x < o_x + s_w
    let ok2 = U32.lte(U32.sub(o_y, s_h), v_y) // o_y - s_h <= v_y
    let ok3 = U32.ltn(v_y, U32.add(o_y, s_h)) // v_y < o_y + s_h
    //let ok  = List.and([ok0, ok1, ok2, ok3])
    let ok  = Bool.and(ok0, Bool.and(ok1, Bool.and(ok2, ok3)))
    // Computes the pixel position on the final canvas
    let c_x = U32.sub(U32.add(v_x, Pos32.get_x(Mons.scr_mid)), o_x)
    let c_y = U32.sub(U32.add(v_y, Pos32.get_y(Mons.scr_mid)), o_y)
    let c_z = Bool.if<>(ok, v_z, 0u)
    // Pushes the pixel to the scr
    let pos = Pos32.new(c_x, c_y, c_z) // final pixel pos
    let col = Image3D.get_col(i, spr.img) // final pixel col
    Image3D.push(pos, col, scr) // pushes to scr

// For each tick, updates an object
Mons.Object.tick(obj: Mons.Object): Mons.Object
  open obj:
  // Configs the walk animation
  let obj = Mons.Object.set_ani(obj)
    | if U32.gtn(obj.ani, 0u)
      then U32.sub(obj.ani, 2u)
      else obj.ani;
  // Sets the direction based on pad
  let obj = Mons.Object.set_dir(obj)
    | if Mons.Object.is_free_to_move(obj) then
        open obj.pad:
        if obj.pad.u then
          Mons.Dir.up
        else if obj.pad.l then
          Mons.Dir.left
        else if obj.pad.d then
          Mons.Dir.down
        else if obj.pad.r then
          Mons.Dir.right
        else
          obj.dir
      else
        obj.dir;
  obj

Mons.Game.dim(game: Mons.Game): U32
  let pos = Mons.Game.get_hero_pos(game)
  case pos:
  | 0u;
  | Pos32.get_z(pos.value);

// Moves an object towards a given direction
Mons.Game.tick_user(user: Word(160), pos: Pos32, game: Mons.Game): Mons.Game
  open game:
  let map = game.map
  let obj_idx = Mons.Map.get_hero(pos, map)
  let obj = Pair.fst<,>(obj_idx)
  let idx = Pair.snd<,>(obj_idx)
  let obj = Mons.Object.tick(obj)
  open obj:
  let old_pos = pos
  let new_pos = Mons.Dir.move(obj.dir, pos)
  let trg = Mons.Map.get_top(new_pos, map)
  open trg:
  let is_walking = Mons.Object.is_walking(obj)
  let is_movfree = Mons.Object.is_free_to_move(obj)
  let is_blocked = Mons.Kind.get_blocks(trg.kin)
  if Bool.and(is_walking, Bool.and(is_movfree, Bool.not(is_blocked))) then
    let obj = Mons.Object.set_ani(obj, 16u)
    let game = Mons.Game.move_obj(old_pos, idx, new_pos, obj, game)
    let game = Mons.Game.set_user_pos(user, new_pos, game)
    game
  else
    Mons.Game.map_set(pos, idx, obj, game)

// For each tick, updates the game state
// TODO: tick objects other than hero
Mons.Game.tick(game: Mons.Game): Mons.Game
  open game:
  for user_pos in Map.to_list<>(game.pos) with game:
    get key pos = user_pos
    let user = Word.from_bits(160, key)
    Mons.Game.tick_user(user, pos, game)

// All valid inputs and its code
Mons.Input.list: List(Pair(Char, Bits))
  let b0 = Bits.0
  let b1 = Bits.1
  let bn = Bits.nil
  [
    {'D', b0(b0(b0(b0(b0(b0(b0(b0(bn))))))))},
    {'W', b0(b0(b0(b0(b0(b0(b0(b1(bn))))))))},
    {'A', b0(b0(b0(b0(b0(b0(b1(b0(bn))))))))},
    {'S', b0(b0(b0(b0(b0(b0(b1(b1(bn))))))))},
    {'U', b0(b0(b0(b0(b0(b1(b0(b0(bn))))))))},
    {'I', b0(b0(b0(b0(b0(b1(b0(b1(bn))))))))},
    {'J', b0(b0(b0(b0(b0(b1(b1(b0(bn))))))))},
    {'K', b0(b0(b0(b0(b0(b1(b1(b1(bn))))))))},
    {'d', b0(b0(b0(b0(b1(b0(b0(b0(bn))))))))},
    {'w', b0(b0(b0(b0(b1(b0(b0(b1(bn))))))))},
    {'a', b0(b0(b0(b0(b1(b0(b1(b0(bn))))))))},
    {'s', b0(b0(b0(b0(b1(b0(b1(b1(bn))))))))},
    {'u', b0(b0(b0(b0(b1(b1(b0(b0(bn))))))))},
    {'i', b0(b0(b0(b0(b1(b1(b0(b1(bn))))))))},
    {'j', b0(b0(b0(b0(b1(b1(b1(b0(bn))))))))},
    {'k', b0(b0(b0(b0(b1(b1(b1(b1(bn))))))))},
    {'P', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'O', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))}, //TODO remove! for now its just a hack to test dimensions
    {'e', b0(b0(b0(b1(b0(b0(b0(b0(bn))))))))},
    {'E', b0(b0(b0(b1(b0(b0(b0(b1(bn))))))))},
    {'c', b0(b0(b0(b1(b0(b0(b1(b1(bn))))))))},
    {'C', b0(b0(b0(b1(b0(b1(b1(b1(bn))))))))},
    {'z', b0(b0(b0(b1(b1(b1(b1(b1(bn))))))))},
    {'Z', b0(b0(b1(b0(b0(b0(b0(b0(bn))))))))},
    {'T', b0(b0(b1(b0(b0(b0(b0(b1(bn))))))))} //TODO remove! just using to test heal
  ]

// Maps from chars to their codes
Mons.Input.char_to_code_map: Map(Bits)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(U16.to_bits(char), code, map)

// Maps from codes to their chars
Mons.Input.code_to_char_map: Map(Char)
  let map = Map.new<>
  for char_code in Mons.Input.list with map:
    get char code = char_code
    Map.set<>(code, char, map)

// Serializes an input to its code
Mons.Input.serialize(char: Char): Maybe(Word(256))
  case Map.get<>(U16.to_bits(char), Mons.Input.char_to_code_map) as code:
  | Maybe.none<>;
  | Maybe.some<>(Word.from_bits(256, code.value));

// Deserializes a code to its input
Mons.Input.deserialize(code: Word(256)): Maybe(Char)
  Map.get<>(Bits.slice(8, Word.to_bits<256>(code)), Mons.Input.code_to_char_map)

// Generates an input char from the event down/code info
Mons.Input.char(down: Bool, code: Char): Char
  if down
  then Char.to_upper(code)
  else Char.to_lower(code)

// Online mode room name
Mons.App.room: Word(48)
  Word.from_bits(48, String.to_bits("MON"))

// Startup
Mons.start(online: Bool): App(Mons.Game)
  let screen = Image3D.alloc_capacity(524288u)
  App.new<>
  // Initial state
  | let game_usr = Word.zero(160)
    let game_pos = Map.new<>
    let game_map = Mons.Map.build(Mons.map_source)
    Mons.Game.new(game_usr, game_pos, game_map, Mons.Screen.game('.'));
  // Render function
  | (game) App.Render.vox(Mons.draw(game, screen));
  // Event handlers
  | (event, game)
    if online then // online mode
      case event:
      | init => [
        App.Action.print<>("Starting app."),
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        App.Action.state<>(Mons.Game.set_usr(event.addr, game)),
        App.Action.watch<>(Mons.App.room),
        // Sends a J to init our char. TODO: better initialization.
        let chr = Mons.Input.char(Bool.true, '.')
        case Mons.Input.serialize(chr) as data:
        | App.Action.print<>(""); // unreachable
        | App.Action.post<>(Mons.App.room, data.value);
      ];
      | tick => [
        App.Action.state<>(Mons.Game.tick(game)),
      ];
      | xkey => // send input to server
        let chr = Mons.Input.char(event.down, event.code)
        case Mons.Input.serialize(chr) as data:
        | [];
        | [App.Action.post<>(Mons.App.room, data.value)];;
      | post => // applies input to this post's hero
        // use skp = Debug.log<>("Got post.")
        // use skp = Debug.log<>(Bits.to_string(Word.to_bits<256>(event.data)))
        case Mons.Input.deserialize(event.data) as input:
        | [];
        | [
          // use skp = Debug.log<>(String.concat("Got input:", String.pure(input.value)))
          // use skp = Debug.log<>(String.concat("From user:", Bits.to_string(Word.to_bits<160>(event.addr))))
          open game:
          App.Action.state<>(Mons.Game.cmd(input.value, event.addr, game))
        ];;
    else // offline mode
      case event:
      | init => [
        App.Action.resize<>(Mons.scr_w, Mons.scr_h),
        let game = Mons.Game.set_usr(event.addr, game)
        let game = Mons.Game.cmd('j', event.addr, game) // inits hero
        App.Action.state<>(game),
      ];
      | tick => [App.Action.state<>(Mons.Game.tick(game))];
      | xkey => [
        open game:
        let chr = Mons.Input.char(event.down, event.code)
        App.Action.state<>(Mons.Game.cmd(chr, game.usr, game))
      ];
      | post => [];;

// Startup (online mode)
Mons.on: App(Mons.Game)
  Mons.start(Bool.true)

// Startup (offline mode)
Mons.off: App(Mons.Game)
  Mons.start(Bool.false)

// Startup (default mode = offline)
Mons: App(Mons.Game)
  Mons.off

//Mons: _
  //let map = Map.new<>
  //let map = Map.set<>(U16.to_bits('i'), 5, map)
  //Map.get<>(U16.to_bits('i'), map)
  //let map = Map.set<>(U16.to_bits('i'), 7)
  //U16.to_bits('i')
//0000000001100001
//0000000001101001
  //Map.get<>(U16.to_bits('h'), Mons.Input.char_to_code_map)
