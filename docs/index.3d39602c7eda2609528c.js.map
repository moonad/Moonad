{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/inferno/dist/index.esm.js","webpack:///./node_modules/inferno/index.esm.js","webpack:///./node_modules/inferno-hyperscript/dist/index.esm.js","webpack:///./src/front/front.js","webpack:///./node_modules/process/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/readable-stream/errors-browser.js","webpack:///./node_modules/readable-stream/lib/_stream_duplex.js","webpack:///./node_modules/formality-lang/FormalitySynt.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/formality-lang/Formality.js","webpack:///./node_modules/formality-lang/FormalityLang.js","webpack:///./node_modules/formality-lang/FormalityComp.js","webpack:///./node_modules/nano-ethereum-signer/main.min.js","webpack:///./node_modules/readable-stream/lib/internal/streams/end-of-stream.js","webpack:///./node_modules/formality-lang/FormalityInet.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/safe-buffer/index.js","webpack:///./node_modules/readable-stream/lib/_stream_readable.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack:///./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack:///./node_modules/readable-stream/lib/internal/streams/state.js","webpack:///./node_modules/readable-stream/lib/_stream_writable.js","webpack:///./node_modules/string_decoder/lib/string_decoder.js","webpack:///./node_modules/readable-stream/lib/_stream_transform.js","webpack:///./src/front/index.js","webpack:///./src/front/IBMPlexMono-Light.ttf","webpack:///./src/front/moonad_logo.png","webpack:///./node_modules/formality-lang/FormalityCore.js","webpack:///./node_modules/formality-lang/FormalityToJS.js","webpack:///./node_modules/formality-lang/FormalityOptx.js","webpack:///./src/back/client.js","webpack:///./node_modules/xhr-request-promise/index.js","webpack:///./node_modules/xhr-request/index.js","webpack:///./node_modules/query-string/index.js","webpack:///./node_modules/strict-uri-encode/index.js","webpack:///./node_modules/decode-uri-component/index.js","webpack:///./node_modules/url-set-query/index.js","webpack:///./node_modules/xhr-request/lib/ensure-header.js","webpack:///./node_modules/xhr-request/lib/request-browser.js","webpack:///./node_modules/xhr/index.js","webpack:///./node_modules/global/window.js","webpack:///./node_modules/is-function/index.js","webpack:///./node_modules/parse-headers/parse-headers.js","webpack:///./node_modules/xtend/immutable.js","webpack:///./node_modules/xhr-request/lib/normalize-response.js","webpack:///./node_modules/simple-peer/index.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/simple-peer/node_modules/debug/src/browser.js","webpack:///./node_modules/simple-peer/node_modules/debug/src/common.js","webpack:///./node_modules/simple-peer/node_modules/ms/index.js","webpack:///./node_modules/get-browser-rtc/index.js","webpack:///./node_modules/randombytes/browser.js","webpack:///./node_modules/readable-stream/readable-browser.js","webpack:///util (ignored)","webpack:///./node_modules/readable-stream/lib/internal/streams/buffer_list.js","webpack:///util (ignored)?3c12","webpack:///./node_modules/util-deprecate/browser.js","webpack:///./node_modules/readable-stream/lib/internal/streams/async_iterator.js","webpack:///./node_modules/readable-stream/lib/internal/streams/from-browser.js","webpack:///./node_modules/readable-stream/lib/_stream_passthrough.js","webpack:///./node_modules/readable-stream/lib/internal/streams/pipeline.js","webpack:///./node_modules/queue-microtask/index.js","webpack:///./src/back/lib.js","webpack:///./node_modules/isomorphic-ws/browser.js","webpack:///./src/front/components/Moonad.js","webpack:///./src/front/components/TopBar.js","webpack:///./src/front/components/User_info.js","webpack:///./src/front/components/Write.js","webpack:///./src/front/components/Posts.js","webpack:///./src/front/components/Post.js","webpack:///./src/front/components/Code.js","webpack:///./src/front/components/Term.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,SAAS;AACpB,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,qBAAqB;AACrB,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB,mBAAmB;AACnB,sBAAsB;AACtB;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEwf;;;ACjnEpd;;AAEpC,IAAI,KAAqC,EAAE,EAE1C;;;;;;;;ACJD;AAAA;AAAA;AAA+G;;AAE/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WAAW,qDAAqD;AAChE,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uEAAuB;AAC3C;AACA,mBAAmB,8DAAc;AACjC;AACA;AACA;AACA;AACA,eAAe,2DAAW;AAC1B;AACA;AACA;AACA;AACA,WAAW,oEAAoB;AAC/B;;AAEa;;;;;;;AC3Hb,WAAW,mBAAO,CAAC,EAAgB;AACnC,sBAAsB,mBAAO,CAAC,EAAqB,GAAG,2BAA2B;AACjF,eAAe,mBAAO,CAAC,EAAsB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA,0B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,YAAY,IAAI,IAAI,MAAM,IAAI;AACxE;;AAEA,2CAA2C;AAC3C;AACA;AACA,8CAA8C,KAAK;AACnD;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9KA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACnBa;;AAEb,+CAA+C,0DAA0D,2CAA2C,iCAAiC;;AAErL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA,eAAe,mBAAO,CAAC,EAAoB;;AAE3C,eAAe,mBAAO,CAAC,EAAoB;;AAE3C,mBAAO,CAAC,CAAU;;AAElB;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA,CAAC,E;;;;;;;AC1ID;;AAEA;AACA;;AAEA,4CAA4C,gBAAgB;AAC5D,4CAA4C,gBAAgB;AAC5D,4CAA4C,WAAW;AACvD,4CAA4C,oCAAoC;AAChF,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,gBAAgB;AAC5D,4CAA4C,qBAAqB;AACjE,4CAA4C,0BAA0B;AACtE,4CAA4C,gBAAgB;AAC5D,4CAA4C,gBAAgB;AAC5D,4CAA4C,gBAAgB;;AAE5D;AACA;;AAEA,6BAA6B,kBAAkB;AAC/C,6BAA6B,sCAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,2BAA2B;AACnE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA,iCAAiC,oCAAoC;AACrE;AACA,WAAW;AACX,2BAA2B,sBAAsB;AACjD;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,kBAAkB;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAgD,EAAE;AACzF,uCAAuC,4BAA4B,EAAE;AACrE,uCAAuC,4BAA4B,EAAE;AACrE;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C,qCAAqC;AACrC,oBAAoB,UAAU;AAC9B,OAAO;AACP;AACA;AACA,4CAA4C;AAC5C,gBAAgB,mBAAO,CAAC,EAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;AACrD,+CAA+C,UAAU;AACzD,6CAA6C;AAC7C,4BAA4B,UAAU;AACtC,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,sBAAsB;AACtB;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/jCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,EAAW;AAChC,cAAc,mBAAO,CAAC,EAAS;AAC/B,cAAc,mBAAO,CAAC,EAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC5vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1BA;AACA,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,CAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC,QAAQ,mBAAO,CAAC,EAAoB;AACpC;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,CAAoB;;AAEhC;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,sBAAsB;AACtB;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,KAAK;AACL;;AAEA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,KAAK;AACL;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD,KAAK;AACL;;AAEA;AACA;AACA,2DAA2D,+BAA+B;AAC1F;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,KAAK;AACL,YAAY,KAAK;AACjB;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,0CAA0C,OAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,QAAQ,QAAQ,QAAQ;AACxB,QAAQ,QAAQ,UAAU;AAC1B,QAAQ,QAAQ,aAAa,UAAU,MAAM;AAC7C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,QAAQ,QAAQ,QAAQ;AACxB,QAAQ,QAAQ,UAAU;AAC1B,QAAQ,QAAQ,aAAa,UAAU,MAAM;AAC7C;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,YAAY,UAAU,kBAAkB;AACxC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT,YAAY,SAAS,UAAU,YAAY,MAAM;AACjD,YAAY,SAAS,UAAU,YAAY,MAAM;AACjD,YAAY,SAAS;AACrB;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B,gBAAgB,YAAY;AAC5B,gBAAgB,YAAY;AAC5B,gBAAgB,YAAY;AAC5B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,GAAG;AACH;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACltDA,UAAU,mBAAO,CAAC,CAAoB;AACtC,UAAU,mBAAO,CAAC,EAAoB;;AAEtC,kCAAkC,gBAAgB;AAClD,kCAAkC,gBAAgB;AAClD,kCAAkC,WAAW;AAC7C,kCAAkC,qBAAqB;AACvD,kCAAkC,qBAAqB;AACvD,kCAAkC,0BAA0B;AAC5D,kCAAkC,qBAAqB;AACvD,kCAAkC,qBAAqB;AACvD,kCAAkC,gBAAgB;AAClD,kCAAkC,gBAAgB;AAClD,kCAAkC,gBAAgB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,eAAe,UAAU,EAAE;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClRA,0DAAY,eAAe,QAAQ,kBAAkB,mBAAmB,qBAAqB,EAAE,UAAU,wFAAwF,yDAAyD,eAAe,kGAAkG,YAAY,WAAW,KAAK,WAAW,4BAA4B,0CAA0C;AACxd,cAAc,gBAAgB,0BAA0B,iBAAiB,SAAS,uBAAuB,oCAAoC,EAAE,iCAAiC,eAAe,kBAAkB,cAAc,wEAAwE,kDAAkD,QAAQ,SAAS;AAC1W,iBAAiB,MAAM,SAAS,eAAe,YAAY,aAAa,KAAK,WAAW,gBAAgB,EAAE,OAAO,gBAAgB,OAAO,OAAO,uBAAuB,oCAAoC,GAAG,2BAA2B,yBAAyB,YAAY,YAAY,wBAAwB,0DAA0D;AAC3W,sCAAsC,2BAA2B,qBAAqB,yBAAyB,oBAAoB,YAAY,yBAAyB,mBAAmB,IAAI,cAAc,aAAa,EAAE,eAAe,WAAW,kBAAkB;AACxQ,qBAAqB,qBAAqB,kDAAkD,aAAa,mDAAmD,IAAI,mBAAmB,kBAAkB,8DAA8D,SAAS,sBAAsB,SAAS,sBAAsB,SAAS,sBAAsB,SAAS,sBAAsB,SAAS,sBAAsB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,QAAQ;AAC/e,OAAO,SAAS,QAAQ,0CAA0C,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,uBAAuB,SAAS,QAAQ,cAAc,UAAU,SAAS,YAAY,YAAY,cAAc,UAAU,cAAc,UAAU,gCAAgC,6BAA6B,aAAa,UAAU;AAChf,IAAI,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa;AAC7e,MAAM,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa;AAC/e,IAAI,UAAU,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,eAAe,WAAW,aAAa,cAAc,aAAa,cAAc,aAAa;AAC/e,MAAM,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,eAAe,WAAW,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,aAAa,cAAc,aAAa;AAC5e,EAAE,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,cAAc,UAAU,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa;AACxe,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,gCAAgC,6BAA6B,aAAa,UAAU,UAAU,cAAc,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc;AAC9e,KAAK,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa;AACjf,IAAI,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B;AAC7e,SAAS,UAAU,aAAa,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS;AAClf,IAAI,aAAa,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa,UAAU,aAAa,cAAc;AACze,cAAc,aAAa,cAAc,cAAc,eAAe,aAAa,cAAc,cAAc,eAAe,aAAa,aAAa,aAAa,aAAa,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,cAAc,cAAc,eAAe,aAAa,aAAa,cAAc;AAC3e,EAAE,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa,UAAU,aAAa,cAAc,aAAa,cAAc,aAAa,aAAa,cAAc,cAAc,aAAa,cAAc,cAAc,eAAe,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa,UAAU,aAAa,aAAa,aAAa,aAAa;AAC1e,EAAE,cAAc,cAAc,eAAe,2BAA2B,4BAA4B,YAAY,SAAS,SAAS,aAAa,SAAS,aAAa,cAAc,aAAa,cAAc,2BAA2B,4BAA4B,YAAY,SAAS,UAAU,aAAa,UAAU,2BAA2B,4BAA4B,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ;AACjf,EAAE,QAAQ,iBAAiB,4BAA4B,SAAS,gBAAgB,0CAA0C,kBAAkB,oBAAoB,SAAS,YAAY,cAAc,cAAc,aAAa,+BAA+B,6BAA6B,kBAAkB,QAAQ,2BAA2B,IAAI,KAAK,yBAAyB,MAAM,uDAAuD,SAAS,kBAAkB,YAAY,0BAA0B;AAC/e,EAAE,QAAQ,0BAA0B,KAAK,mBAAmB,kBAAkB,YAAY,IAAI,KAAK,0BAA0B,yBAAyB,mCAAmC,KAAK,mEAAmE,WAAW,MAAM,4BAA4B,aAAa,gBAAgB,YAAY,mBAAmB,kBAAkB,uCAAuC,kBAAkB,aAAa;AAClc,cAAc,wHAAwH,SAAS,KAAwB,KAAK,SAAM,CAAC,OAAO,QAAQ,iBAAiB,qGAAqG,+BAA+B,oCAAoC,yCAAyC,KAAK,kBAAkB,0BAA0B;AACrd,QAAQ,gBAAgB,mCAAmC,uBAAuB,SAAS,gCAAgC,6BAA6B,qBAAqB,0MAA0M,+BAA+B,6BAA6B,8BAA8B;AACjd,EAAE,KAAK,kCAAkC,0BAA0B,YAAY,cAAc,gBAAgB,QAAQ,iCAAiC,KAAK,MAAM,gCAAgC,yBAAyB,8BAA8B,MAAM,mBAAmB,2BAA2B,WAAW,iHAAiH,WAAW,6BAA6B;AAChd,0BAA0B,YAAY,cAAc,gBAAgB,UAAU,aAAa,QAAQ,KAAK,MAAM,iBAAiB,yBAAyB,8BAA8B,MAAM,mBAAmB,+EAA+E,UAAU,2BAA2B,uBAAuB,YAAY,cAAc,qBAAqB,qBAAqB,WAAW,gBAAgB,6BAA6B,kBAAkB,WAAW;AACnf,2BAA2B,KAAK,cAAc,0BAA0B,yBAAyB,KAAK,yCAAyC,eAAe,kBAAkB,0BAA0B,2CAA2C,aAAa;AAClQ,oYAAoY,mCAAmC,QAAQ,SAAS,sBAAsB,SAAS,kBAAkB,cAAc,KAAK;AAC5f,6CAA6C,oBAAoB,iDAAiD,KAAK,mBAAmB,gCAAgC,eAAe,SAAS,sBAAsB,SAAS,2BAA2B,OAAO,OAAO,KAAK,eAAe,UAAU,OAAO,+DAA+D,wBAAwB,eAAe,SAAS,sBAAsB,SAAS,yCAAyC;AACte,GAAG,qBAAqB,6BAA6B,gCAAgC,mBAAmB,gDAAgD,qCAAqC,SAAS,eAAe,WAAW,eAAe,MAAM,QAAQ,OAAO,6BAA6B,KAAK,IAAI,WAAW,KAAK,QAAQ,MAAM,WAAW,QAAQ,OAAO,iCAAiC,UAAU,sCAAsC,wBAAwB,aAAa,QAAQ;AAChe,IAAI,qBAAqB,oBAAoB,oBAAoB,YAAY,yBAAyB,0DAA0D,kCAAkC,8BAA8B,yBAAyB,0BAA0B,0BAA0B,sBAAsB,aAAa,0BAA0B,qEAAqE,wBAAwB,MAAM,gBAAgB,MAAM,cAAc;AACjf,oBAAoB,gBAAgB,cAAc,WAAW,2DAA2D,KAAK,kBAAkB,gDAAgD,qBAAqB,6CAA6C,sBAAsB,WAAW,qBAAqB,aAAa,4BAA4B,wBAAwB,MAAM,kBAAkB,OAAO,SAAS;AACha,mBAAmB,0BAA0B,YAAY,MAAM,gBAAgB,MAAM,cAAc,2DAA2D,cAAc,wDAAwD,kBAAkB,gBAAgB,gBAAgB,WAAW,2DAA2D,KAAK,kBAAkB,gDAAgD,oCAAoC,WAAW,qBAAqB;AACve,GAAG,qBAAqB,iBAAiB,4BAA4B,0BAA0B,gBAAgB,iBAAiB,6BAA6B,2BAA2B,iDAAiD,2BAA2B,oBAAoB,UAAU,0BAA0B,kBAAkB,gCAAgC,qBAAqB,2BAA2B,6BAA6B,WAAW,WAAW,8BAA8B;AAC/e,GAAG,QAAQ,QAAQ,cAAc,KAAK,kBAAkB,+BAA+B,WAAW,+BAA+B,UAAU,oBAAoB,KAAK,0BAA0B,QAAQ,IAAI,gBAAgB,eAAe,iBAAiB,0BAA0B,6BAA6B,uEAAuE,qBAAqB,iDAAiD,cAAc,0BAA0B;AACte,gBAAgB,IAAI,oBAAoB,oBAAoB,KAAK,kBAAkB,wBAAwB,MAAM,6CAA6C,iBAAiB,2BAA2B,2BAA2B,2BAA2B,0BAA0B,2BAA2B,uBAAuB,cAAc,0BAA0B,eAAe,mFAAmF,SAAS,WAAW,SAAS,YAAY;AAC/f,2BAA2B,aAAa,QAAQ,mCAAmC,sEAAsE,sCAAsC,aAAa,2BAA2B,uBAAuB,cAAc,0BAA0B,uDAAuD,aAAa,8DAA8D,aAAa,2BAA2B;AAChd,iBAAiB,+BAA+B,MAAM,oBAAoB,QAAQ,QAAQ,WAAW,KAAK,wBAAwB,eAAe,cAAc,yBAAyB,uBAAuB,KAAK,gBAAgB,uDAAuD,yBAAyB,UAAU,UAAU,cAAc,oDAAoD,SAAS,iBAAiB,6BAA6B,2CAA2C;AAC5e,+CAA+C,wBAAwB,cAAc,kBAAkB,aAAa,oBAAoB,YAAY,WAAW,aAAa,sBAAsB,6BAA6B,QAAQ,KAAK,KAAK,qDAAqD,2BAA2B,gBAAgB,QAAQ,uCAAuC,cAAc,SAAS,MAAM,yBAAyB,OAAO,gBAAgB,+BAA+B;AAC5e,mBAAmB,uBAAuB,MAAM,wBAAwB,uBAAuB,uBAAuB,cAAc,cAAc,mBAAmB,OAAO,SAAS,uEAAuE,UAAU,sFAAsF,UAAU,uCAAuC,kBAAkB,yBAAyB,yBAAyB,YAAY,gCAAgC;AAC7f,CAAC,2CAA2C,eAAe,0BAA0B,8BAA8B,0BAA0B,8BAA8B,2BAA2B,iBAAiB,sBAAsB,uCAAuC,SAAS,WAAW,4DAA4D,2BAA2B,eAAe,yCAAyC,KAAK,4BAA4B,UAAU,2BAA2B;AAC7f,KAAK,UAAU,uBAAuB,2BAA2B,WAAW,6CAA6C,eAAe,mBAAmB,gCAAgC,OAAO,EAAE,gBAAgB,qBAAqB,WAAW,kBAAkB,MAAM,EAAE,8BAA8B,OAAO,OAAO,IAAI,QAAQ,qBAAqB,WAAW,kBAAkB,MAAM,EAAE,8BAA8B,OAAO,OAAO,0DAA0D,OAAO;AAC7e,aAAa,2BAA2B,WAAW,UAAU,uBAAuB,2BAA2B,0CAA0C,mBAAmB,EAAE,gBAAgB,qBAAqB,WAAW,kBAAkB,MAAM,sBAAsB,IAAI,QAAQ,qBAAqB,WAAW,kBAAkB,MAAM,sBAAsB,4CAA4C,iBAAiB,iBAAiB,UAAU,2BAA2B,0BAA0B;AACnf,WAAW,0BAA0B,yBAAyB,0BAA0B,0BAA0B,oBAAoB,yBAAyB,uCAAuC,0BAA0B,UAAU,2BAA2B,0BAA0B,SAAS,kGAAkG,0BAA0B,4BAA4B,gCAAgC;AAChe,aAAa,0BAA0B,2BAA2B,iCAAiC,iCAAiC,4BAA4B,KAAK,KAAK,6BAA6B,UAAU,oBAAoB,OAAO,UAAU,kBAAkB,iBAAiB,0BAA0B,qDAAqD,8CAA8C,yBAAyB,0BAA0B;AACzc,0BAA0B,2BAA2B,WAAW,aAAa,0BAA0B,iDAAiD,6BAA6B,0BAA0B,kDAAkD,2BAA2B,2BAA2B,iDAAiD,6BAA6B,0BAA0B,kDAAkD,2BAA2B;AAC5e,YAAY,iDAAiD,oBAAoB,2BAA2B,yBAAyB,iDAAiD,kBAAkB,0BAA0B,0BAA0B,kDAAkD,kBAAkB,4BAA4B,0BAA0B,kDAAkD,kBAAkB,0BAA0B,0BAA0B;AAC9e,sCAAsC,kBAAkB,yBAAyB,OAAO,iCAAiC,0BAA0B,kBAAkB,gCAAgC,UAAU,2BAA2B,GAAG,sBAAsB,aAAa,eAAe,YAAY,gBAAgB,2BAA2B,kDAAkD,UAAU,eAAe,cAAc,OAAO,wBAAwB,kBAAkB;AAChe,EAAE,OAAO,gCAAgC,mCAAmC,IAAI,kBAAkB,WAAW,mCAAmC,KAAK,SAAS,0BAA0B,SAAS,WAAW,mDAAmD,QAAQ,YAAY,qDAAqD,2BAA2B,gBAAgB,kBAAkB,YAAY,gBAAgB,WAAW,KAAK,eAAe,SAAS,kBAAkB,sBAAsB;AACjf,8DAA8D,UAAU,gBAAgB,oBAAoB,YAAY,eAAe,2BAA2B,2CAA2C,4CAA4C,6BAA6B,iDAAiD,2DAA2D,2BAA2B,4DAA4D,0BAA0B;AACnf,kCAAkC,8BAA8B,aAAa,WAAW,8BAA8B,mBAAmB,4BAA4B,aAAa,SAAS,8BAA8B,UAAU,8BAA8B,aAAa,WAAW,sBAAsB,mBAAmB,4BAA4B,aAAa,SAAS,sBAAsB,UAAU,4BAA4B,aAAa,wBAAwB,2BAA2B;AAChf,IAAI,6BAA6B,0BAA0B,kBAAkB,WAAW,0DAA0D,2BAA2B,mBAAmB,YAAY,UAAU,qBAAqB,8CAA8C,6BAA6B,yBAAyB,QAAQ,gBAAgB,2BAA2B,gBAAgB,QAAQ,aAAa,EAAE,IAAI,QAAQ,aAAa,YAAY,OAAO;AACrd,SAAS,QAAQ,SAAS,IAAI,UAAU,2BAA2B,eAAe,mDAAmD,8BAA8B,kCAAkC,+BAA+B,gBAAgB,wBAAwB,OAAO,YAAY,WAAW,0BAA0B,OAAO,uBAAuB,cAAc,iBAAiB,KAAK,KAAK,aAAa,QAAQ,KAAK,KAAK,aAAa,yBAAyB,oBAAoB;AACpe,iDAAiD,KAAK,UAAU,2BAA2B,kBAAkB,0BAA0B,2BAA2B,YAAY,WAAW,UAAU,SAAS,mBAAmB,cAAc,cAAc,oBAAoB,SAAS,OAAO,QAAQ,OAAO,+BAA+B,qBAAqB,sBAAsB,oFAAoF;AAC5c,oCAAoC,eAAe,wBAAwB,UAAU,yMAAyM,2BAA2B,IAAI,uBAAuB,yBAAyB,eAAe,kBAAkB,8BAA8B,kBAAkB,mBAAmB,oBAAoB;AACre,cAAc,WAAW,qDAAqD,eAAe,QAAQ,IAAI,KAAK,mCAAmC,kBAAkB,YAAY,UAAU,SAAS,mBAAmB,gBAAgB,0CAA0C,iBAAiB,SAAS,mBAAmB,SAAS,KAAK,kBAAkB,WAAW,QAAQ,UAAU,UAAU,kBAAkB,qBAAqB,6BAA6B,UAAU,SAAS,YAAY,YAAY,WAAW,KAAK;AAClgB,WAAW,8CAA8C,OAAO,OAAO,UAAU,mBAAmB,cAAc,YAAY,YAAY,gBAAgB,qBAAqB,EAAE,8BAA8B,cAAc,cAAc,qBAAqB,KAAK,iBAAiB,2BAA2B,aAAa,wDAAwD,aAAa,mBAAmB,mBAAmB,OAAO,OAAO,UAAU,kBAAkB,kBAAkB,SAAS,mBAAmB;AACjgB,EAAE,eAAe,OAAO,kBAAkB,qCAAqC,eAAe,SAAS,2CAA2C,WAAW,KAAK,sBAAsB,8FAA8F,KAAK,8EAA8E,WAAW,sCAAsC,aAAa,WAAW,gBAAgB,UAAU,qBAAqB,KAAK,WAAW;AACjf,GAAG,gBAAgB,WAAW,wGAAwG,UAAU,iBAAiB,oCAAoC,WAAW,UAAU,WAAW,YAAY,kBAAkB,iBAAiB,aAAa,UAAU,mBAAmB,sBAAsB,mBAAmB,gBAAgB,uBAAuB,oBAAoB,yBAAyB,sBAAsB,SAAS,mBAAmB;AAC7e,GAAG,gDAAgD,SAAS,UAAU,mBAAmB,qBAAqB,qBAAqB,kCAAkC,oBAAoB,KAAK,uBAAuB,gCAAgC,qBAAqB,iBAAiB,qCAAqC,gBAAgB,+BAA+B,gBAAgB,uDAAuD,gBAAgB,qCAAqC,mBAAmB,aAAa;AAC3gB,KAAK,UAAU,0BAA0B,4BAA4B,4BAA4B,8BAA8B,cAAc,iBAAiB,kBAAkB,QAAQ,eAAe,OAAO,iCAAiC,WAAW,gEAAgE,kBAAkB;AAC5U,eAAe,WAAW,wBAAwB,aAAa,+BAA+B,uBAAuB,uBAAuB,mBAAmB,0BAA0B,0CAA0C,mBAAmB,SAAS,YAAY,IAAI,WAAW,MAAM,oBAAoB,QAAQ,UAAU,aAAa,SAAS,SAAS,SAAS,SAAS,kBAAkB,kBAAkB,iBAAiB,aAAa;AACzb,mDAAmD,UAAU,aAAa,UAAU,SAAS,mBAAmB,cAAc,MAAM,QAAQ,KAAK,MAAM,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC,mCAAmC;AACld,sBAAsB,sBAAsB,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,kBAAkB,kBAAkB,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,kBAAkB,kBAAkB,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,kBAAkB,kBAAkB,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS;AAC/e,EAAE,kBAAkB,kBAAkB,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,0BAA0B,0BAA0B,0BAA0B,0BAA0B,0BAA0B,0BAA0B,2BAA2B,2BAA2B,wBAAwB,wBAAwB,uBAAuB,uBAAuB,2BAA2B,2BAA2B;AAClf,qBAAqB,2BAA2B,0BAA0B,2BAA2B,wBAAwB,yBAAyB,0BAA0B,0BAA0B,uBAAuB,uBAAuB,2BAA2B,4BAA4B,2BAA2B,0BAA0B,oBAAoB,oBAAoB,2BAA2B,0BAA0B,2BAA2B;AAC5d,uBAAuB,uBAAuB,2BAA2B,0BAA0B,yBAAyB,wBAAwB,4BAA4B,2BAA2B,2BAA2B,0BAA0B,2BAA2B,0BAA0B,uBAAuB,uBAAuB,YAAY,YAAY,cAAc,aAAa,cAAc,aAAa,cAAc,aAAa,eAAe,cAAc;AACze,YAAY,cAAc,aAAa,eAAe,aAAa,aAAa,cAAc,eAAe,aAAa,YAAY,YAAY,cAAc,aAAa,eAAe,aAAa,cAAc,cAAc,cAAc,cAAc,YAAY,YAAY,cAAc,aAAa,cAAc,aAAa,eAAe,cAAc,aAAa,eAAe,YAAY,YAAY,eAAe,aAAa,aAAa,aAAa,eAAe,aAAa;AAClf,QAAQ,eAAe,WAAW,cAAc,QAAQ,saAAsa,UAAU,eAAe;AACvf,GAAG,QAAQ,iDAAiD,6BAA6B,IAAI,yCAAyC,wBAAwB,SAAS,UAAU,iBAAiB,OAAO,oBAAoB,aAAa,uCAAuC,IAAI,EAAE,yBAAyB,MAAM,WAAW,+BAA+B,SAAS,4BAA4B,aAAa,SAAS;AAC3Z,6NAA6N,IAAI,SAAS,MAAM,OAAO,QAAQ,IAAI,eAAe,KAAK,KAAK,SAAS,IAAI,gBAAgB,2BAA2B,MAAM,WAAW,mBAAmB,QAAQ,IAAI,eAAe,KAAK,KAAK,QAAQ,IAAI,EAAE,QAAQ,SAAS;AAC5b,gDAAgD,cAAc,cAAc,OAAO,mBAAmB,SAAS,UAAU,UAAU,UAAU,SAAS,mBAAmB,gBAAgB,YAAY,qBAAqB,uCAAuC,+BAA+B,+BAA+B,+BAA+B,0BAA0B,8BAA8B,iBAAiB,iBAAiB,iBAAiB,iBAAiB;AAC1d,2BAA2B,mCAAmC,gBAAgB,aAAa,YAAY,YAAY,2CAA2C,6BAA6B,OAAO,SAAS,wDAAwD,KAAK,iBAAiB,WAAW,WAAW,yBAAyB,KAAK,kBAAkB,UAAU,yBAAyB,6BAA6B,IAAI,KAAK,QAAQ,WAAW;AAC3b,WAAW,eAAe,iCAAiC,8CAA8C,IAAI,KAAK,qBAAqB,UAAU,SAAS,UAAU,KAAK,MAAM,cAAc,8HAA8H,KAAK,4BAA4B;AAC5V,gDAAgD,6CAA6C,0BAA0B,cAAc,cAAc,QAAQ,IAAI,mEAAmE,yBAAyB,UAAU,QAAQ,KAAK,KAAK,QAAQ,KAAK,EAAE,KAAK,QAAQ,IAAI,oCAAoC,YAAY,IAAI,IAAI,UAAU,UAAU,aAAa,QAAQ,IAAI;AAC5Z,UAAU,QAAQ,IAAI,cAAc,mBAAmB,OAAO,0BAA0B,4BAA4B,2BAA2B,sDAAsD,2EAA2E,iCAAiC,+BAA+B,2BAA2B,YAAY,OAAO,yBAAyB,eAAe,iBAAiB,iBAAiB,WAAW,2BAA2B;AAC9e,eAAe,qDAAqD,6BAA6B,oCAAoC,4BAA4B,IAAI,MAAM,YAAY,IAAI,aAAa,UAAU,OAAO,aAAa,2BAA2B,oCAAoC,uDAAuD,IAAI,uBAAuB,OAAO,WAAW,SAAS,mBAAmB,cAAc,yBAAyB,oBAAoB,oBAAoB;AACpf,OAAO,+BAA+B,kDAAkD,QAAQ,sBAAsB,OAAO,eAAe,2BAA2B,6CAA6C,eAAe,2BAA2B,sCAAsC,EAAE,UAAU,EAAE,eAAe;AACjU,mKAAmK,2EAA2E,EAAE,2EAA2E,mJAAmJ,EAAE,EAAE,SAAS,mBAAmB;AAC9e,UAAU,UAAU,MAAM,SAAS,UAAU,aAAa,SAAS,mBAAmB,cAAc,4BAA4B,cAAc,iBAAiB,WAAW,4BAA4B,SAAS,OAAO,gBAAgB,qCAAqC,eAAe,SAAS,wBAAwB,QAAQ,WAAW,gBAAgB,SAAS,8EAA8E,WAAW,sCAAsC,aAAa;AACnf,SAAS,KAAK,6BAA6B,OAAO,wBAAwB,WAAW,OAAO,OAAO,uBAAuB,wBAAwB,SAAS,mBAAmB,QAAQ,WAAW,kBAAkB,qBAAqB,iBAAiB,qBAAqB,oBAAoB,kBAAkB,iBAAiB,+BAA+B,iBAAiB,+BAA+B,iBAAiB,6BAA6B,iBAAiB,+BAA+B,SAAS;AAC3f,iBAAiB,aAAa,qCAAqC,aAAa,gGAAgG,SAAS,kBAAkB;AAC3M,8eAA8e;AAC9e,GAAG,QAAQ,SAAS,SAAS,QAAQ,6BAA6B,sBAAsB,KAAK,gBAAgB,KAAK,WAAW,gDAAgD,YAAY,YAAY,4EAA4E,4BAA4B,QAAQ,WAAW,KAAK,2DAA2D,IAAI,IAAI,IAAI,SAAS,IAAI,IAAI,IAAI,SAAS,yBAAyB,yBAAyB;AAC5d,yBAAyB,yBAAyB,yBAAyB,yBAAyB,0BAA0B,2BAA2B,iDAAiD,SAAS,mBAAmB,cAAc,uBAAuB,mCAAmC,mCAAmC,qBAAqB,6BAA6B,0CAA0C,mBAAmB,iBAAiB,iBAAiB,oBAAoB;AACtf,YAAY,yPAAyP,oBAAoB,6BAA6B,sIAAsI,8CAA8C;AAC1e,kCAAkC,8CAA8C,+BAA+B,SAAS,OAAO,oCAAoC,OAAO,IAAI,2BAA2B,8CAA8C,+CAA+C,oEAAoE,6BAA6B;AACvY,MAAM,4BAA4B,OAAO,iCAAiC,eAAe,OAAO,oBAAoB,2BAA2B,+EAA+E,WAAW,eAAe,WAAW,WAAW,kBAAkB,eAAe,OAAO,YAAY,6BAA6B,cAAc,yBAAyB,mDAAmD;AACzb,aAAa,yBAAyB,oBAAoB,2BAA2B,gBAAgB,UAAU,MAAM,kBAAkB,4BAA4B,4BAA4B,6BAA6B,gCAAgC,WAAW,KAAK,oCAAoC,8BAA8B,8BAA8B,SAAS,WAAW,YAAY,cAAc,0BAA0B,QAAQ,MAAM,wBAAwB,UAAU,UAAU;AAC9e,gBAAgB,0BAA0B,6BAA6B,sBAAsB,0BAA0B,kBAAkB,aAAa,2BAA2B,wDAAwD,MAAM,+BAA+B,kCAAkC,SAAS,KAAK,kBAAkB,yBAAyB,SAAS,+BAA+B,WAAW,gCAAgC,oBAAoB,cAAc;AAC9d,uCAAuC,uBAAuB,kBAAkB,OAAO,KAAK,kBAAkB,yCAAyC,SAAS,uCAAuC,UAAU,yBAAyB,eAAe,4BAA4B,mBAAmB,mBAAmB,+BAA+B,sEAAsE,qBAAqB,yCAAyC;AAC9d,8BAA8B,0BAA0B,0BAA0B,oBAAoB,0BAA0B,oBAAoB,0BAA0B,cAAc,qHAAqH,+BAA+B,WAAW,QAAQ,8DAA8D,2BAA2B;AAC5b,sBAAsB,0BAA0B,sBAAsB,uCAAuC,cAAc,SAAS,kBAAkB,cAAc,KAAK,QAAQ,yBAAyB,SAAS,+BAA+B,UAAU,0BAA0B,sFAAsF,UAAU,8BAA8B,0BAA0B,0BAA0B,2CAA2C;AACnf,kCAAkC,mBAAmB,0BAA0B,yBAAyB,gDAAgD,4BAA4B,qBAAqB,qBAAqB,oDAAoD,qBAAqB,qBAAqB,UAAU,UAAU,uEAAuE,qBAAqB,SAAS,uBAAuB,wBAAwB;AACpe,4BAA4B,2BAA2B,0BAA0B,qBAAqB,8CAA8C,qBAAqB,UAAU,UAAU,uEAAuE,YAAY,SAAS,SAAS,uBAAuB,wBAAwB,cAAc,4BAA4B,2BAA2B,+BAA+B,uBAAuB,iCAAiC;AAC7e,SAAS,IAAI,aAAa,SAAS,eAAe,6BAA6B,SAAS,kCAAkC,QAAQ,IAAI,KAAK,4BAA4B,wBAAwB,SAAS,kBAAkB,SAAS,SAAS,cAAc,SAAS,kBAAkB,IAAI,iCAAiC,0BAA0B,gFAAgF,0BAA0B,YAAY,iBAAiB,iBAAiB;AAC5e,4BAA4B,SAAS,cAAc,+BAA+B,SAAS,SAAS,IAAI,mBAAmB,mBAAmB,0LAA0L,4BAA4B,yBAAyB,wBAAwB,SAAS,mBAAmB,kBAAkB,4CAA4C;AAC/e,EAAE,aAAa,eAAe,qBAAqB,kBAAkB,kBAAkB,2BAA2B,sDAAsD,oBAAoB,mBAAmB,SAAS,cAAc,QAAQ,WAAW,aAAa,gCAAgC,QAAQ,WAAW,cAAc,iCAAiC,iCAAiC,oBAAoB,aAAa,+BAA+B,iCAAiC;AAC1e,SAAS,mBAAmB,cAAc,wCAAwC,wEAAwE,uBAAuB,QAAQ,EAAE,yBAAyB,oBAAoB,qBAAqB,oBAAoB,iBAAiB,2BAA2B,+BAA+B,yDAAyD,6BAA6B,uBAAuB,6BAA6B;AACte,WAAW,iBAAiB,4CAA4C,mCAAmC,kCAAkC,QAAQ,EAAE,eAAe,uBAAuB,0BAA0B,gBAAgB,cAAc,SAAS,oDAAoD,EAAE,oCAAoC,KAAK,kDAAkD,gBAAgB,8BAA8B,kBAAkB,WAAW,aAAa;AACve,6KAA6K,cAAc,MAAM,+BAA+B,wDAAwD,kBAAkB,wBAAwB,MAAM,iBAAiB,MAAM,iGAAiG;AAChc,GAAG,YAAY,qBAAqB,cAAc,yBAAyB,SAAS,mBAAmB,cAAc,wCAAwC,iBAAiB,qBAAqB,2BAA2B,oCAAoC,uDAAuD,wBAAwB,0EAA0E,eAAe,yBAAyB,+BAA+B;AACle,yBAAyB,wBAAwB,QAAQ,gBAAgB,6BAA6B,WAAW,UAAU,yBAAyB,0BAA0B,oCAAoC,2BAA2B,2CAA2C,mBAAmB,mBAAmB,yCAAyC,+GAA+G,2BAA2B;AACjf,0CAA0C,wBAAwB,QAAQ,QAAQ,WAAW,kCAAkC,SAAS,WAAW,6DAA6D,eAAe,WAAW,UAAU,sBAAsB,SAAS,mBAAmB,gBAAgB,UAAU,oBAAoB,uBAAuB,yBAAyB,WAAW,KAAK,qBAAqB,iCAAiC,SAAS,GAAG,0BAA0B;AAChf,WAAW,kCAAkC,uCAAuC,sCAAsC,6BAA6B,sBAAsB,kCAAkC,iCAAiC,iCAAiC,SAAS,mBAAmB,cAAc,2BAA2B,wCAAwC,qBAAqB,uBAAuB,wCAAwC,yBAAyB,SAAS;AACpf,iBAAiB,SAAS,aAAa,cAAc,mCAAmC,KAAK,yDAAyD,SAAS,4DAA4D,eAAe,8EAA8E,yBAAyB,GAAG,oBAAoB,2BAA2B,6BAA6B,OAAO,4BAA4B,oBAAoB,kBAAkB;AACze,uCAAuC,MAAM,EAAE,kGAAkG,iFAAiF,YAAY,iBAAiB,iBAAiB,iBAAiB,0BAA0B,kBAAkB,+DAA+D,GAAG,gDAAgD;AAC/b,6BAA6B,OAAO,8BAA8B,mBAAmB,SAAS,IAAI,qCAAqC,oCAAoC,iCAAiC,mCAAmC;;;;;;;;;AC1G/O;AACA;AACa;;AAEb,iCAAiC,mBAAO,CAAC,CAAiB;;AAE1D;AACA;AACA;AACA;AACA;;AAEA,uEAAuE,aAAa;AACpF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qB;;;;;;ACvGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,wCAAwC;AAC1E;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,oBAAoB;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,iDAAiD;AACjD,gDAAgD;AAChD,gDAAgD;AAChD,gDAAgD;AAChD,2CAA2C;AAC3C,kDAAkD;AAClD,iDAAiD;AACjD,wDAAwD;AACxD,wDAAwD;AACxD,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,cAAc,mBAAmB,EAAE;AACnC;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA,gCAAgC;AAChC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;;;;;;;ACjblB;AACA;AACA;AACA;AACA;;AAEa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACzFA;AACA,aAAa,mBAAO,CAAC,CAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS,mBAAO,CAAC,EAAQ;;AAEzB;AACA;AACA;AACA;;AAEA;;;AAGA,aAAa,mBAAO,CAAC,EAA2B;AAChD;;;AAGA,aAAa,mBAAO,CAAC,CAAQ;;AAE7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,gBAAgB,mBAAO,CAAC,EAAM;;AAE9B;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;;AAGA,iBAAiB,mBAAO,CAAC,EAAgC;;AAEzD,kBAAkB,mBAAO,CAAC,EAA4B;;AAEtD,eAAe,mBAAO,CAAC,EAA0B;AACjD;;AAEA,qBAAqB,mBAAO,CAAC,CAAW;AACxC;AACA;AACA;AACA,2FAA2F;;;AAG3F;AACA;AACA;;AAEA,mBAAO,CAAC,CAAU;;AAElB;AACA;;AAEA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA;AACA;;AAEA,yEAAyE,mFAAmF;AAC5J;;AAEA;AACA,qBAAqB,mBAAO,CAAC,CAAkB;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,yEAAyE;AACzE;;AAEA;AACA,kFAAkF;AAClF;;AAEA,0FAA0F;AAC1F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,+CAA+C;;AAE/C,2CAA2C;;AAE3C,yBAAyB;AACzB;AACA;;AAEA,2DAA2D;;AAE3D,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA,wCAAwC,mBAAO,CAAC,EAAiB;AACjE;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,CAAkB;AAC/C,gEAAgE;AAChE;;AAEA;AACA,mEAAmE;;AAEnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,+FAA+F;AAC/F,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA,4FAA4F;AAC5F,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;;AAGF;AACA,sCAAsC,mBAAO,CAAC,EAAiB;AAC/D;AACA,wCAAwC;;AAExC,sEAAsE;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E,GAAG;;;AAGH;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,sBAAsB;;AAEtB,sDAAsD;;AAEtD;;AAEA,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,0CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,0CAA0C;;AAE1C;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,0DAA0D;;AAE1D,4EAA4E;;AAE5E;;AAEA;AACA;AACA;AACA;AACA,GAAG,EAAE;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;;AAGH,iBAAiB,yBAAyB;AAC1C;AACA,GAAG;AACH;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,mBAAO,CAAC,EAAmC;AACrF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mDAAmD,+DAA+D;AAClH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,EAAyB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;;AAEA;AACA,C;;;;;;;;ACnmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;;;;;;AC7bA,iBAAiB,mBAAO,CAAC,EAAQ;;;;;;;;ACAjC,+CAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;AAGA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;;ACxGa;;AAEb,4BAA4B,mBAAO,CAAC,CAAiB;;AAErD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA,E;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,EAAgB;AACrC;AACA;;AAEA;;AAEA,aAAa,mBAAO,CAAC,EAA2B;AAChD;;;AAGA,aAAa,mBAAO,CAAC,CAAQ;;AAE7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAA4B;;AAEtD,eAAe,mBAAO,CAAC,EAA0B;AACjD;;AAEA,qBAAqB,mBAAO,CAAC,CAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAO,CAAC,CAAU;;AAElB;;AAEA;AACA,qBAAqB,mBAAO,CAAC,CAAkB;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,yEAAyE;AACzE;;AAEA;AACA,kFAAkF;AAClF;AACA;;AAEA,0FAA0F;;AAE1F,2BAA2B;;AAE3B,yBAAyB;;AAEzB,sBAAsB;;AAEtB,qBAAqB;;AAErB,wBAAwB;;AAExB,yBAAyB;AACzB;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA,2DAA2D;AAC3D;AACA;;AAEA,kBAAkB;;AAElB,uBAAuB;;AAEvB,kBAAkB;AAClB;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA,gCAAgC;;AAEhC;AACA;AACA,IAAI;;;AAGJ,sBAAsB;;AAEtB;AACA;AACA,kCAAkC;AAClC;;AAEA,qBAAqB;AACrB;;AAEA,2BAA2B;;AAE3B,4BAA4B;;AAE5B,+CAA+C;;AAE/C,2CAA2C;;AAE3C,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC,IAAI;AACL;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,CAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sDAAsD;AAC9H;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,yEAAyE;;AAEzE;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA,E;;;;;;;;ACxrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,EAAa;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb;;AAEA,qBAAqB,mBAAO,CAAC,CAAW;AACxC;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,CAAkB;;AAEvC,mBAAO,CAAC,CAAU;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,0CAA0C;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;ACxMA,mBAAO,CAAC,EAAyB;AACjC,aAAa,mBAAO,CAAC,EAAmB;;AAExC,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;;AAEvC,cAAc,mBAAO,CAAC,CAAY;AAClC,eAAe,mBAAO,CAAC,EAAwB;;AAE/C;;;;;;;;ACTA;AAAe,oFAAuB,yCAAyC,E;;;;;;;ACA/E;AAAe,oFAAuB,yCAAyC,E;;;;;;ACA/E;AACA;;AAEA,4CAA4C,gBAAgB;AAC5D,4CAA4C,gBAAgB;AAC5D,4CAA4C,WAAW;AACvD,4CAA4C,oCAAoC;AAChF,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;AACtE,4CAA4C,0BAA0B;;AAEtE;AACA;;AAEA,6BAA6B,mBAAmB;AAChD,6BAA6B,sCAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3fA,YAAY,mBAAO,CAAC,CAAoB;AACxC,YAAY,mBAAO,CAAC,EAAoB;AACxC,YAAY,mBAAO,CAAC,EAAoB;;AAExC;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA,GAAG;AACH;AACA;AACA,WAAW,+CAA+C;AAC1D;AACA,GAAG;AACH;AACA;AACA,WAAW,oEAAoE;AAC/E;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,OAAO;AACP,qBAAqB;AACrB,uBAAuB,OAAO;AAC9B;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,6BAA6B,EAAE;AAC/B,+BAA+B,EAAE,IAAI,EAAE;AACvC,kCAAkC,EAAE,GAAG,EAAE,GAAG,EAAE;AAC9C,+BAA+B,EAAE,IAAI,EAAE;AACvC,4CAA4C,EAAE,IAAI,EAAE;AACpD,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE,UAAU,EAAE,GAAG,EAAE;AACvD,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,qBAAqB,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,GAAG;AAC5E,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,KAAK,EAAE;AACxC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,wCAAwC,EAAE,GAAG,EAAE;AAC/C,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,GAAG,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,IAAI,EAAE;AACxC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,KAAK,EAAE;AACxC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,KAAK,EAAE;AACxC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,wCAAwC,EAAE,GAAG,EAAE;AAC/C,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,GAAG,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,IAAI,EAAE;AACxC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,KAAK,EAAE;AACxC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,KAAK,EAAE;AACxC,+BAA+B,EAAE,IAAI,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,GAAG,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,GAAG,EAAE;AACvC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,gCAAgC,EAAE,IAAI,EAAE;AACxC,gCAAgC,EAAE,GAAG,EAAE;AACvC,gCAAgC,EAAE,IAAI,EAAE;AACxC,gCAAgC,EAAE,KAAK,EAAE;AACzC,gCAAgC,EAAE,IAAI,EAAE;AACxC,gCAAgC,EAAE,GAAG,EAAE;AACvC,gCAAgC,EAAE,IAAI,EAAE;AACxC,gCAAgC,EAAE,IAAI,EAAE;AACxC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,GAAG,EAAE;AACtC,+BAA+B,EAAE,IAAI,EAAE;AACvC,qCAAqC,EAAE;AACvC,qCAAqC,EAAE;AACvC,qCAAqC,EAAE;AACvC,qCAAqC,EAAE;AACvC,sCAAsC,EAAE;AACxC,sCAAsC,EAAE;AACxC,sCAAsC,EAAE;AACxC,+BAA+B,EAAE,KAAK,EAAE;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA,aAAa;AACb,4CAA4C;AAC5C,qCAAqC;AACrC,mBAAmB,iBAAiB;AACpC;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA,mDAAmD;AACnD;AACA;AACA;AACA,sCAAsC;AACtC;AACA,cAAc;AACd,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,8DAA8D;AAC9D;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,eAAe,gDAAgD,EAAE;AACjE,yBAAyB;AACzB,qCAAqC;AACrC,sEAAsE;AACtE,2BAA2B;AAC3B,eAAe;AACf;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO,iBAAiB;;AAExB,2B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,oDAAoD,wCAAwC,OAAO;AACnG,mDAAmD,uDAAuD,MAAM;AAChH;AACA;AACA,oDAAoD,wCAAwC,OAAO;AACnG,mDAAmD,uDAAuD,MAAM;AAChH;AACA;AACA,oDAAoD,2CAA2C,QAAQ;AACvG,mDAAmD,yDAAyD,OAAO;AACnH;AACA;AACA,6CAA6C;AAC7C,qDAAqD;AACrD,2FAA2F;AAC3F,kHAAkH;AAClH,oDAAoD,iDAAiD,OAAO;AAC5G,mDAAmD,0DAA0D,MAAM;AACnH;AACA;AACA,8FAA8F;AAC9F,2HAA2H;AAC3H;AACA;AACA,8DAA8D,0CAA0C,EAAE;AAC1G,iCAAiC;AACjC,+BAA+B;AAC/B,gEAAgE;AAChE,+GAA+G;AAC/G,wHAAwH;AACxH,kBAAkB;AAClB,iBAAiB;AACjB,gEAAgE;AAChE,sHAAsH;AACtH,wHAAwH;AACxH,0DAA0D;AAC1D,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,YAAY,IAAI;;AAEhB;AACA;AACA;AACA,uEAAuE;AACvE,KAAK;AACL,yDAAyD;AACzD;AACA;;AAEA;AACA;;AAEA,kBAAkB;;;;;;;ACnnBlB,OAAO,mCAAmC,GAAG,mBAAO,CAAC,CAAoB;AACzE,OAAO,+DAA+D,GAAG,mBAAO,CAAC,EAAoB;;AAErG;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA,UAAU;AACV;;AAEA,kBAAkB;;;;;;;ACpNlB,yDAAU,mBAAO,CAAC,EAAqB;AACvC,UAAU,mBAAO,CAAC,EAAsB;AACxC,WAAW,mBAAO,CAAC,EAAa;AAChC,UAAU,mBAAO,CAAC,EAAU;AAC5B,gBAAgB,mBAAO,CAAC,EAAe;;AAEvC,mBAAmB,0BAA0B;;AAE7C;AACA,sCAAsC,qBAAqB;AAC3D;;AAEA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,WAAW;AACtC,oCAAoC,WAAW;AAC/C;;AAEA,sBAAsB,IAAI;AAC1B,+BAA+B,IAAI;AACnC;;AAEA,2BAA2B,KAAK;AAChC,sBAAsB,kBAAkB;AACxC;;AAEA,2BAA2B,KAAK;AAChC,wCAAwC,kBAAkB;AAC1D,eAAe;AACf;AACA;;AAEA,2BAA2B,KAAK;AAChC,wCAAwC,kBAAkB;AAC1D;;AAEA,2BAA2B,KAAK;AAChC,wCAAwC,kBAAkB;AAC1D;;AAEA,2BAA2B,KAAK;AAChC,kDAAkD,kBAAkB;AACpE;;AAEA,2BAA2B,KAAK;AAChC,kDAAkD,kBAAkB;AACpE;;AAEA,2BAA2B,KAAK;AAChC,sCAAsC,kBAAkB;AACxD;;AAEA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA,OAAO;;AAEP;AACA;AACA,2BAA2B,kBAAkB;;AAE7C;AACA,sBAAsB,oDAAoD;AAC1E,KAAK;;AAEL,GAAG;;;;;;;;AC5MH,cAAc,mBAAO,CAAC,EAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;ACTA,kBAAkB,mBAAO,CAAC,EAAc;AACxC,eAAe,mBAAO,CAAC,EAAe;AACtC,aAAa,mBAAO,CAAC,EAAe;AACpC,mBAAmB,mBAAO,CAAC,EAAwB;;AAEnD;AACA,cAAc,mBAAO,CAAC,EAAkB;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,gCAAgC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AC1Da;AACb,sBAAsB,mBAAO,CAAC,EAAmB;AACjD,mBAAmB,mBAAO,CAAC,EAAe;AAC1C,sBAAsB,mBAAO,CAAC,EAAsB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,oBAAoB;;AAE1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA,EAAE;AACF;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/Na;AACb;AACA;AACA;AACA,EAAE;AACF;;;;;;;;ACLa;AACb,uBAAuB,EAAE;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;AC7FA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA,UAAU,mBAAO,CAAC,EAAK;AACvB,gBAAgB,mBAAO,CAAC,EAAsB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzCa;AACb,aAAa,mBAAO,CAAC,EAAe;AACpC,iBAAiB,mBAAO,CAAC,EAAa;AACtC,mBAAmB,mBAAO,CAAC,EAAe;AAC1C,YAAY,mBAAO,CAAC,EAAO;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,KAAK;AACL,iCAAiC,SAAS;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;;;;;;ACtPA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;ACZA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;;;;;AC/BA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA,YAAY,mBAAO,CAAC,EAAO;AAC3B,oBAAoB,mBAAO,CAAC,EAAiB;AAC7C,kBAAkB,mBAAO,CAAC,EAAa;AACvC,aAAa,mBAAO,CAAC,EAAiB;AACtC,qBAAqB,mBAAO,CAAC,EAAiB;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,+CAA+C;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,2BAA2B;AAC3B,6BAA6B;AAC7B,OAAO;AACP;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,iBAAiB;AAC9B,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,0BAA0B;AAC1B;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B;AAC7B;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;;AAET;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;;AAEP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;ACh/BY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAU;;AAEnC,OAAO,WAAW;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAO,CAAC,EAAI;;AAEpC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;ACzQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACjKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA,uDAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAa;AAClC;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB;AACjB,2BAA2B;AAC3B;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;ACjDA,2BAA2B,mBAAO,CAAC,EAA2B;AAC9D;AACA;AACA,mBAAmB,mBAAO,CAAC,EAA2B;AACtD,iBAAiB,mBAAO,CAAC,CAAyB;AAClD,oBAAoB,mBAAO,CAAC,EAA4B;AACxD,sBAAsB,mBAAO,CAAC,EAA8B;AAC5D,mBAAmB,mBAAO,CAAC,EAAyC;AACpE,mBAAmB,mBAAO,CAAC,EAAoC;;;;;;;ACR/D,e;;;;;;;ACAa;;AAEb,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,eAAe,mBAAO,CAAC,CAAQ;AAC/B;;AAEA,gBAAgB,mBAAO,CAAC,EAAM;AAC9B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL,GAAG;AACH;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC,G;;;;;;ACjND,e;;;;;;;ACCA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClEA,+CAAa;;AAEb;;AAEA,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M,eAAe,mBAAO,CAAC,EAAiB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;;AAEA,yFAAyF;AACzF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA,mD;;;;;;;AC9MA;AACA;AACA;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,EAAqB;;AAE7C,mBAAO,CAAC,CAAU;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;ACtCA;AACA;AACa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,CAAiB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+BAA+B,mBAAO,CAAC,EAAiB;AACxD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,aAAa;AACrF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA,0B;;;;;;AChGA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;;;;;;;ACPhD,UAAU,mBAAO,CAAC,EAAsB;AACxC,SAAS,mBAAO,CAAC,EAAgB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,WAAW,O;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,KAAK;AACL;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,gCAAgC,gDAAgD;AAChF,iDAAiD;AACjD,gCAAgC,eAAe;AAC/C,gCAAgC,gCAAgC;AAChE,gCAAgC,eAAe;AAC/C,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC,kD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5RA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;;;;;;;;AChBA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC,eAAe,mBAAO,CAAC,EAAa;AACpC,cAAc,mBAAO,CAAC,EAAY;AAClC,cAAc,mBAAO,CAAC,EAAY;AAClC,aAAa,mBAAO,CAAC,EAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpEA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;AACrC,kBAAkB,mBAAO,CAAC,EAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,sCAAsC;;AAE3C;AACA;AACA;;AAEA;;;;;;;AC9DA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA,2B;;;;;;AC5FA;;AAEA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,yCAAyC,GAAG;AAC5C,mBAAmB,iBAAiB;AACpC,OAAO;AACP,KAAK;;AAEL,2B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7HA;;AAEA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC,aAAa,mBAAO,CAAC,EAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,gBAAgB,oBAAoB;AACpC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;ACjFA;;AAEA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC,aAAa,mBAAO,CAAC,EAAW;;AAEhC,eAAe,kBAAkB;AACjC;AACA;AACA,sBAAsB;AACtB,GAAG;AACH,sBAAsB;AACtB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;;;;;;ACrFA;;AAEA,WAAW,mBAAO,CAAC,EAAgB;AACnC,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,cAAc,mBAAO,CAAC,CAAe;;AAErC,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;ACxEA;;AAEA,OAAO,kBAAkB,GAAG,mBAAO,CAAC,CAAS;AAC7C,UAAU,mBAAO,CAAC,CAAqB;AACvC,WAAW,mBAAO,CAAC,EAAgB;AACnC,cAAc,mBAAO,CAAC,CAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sBAAsB;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB,wBAAwB;AACxB,wBAAwB,mDAAmD;AAC3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA","file":"index.3d39602c7eda2609528c.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 26);\n","var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n    return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    for (var i = 0; i < arrayFn.length; i++) {\n        arrayFn[i]();\n    }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n        return children.$LI;\n    }\n    if (flags & 8192 /* Fragment */) {\n        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n    }\n    return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n    var flags;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        vNode = findChildVNode(vNode, startEdge, flags);\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            removeChild(parentDOM, vNode.dom);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            insertOrAppend(parentDOM, vNode.dom, nextNode);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n    return (isLinkEventObject(lastValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\nfunction mergeUnsetProperties(to, from) {\n    for (var propName in from) {\n        if (isUndefined(to[propName])) {\n            to[propName] = from[propName];\n        }\n    }\n    return to;\n}\nfunction safeCall1(method, arg1) {\n    return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n    if (flags & 4 /* ComponentClass */) {\n        return ref;\n    }\n    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n    if (isNullOrUndef(defaultHooks)) {\n        return ref;\n    }\n    if (isNullOrUndef(ref)) {\n        return defaultHooks;\n    }\n    return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n    // set default props\n    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n    if (isNullOrUndef(defaultProps)) {\n        return props;\n    }\n    if (isNullOrUndef(props)) {\n        return combineFrom(defaultProps, null);\n    }\n    return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n    if (flags & 12 /* ComponentKnown */) {\n        return flags;\n    }\n    if (type.prototype && type.prototype.render) {\n        return 4 /* ComponentClass */;\n    }\n    if (type.render) {\n        return 32776 /* ForwardRefComponent */;\n    }\n    return 8 /* ComponentFunction */;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    flags = resolveComponentFlags(flags, type);\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                vNode.className = props.className || null;\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var clonedChildren;\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        clonedChildren = directClone(oldChildren);\n    }\n    else if (childFlags & 12 /* MultipleChildren */) {\n        clonedChildren = [];\n        for (var i = 0, len = oldChildren.length; i < len; ++i) {\n            clonedChildren.push(directClone(oldChildren[i]));\n        }\n    }\n    return createFragment(clonedChildren, childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    var normalizedRoot = normalizeRoot(children);\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nfunction normalizeRoot(input) {\n    if (isInvalid(input) || isStringOrNumber(input)) {\n        return createTextVNode(input, null);\n    }\n    if (isArray(input)) {\n        return createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (!eventsObject) {\n        eventsObject = dom.$EV = getDelegatedEventObject(null);\n    }\n    if (!eventsObject[name]) {\n        if (++attachedEventCounts[name] === 1) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n    }\n    return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n    if (isFunction(nextEvent)) {\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else if (isLinkEventObject(nextEvent)) {\n        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n            return;\n        }\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else {\n        unmountSyntheticEvent(name, dom);\n    }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n    var dom = getTargetNode(event);\n    do {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    } while (!isNull(dom));\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n    // Event data needs to be object to save reference to currentTarget getter\n    var eventData = {\n        dom: document\n    };\n    event.isDefaultPrevented = isDefaultPrevented;\n    event.isPropagationStopped = isPropagationStopped;\n    event.stopPropagation = stopPropagation;\n    Object.defineProperty(event, 'currentTarget', {\n        configurable: true,\n        get: function get() {\n            return eventData.dom;\n        }\n    });\n    return eventData;\n}\nfunction rootClickEvent(name) {\n    return function (event) {\n        if (event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 17 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        dispatchEvents(event, true, name, extendEventProperties(event));\n    };\n}\nfunction rootEvent(name) {\n    return function (event) {\n        dispatchEvents(event, false, name, extendEventProperties(event));\n    };\n}\nfunction attachEventToDocument(name) {\n    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n    document.addEventListener(normalizeEventName(name), attachedEvent);\n    return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n    var previousKey = \"$\" + eventName;\n    var previousArgs = dom[previousKey];\n    if (previousArgs) {\n        if (previousArgs[1].wrapped) {\n            return;\n        }\n        dom.removeEventListener(previousArgs[0], previousArgs[1]);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(eventName, handler);\n        dom[previousKey] = [eventName, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\n/**\n * There is currently no support for switching same input between controlled and nonControlled\n * If that ever becomes a real issue, then re design controlled elements\n * Currently user must choose either controlled or non-controlled and stick with that\n */\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nfunction forwardRef(render) {\n    return {\n        render: render\n    };\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (!safeCall1(ref, null) && ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref && (isFunction(ref) || ref.current !== void 0)) {\n        lifecycle.push(function () {\n            if (!safeCall1(ref, value) && ref.current !== void 0) {\n                ref.current = value;\n            }\n        });\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (syntheticEvents[key]) {\n                    unmountSyntheticEvent(key, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction wrapLinkEvent(nextValue) {\n    // This variable makes sure there is no \"this\" context in callback\n    var ev = nextValue.event;\n    return function (e) {\n        ev(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (isLinkEventObject(nextValue)) {\n        if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n            return;\n        }\n        nextValue = wrapLinkEvent(nextValue);\n    }\n    attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n    var lastHtml = (lastValue && lastValue.__html) || '';\n    var nextHtml = (nextValue && nextValue.__html) || '';\n    if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n            if (!isNull(lastVNode)) {\n                if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                    unmountAllChildren(lastVNode.children);\n                }\n                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                    unmount(lastVNode.children);\n                }\n                lastVNode.children = null;\n                lastVNode.childFlags = 1 /* HasInvalidChildren */;\n            }\n            dom.innerHTML = nextHtml;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n        case 'selectedIndex':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n            break;\n        default:\n            if (syntheticEvents[prop]) {\n                handleSyntheticEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        mountFunctionalComponentCallbacks(vNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction renderFunctionalComponent(vNode, context) {\n    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(vNode.props || EMPTY_OBJ, vNode.ref, context) : vNode.type(vNode.props || EMPTY_OBJ, context);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n    };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n    var ref = vNode.ref;\n    if (!isNullOrUndef(ref)) {\n        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = (nextVNode.dom = lastVNode.dom);\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var type = nextVNode.type;\n        var nextInput = normalizeRoot(nextVNode.flags & 32768 /* ForwardRef */ ? type.render(nextProps, nextRef, context) : type(nextProps, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = (nextVNode.dom = lastVNode.dom);\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n    }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n    var aNode;\n    var bNode;\n    var nextPos;\n    var i = 0;\n    var aStart = j;\n    var bStart = j;\n    var aLeft = aEnd - j + 1;\n    var bLeft = bEnd - j + 1;\n    var sources = new Int32Array(bLeft + 1);\n    // Keep track if its possible to remove whole DOM using textContent = '';\n    var canRemoveWholeContent = aLeft === aLength;\n    var moved = false;\n    var pos = 0;\n    var patched = 0;\n    // When sizes are small, just loop them through\n    if (bLength < 4 || (aLeft | bLeft) < 32) {\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                for (j = bStart; j <= bEnd; j++) {\n                    bNode = b[j];\n                    if (aNode.key === bNode.key) {\n                        sources[j - bStart] = i + 1;\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (aStart < i) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                        break;\n                    }\n                }\n                if (!canRemoveWholeContent && j > bEnd) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    else {\n        var keyIndex = {};\n        // Map keys by their index\n        for (i = bStart; i <= bEnd; ++i) {\n            keyIndex[b[i].key] = i;\n        }\n        // Try to patch same keys\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                j = keyIndex[aNode.key];\n                if (j !== void 0) {\n                    if (canRemoveWholeContent) {\n                        canRemoveWholeContent = false;\n                        while (i > aStart) {\n                            remove(a[aStart++], dom);\n                        }\n                    }\n                    sources[j - bStart] = i + 1;\n                    if (pos > j) {\n                        moved = true;\n                    }\n                    else {\n                        pos = j;\n                    }\n                    bNode = b[j];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[j] = bNode = directClone(bNode);\n                    }\n                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                    ++patched;\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    // fast-path: if nothing patched remove all old and add all new\n    if (canRemoveWholeContent) {\n        removeAllChildren(dom, parentVNode, a);\n        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n    }\n    else if (moved) {\n        var seq = lis_algorithm(sources);\n        j = seq.length - 1;\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n            else if (j < 0 || i !== seq[j]) {\n                pos = i + bStart;\n                bNode = b[pos];\n                nextPos = pos + 1;\n                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n            }\n            else {\n                j--;\n            }\n        }\n    }\n    else if (patched !== bLeft) {\n        // when patched count doesn't match b length we need to insert those new ones\n        // loop backwards so we can use insertBefore\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n        result[u] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    if (window.Node) {\n        Node.prototype.$EV = null;\n        Node.prototype.$V = null;\n    }\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    callAll(lifecycle);\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : function (a) {\n        window.setTimeout(a, 0);\n    };\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force);\n                if (isFunction(callback)) {\n                    callback.call(component);\n                }\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0; i < queue.length; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.shift())) {\n        if (!component.$UN) {\n            applyState(component, false);\n            if (component.$QU) {\n                callSetStateCallbacks(component);\n            }\n        }\n    }\n}\nfunction applyState(component, force) {\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        callAll(lifecycle);\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.4.2\";\n\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };\n","export * from './dist/index.esm.js';\n\nif (process.env.NODE_ENV !== 'production') {\n  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');\n}\n","import { getFlagsForElementVnode, createFragment, createVNode, createComponentVNode, Fragment } from 'inferno';\n\nvar isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\n\nvar classIdSplit = /([.#]?[a-zA-Z0-9_:-]+)/;\nvar notClassId = /^\\.|#/;\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'div';\n    }\n    if (tag === Fragment) {\n        return tag;\n    }\n    var noId = props && isUndefined(props.id);\n    var tagParts = tag.split(classIdSplit);\n    var tagName = null;\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'div';\n    }\n    var classes;\n    for (var i = 0, len = tagParts.length; i < len; ++i) {\n        var part = tagParts[i];\n        if (!part) {\n            continue;\n        }\n        var type = part.charAt(0);\n        if (!tagName) {\n            tagName = part;\n        }\n        else if (type === '.') {\n            if (classes === void 0) {\n                classes = [];\n            }\n            classes.push(part.substring(1, part.length));\n        }\n        else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n        props.className = classes.join(' ');\n    }\n    return tagName || 'div';\n}\nfunction isChildren(x) {\n    return isStringOrNumber(x) || (x && isArray(x));\n}\n/**\n * Creates virtual node\n * @param {string|VNode|Function} _tag Name for virtual node\n * @param {object=} _props Additional properties for virtual node\n * @param {string|number|VNode|Array<string|number|VNode>|null=} _children Optional children for virtual node\n * @returns {VNode} returns new virtual node\n */\nfunction h(_tag, _props, _children) {\n    // If a child array or text node are passed as the second argument, shift them\n    if (!_children && isChildren(_props)) {\n        _children = _props;\n        _props = {};\n    }\n    var isElement = isString(_tag);\n    _props = _props || {};\n    var tag = isElement ? parseTag(_tag, _props) : _tag;\n    var newProps = {};\n    var key = null;\n    var ref = null;\n    var children = null;\n    var className = null;\n    for (var prop in _props) {\n        if (isElement && (prop === 'className' || prop === 'class')) {\n            className = _props[prop];\n        }\n        else if (prop === 'key') {\n            key = _props[prop];\n        }\n        else if (prop === 'ref') {\n            ref = _props[prop];\n        }\n        else if (prop === 'hooks') {\n            ref = _props[prop];\n        }\n        else if (prop === 'children') {\n            children = _props[prop];\n        }\n        else if (!isElement && prop.substr(0, 11) === 'onComponent') {\n            if (!ref) {\n                ref = {};\n            }\n            ref[prop] = _props[prop];\n        }\n        else {\n            newProps[prop] = _props[prop];\n        }\n    }\n    if (isElement) {\n        var flags = getFlagsForElementVnode(tag);\n        if (flags & 8192 /* Fragment */) {\n            return createFragment(_children || children, 0 /* UnknownChildren */, key);\n        }\n        if (newProps.contenteditable !== void 0) {\n            flags |= 4096 /* ContentEditable */;\n        }\n        return createVNode(flags, tag, className, _children || children, 0 /* UnknownChildren */, newProps, key, ref);\n    }\n    if (children || _children) {\n        newProps.children = children || _children;\n    }\n    return createComponentVNode(2 /* ComponentUnknown */, tag, newProps, key, ref);\n}\n\nexport { h };\n","const fm = require(\"formality-lang\");\nconst moonad_client = require(\"./../back/client.js\")({url:window.location.origin});\nconst ethsig = require(\"nano-ethereum-signer\");\n\nfunction memoize(fn) {\n  var memo = {};\n  return function(arg) {\n    if (!memo[arg]) {\n      memo[arg] = fn(arg);\n    }\n    return memo[arg];\n  };\n};\n\nfunction gen_pkey() {\n  var pkey = \"\";\n  var nums = crypto.getRandomValues(new Uint8Array(32));\n  for (var i = 0; i < nums.length; ++i) {\n    pkey += (\"00\" + nums[i].toString(16)).slice(-2);\n  }\n  localStorage.setItem(\"pkey\", pkey);\n  return pkey;\n};\n\nfunction get_pkey() {\n  return localStorage.getItem(\"pkey\") || gen_pkey();\n};\n\nfunction get_addr() {\n  return pkey_to_addr(get_pkey());\n};\n\nfunction format_date(date) {\n  var date = new Date(date);\n  return date.getFullYear()+\"-\"+date.getMonth()+\"-\"+date.getDate()\n    + \", \"+date.getHours()+\"h \"+date.getMinutes()+\"min\";\n}\n\nconst pkey_to_addr = memoize(ethsig.addressFromKey);\n\n// Login\n// =====\n\n// Asks the user a name, registers a new (name,addr) pair.\nasync function register(taken = false) {\n  var name = prompt((taken ? \"Name taken. \" : \"\") + \"Choose a name:\");\n  try {\n    console.log(\"Registering\", name);\n    await lib.moonad.api.register({name, addr: lib.addr});\n    return name;\n  } catch (e) {\n    console.log(\"register error:\", e);\n    register(true);\n  }\n};\n\n// Logs in with the private key. If not registered, registers.\nasync function login() {\n  console.log(\"Logging in...\");\n  try {\n    return await lib.moonad.api.get_name({addr: lib.addr})\n  } catch (e) {\n    console.log(\"login error:\", e);\n    return await register();\n  }\n};\n\n// Routing\n// =======\n\nfunction get_route() {\n  var route = window.location.pathname;\n  return route === \"/\" ? \"/p\" : route;\n}\n\nfunction set_route(route) {\n  window.history.pushState({}, route, window.location.origin+route);\n}\n\nfunction get_paths() {\n  return get_route().split(\"/\").slice(1);\n};\n\nfunction get_watched_poid() {\n  var paths = get_paths(); \n  if (paths[0] === \"p\") {\n    return paths[1] || \"0x0000000000000000\";\n  } else {\n    return null;\n  };\n};\n\nvar last_watched_poid = null;\nfunction refresh_watched_poid() {\n  var watched_poid = get_watched_poid();\n  if (watched_poid !== null && last_watched_poid !== watched_poid) {\n    //console.log(\"watch:\", watched_poid);\n    lib.moonad.do_watch(watched_poid);\n    last_watched_poid = watched_poid;\n  };\n};\n\n// Formality\n// =========\n\nfunction remove_colors(msg) {\n  return msg.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,\"\");\n};\n\nasync function load_defs_of(name, defs = {}) {\n  //console.log(\"loading\", name);\n  if (!defs[name]) {\n    var poid = await lib.moonad.api.get_orig({name});\n    //console.log(\"- poid: \", poid);\n    var post = await lib.moonad.api.get_post({poid});\n    //console.log(\"- post: \", post);\n    var auth = lib.moonad.lib.get_post_auth(post);\n    //console.log(\"- auth: \", auth);\n    var anam = await lib.moonad.api.get_name({addr: auth.toLowerCase()});\n    //console.log(\"- anam: \", anam);\n    var code = lib.moonad.lib.get_post_code(post, anam);\n    //console.log(\"- code: \", code);\n    var new_defs = fm.lang.parse(code).defs;\n    for (var def in new_defs) {\n      //console.log(\"- defn: \" + def);\n      defs[def] = new_defs[def];\n    };\n    var deps = await lib.moonad.api.get_deps({name});\n    //console.log(\"- deps:\", deps);\n    var deps_loads = [];\n    for (var dep of deps) {\n      deps_loads.push(load_defs_of(dep, defs));\n    };\n    await Promise.all(deps_loads);\n  };\n  return defs;\n};\n\n// Startup\n// =======\n\n// Gets the private key stored on browser\nvar lib = {};\nlib.pkey = get_pkey();\nlib.addr = get_addr();\n\n// Starts the moonad object. It gets data from server, allows making posts, etc.\nlib.moonad = moonad_client.direct();\n\n// Logs in.\nlib.name = \"user\";\nlogin().then((login_name) => {\n  console.log(\"logged as\", login_name);\n  lib.name = login_name;\n});\n\n// Periodically sends watched poid to server.\nsetInterval(refresh_watched_poid, 50);\n\nlib.gen_pkey = gen_pkey;\nlib.get_pkey = get_pkey;\nlib.get_addr = get_addr;\nlib.pkey_to_addr = pkey_to_addr;\nlib.format_date = format_date;\nlib.register = register;\nlib.login = login;\nlib.get_route = get_route;\nlib.set_route = set_route;\nlib.get_paths = get_paths;\nlib.get_watched_poid = get_watched_poid;\nlib.refresh_watched_poid = refresh_watched_poid;\nlib.remove_colors = remove_colors;\nlib.load_defs_of = load_defs_of;\n\nmodule.exports = lib;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// This is the same as FormalityCore.js, but with holes and unification\n\n// Term\n// ====\n\nconst Var = (indx)                     => ({ctor:\"Var\",indx});\nconst Ref = (name)                     => ({ctor:\"Ref\",name});\nconst Typ = ()                         => ({ctor:\"Typ\"});\nconst All = (eras,self,name,bind,body) => ({ctor:\"All\",eras,self,name,bind,body});\nconst Lam = (eras,name,body)           => ({ctor:\"Lam\",eras,name,body});\nconst App = (eras,func,argm)           => ({ctor:\"App\",eras,func,argm});\nconst Let = (name,expr,body)           => ({ctor:\"Let\",name,expr,body});\nconst Ann = (done,expr,type)           => ({ctor:\"Ann\",done,expr,type});\nconst Loc = (from,upto,expr)           => ({ctor:\"Loc\",from,upto,expr});\nconst Wat = (name)                     => ({ctor:\"Wat\",name});\nconst Hol = (name,vals)                => ({ctor:\"Hol\",name,vals});\nconst Cse = (name,func,info)           => ({ctor:\"Cse\",name,func,info});\nconst Nat = (natx)                     => ({ctor:\"Nat\",natx});\nconst Chr = (chrx)                     => ({ctor:\"Chr\",chrx});\nconst Str = (strx)                     => ({ctor:\"Str\",strx});\n\n// List\n// ====\n\nconst Nil = ()          => ({ctor:\"Nil\",size:0});\nconst Ext = (head,tail) => ({ctor:\"Ext\",head,tail,size:tail.size+1});\n\n// Finds first value satisfying `cond` in a list\nfunction find(list, cond, indx = 0) {\n  switch (list.ctor) {\n    case \"Nil\":\n      return null;\n    case \"Ext\":\n      if (cond(list.head, indx)) {\n        return {value:list.head, index:indx};\n      } else {\n        return find(list.tail, cond, indx + 1);\n      };\n  };\n};\n\n// Gets the nth element of a list\nfunction at(list, n) {\n  switch (list.ctor) {\n    case \"Nil\": return null;\n    case \"Ext\": return n === 0 ? list.head : at(list.tail, n - 1);\n  };\n};\n\n// Folds a list\nfunction fold(list, nil, cons) {\n  switch (list.ctor) {\n    case \"Nil\": return nil;\n    case \"Ext\": return cons(list.head, fold(list.tail, nil, cons));\n  }\n};\n\n// Syntax\n// ======\n\nfunction stringify(term, depth = 0) {\n  switch (term.ctor) {\n    case \"Var\":\n      return term.indx.split(\"#\")[0];\n    case \"Ref\":\n      return term.name;\n    case \"Typ\":\n      return \"*\";\n    case \"All\":\n      var bind = term.eras ? \"\" : \"\";\n      var self = term.self;\n      var name = term.name;\n      var type = stringify(term.bind, depth);\n      var body = stringify(term.body(Var(self+\"#\"), Var(name+\"#\")), depth + 2);\n      return bind + self + \"(\" + name + \":\" + type + \") \" + body;\n    case \"Lam\":\n      var bind = term.eras ? \"\" : \"\";\n      var name = term.name;\n      var body = stringify(term.body(Var(name+\"#\")), depth + 1);\n      return bind + name + \" \" + body;\n    case \"App\":\n      var open = term.eras ? \"<\" : \"(\";\n      var func = stringify(term.func, depth);\n      var argm = stringify(term.argm, depth);\n      var clos = term.eras ? \">\" : \")\";\n      return open + func + \" \" + argm + clos;\n    case \"Let\":\n      var name = term.name;\n      var expr = stringify(term.expr, depth);\n      var body = stringify(term.body(Var(name+\"#\")), depth + 1);\n      return \"$\" + name + \"=\" + expr + \";\" + body;\n    case \"Ann\":\n      var type = stringify(term.type, depth);\n      var expr = stringify(term.expr, depth);\n      return \":\" + type + \" \" + expr;\n    case \"Loc\":\n      return stringify(term.expr, depth);\n    case \"Wat\":\n      return \"?\"+term.name;\n    case \"Hol\":\n      return \"_\"+term.name;\n    case \"Cse\":\n      return \"<TODO:stringify.case>\";\n    case \"Nat\":\n      return \"\"+term.natx;\n    case \"Chr\":\n      return \"'\"+term.chrx+\"'\";\n    case \"Str\":\n      return '\"'+term.strx+'\"';\n  };\n};\n\nfunction parse(code, indx, mode = \"defs\") {\n  function is_name(chr) {\n    var val = chr.charCodeAt(0);\n    return (val >= 46 && val < 47)   // .\n        || (val >= 48 && val < 58)   // 0-9\n        || (val >= 65 && val < 91)   // A-Z\n        || (val >= 95 && val < 96)   // _\n        || (val >= 97 && val < 123); // a-z\n  };\n  function parse_name() {\n    if (indx < code.length && is_name(code[indx])) {\n      return code[indx++] + parse_name();\n    } else {\n      return \"\";\n    }\n  };\n  function parse_nuls() {\n    while (code[indx] === \" \" || code[indx] === \"\\n\") {\n      ++indx;\n    };\n  };\n  function parse_char(chr) {\n    if (indx >= code.length) {\n      throw \"Unexpected eof.\";\n    } else if (code[indx] !== chr) {\n      throw 'Expected \"'+chr+'\", found '+JSON.stringify(code[indx])+' at '+indx+': `'+code.slice(indx)+\"`.\";\n    }\n    ++indx;\n  };\n  function parse_term() {\n    parse_nuls();\n    var chr = code[indx++];\n    switch (chr) {\n      case \"*\":\n        return ctx => Typ();\n      case \"\":\n      case \"\":\n        var eras = chr === \"\";\n        var self = parse_name();\n        var skip = parse_char(\"(\");\n        var name = parse_name();\n        var skip = parse_char(\":\");\n        var bind = parse_term();\n        var skip = parse_char(\")\");\n        var body = parse_term();\n        return ctx => All(eras, self, name, bind(ctx), (s,x) => body(Ext([name,x],Ext([self,s],ctx))));\n      case \"\":\n      case \"\":\n        var eras = chr === \"\";\n        var name = parse_name();\n        var body = parse_term();\n        return ctx => Lam(eras, name, (x) => body(Ext([name,x],ctx)));\n      case \"(\":\n      case \"<\":\n        var eras = chr === \"<\";\n        var func = parse_term();\n        var argm = parse_term();\n        var skip = parse_char(eras ? \">\" : \")\");\n        return ctx => App(eras, func(ctx), argm(ctx));\n      case \"$\":\n      case \"@\":\n        var name = parse_name();\n        var skip = parse_char(\"=\");\n        var expr = parse_term();\n        var skip = parse_char(\";\");\n        var body = parse_term();\n        return ctx => Let(name, expr(ctx), x => body(Ext([name,x],ctx)));\n      case \":\":\n        var type = parse_term();\n        var expr = parse_term();\n        return ctx => Ann(false, expr(ctx), type(ctx));\n      case \"?\":\n        var name = parse_name();\n        return ctx => Wat(name);\n      case \"_\":\n        var name = parse_name();\n        return ctx => Hol(name, fold(ctx, Nil(), (h,t) => Ext(h[1],t)));\n      case \"'\":\n        var chrx = code[indx++];\n        var skip = parse_char(\"'\");\n        return ctx => Chr(chrx);\n      case '\"':\n        var strx = \"\";\n        while (code[indx] !== '\"') {\n          strx += code[indx++];\n        }\n        var skip = parse_char('\"');\n        return ctx => Str(strx);\n      default:\n        if (is_name(chr)) {\n          var name = chr + parse_name();\n          return ctx => {\n            var got = find(ctx, (x) => x[0] === name);\n            if (got) {\n              return got.value[1];\n            } else if (/^[0-9]*$/.test(name)) {\n              return Nat(BigInt(name));\n            } else {\n              return Ref(name);\n            }\n          };\n        } else {\n          throw \"Unexpected symbol: '\" + chr + \"'.\";\n        }\n    };\n  };\n  function parse_defs() {\n    parse_nuls();\n    var name = parse_name();\n    if (name.length > 0) {\n      var skip = parse_char(\":\");\n      var type = parse_term()(Nil());\n      var term = parse_term()(Nil());\n      defs[name] = {type, term};\n      parse_defs();\n    }\n  };\n  var indx = 0;\n  if (mode === \"defs\") {\n    var defs = {};\n    parse_defs();\n    return {defs};\n  } else {\n    return parse_term()(Nil());\n  };\n};\n\n// Derivers\n// ========\n\nfunction build_cse(term, type) {\n  var tnam = term.name.split(\"#\")[0];\n  var func = term.func;\n  var info = term.info;\n  var indx = 0;\n  var [ctx, args] = info;\n  while (type.ctor === \"All\") {\n    let csev = args[indx];\n    if (csev) {\n      var bind = type.bind;\n      var argm = (function go(bind, ctx) {\n        if (bind.ctor === \"All\") {\n          var eras = bind.eras;\n          var name = tnam+\".\"+bind.name;\n          var body = x => go(bind.body(bind, bind.bind), Ext([name, x], ctx));\n          return Lam(eras, name, body);\n        } else {\n          return csev(ctx);\n        };\n      })(type.bind, ctx);\n    } else {\n      throw \"Misformatted case. TODO: improve this error.\"\n    }\n    func = App(type.eras, func, argm);\n    type = type.body(type, type.bind);\n    indx = indx + 1;\n  };\n  return func;\n};\n\nfunction build_nat(term) {\n  if (term.natx === 0n) {\n    return Ref(\"Nat.zero\");\n  } else {\n    return App(false, Ref(\"Nat.succ\"), Nat(term.natx - 1n));\n  };\n};\n\nfunction build_chr(term) {\n  var done = Ref(\"Char.new\");\n  var ccod = term.chrx.charCodeAt(0);\n  for (var i = 0; i < 16; ++i) {\n    done = App(false, done, Ref(((ccod>>>(16-i-1))&1) ? \"Bit.1\" : \"Bit.0\"));\n  };\n  return done;\n};\n\nfunction build_str(term) {\n  if (term.strx.length === 0) {\n    return Ref(\"String.nil\");\n  } else {\n    var chr = build_chr(Chr(term.strx[0]));\n    return App(false, App(false, Ref(\"String.cons\"), chr), Str(term.strx.slice(1)));\n  }\n};\n\n// Evaluation\n// ==========\n\nfunction unloc(term) {\n  switch (term.ctor) {\n    case \"Var\": return term;\n    case \"Ref\": return term;\n    case \"Typ\": return term;\n    case \"All\": return All(term.eras, term.self, term.name, unloc(term.bind), (s, x) => unloc(term.body(s, x)));\n    case \"Lam\": return Lam(term.eras, term.name, x => unloc(term.body(x)));\n    case \"App\": return App(term.eras, unloc(term.func), unloc(term.argm));\n    case \"Let\": return Let(term.name, unloc(term.expr), x => unloc(term.body(x)));\n    case \"Ann\": return Ann(term.done, unloc(term.expr), unloc(term.type));\n    case \"Loc\": return unloc(term.expr);\n    case \"Wat\": return term;\n    case \"Hol\": return term;\n    case \"Nat\": return term;\n    case \"Chr\": return term;\n    case \"Str\": return term;\n  };\n};\n\nfunction reduce(term, defs = {}, hols = {}, erased = false) {\n  switch (term.ctor) {\n    case \"Var\":\n      return Var(term.indx);\n    case \"Ref\":\n      if (defs[term.name]) {\n        // If reference wasn't synthetized, synthetize it\n        if (defs[term.name].core === undefined) {\n          var got = typesynth(term.name, defs).term;\n        // If reference is being synthetized, return its version with holes\n        } else if (defs[term.name].core === null) {\n          var got = defs[term.name].term;\n        // If reference was synthetized, return its filled core version\n        } else {\n          var got = defs[term.name].core.term;\n        }\n        // Avoids reducing axioms\n        if (got.ctor === \"Loc\" && got.expr.ctor === \"Ref\" && got.expr.name === term.name) {\n          return got;\n        } else {\n          return reduce(got, defs, hols, erased);\n        };\n      } else {\n        return Ref(term.name);\n      }\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var eras = term.eras;\n      var self = term.self;\n      var name = term.name;\n      var bind = term.bind;\n      var body = term.body;\n      return All(eras, self, name, bind, body);\n    case \"Lam\":\n      if (erased && term.eras) {\n        return reduce(term.body(Lam(false, \"\", x => x)), defs, hols, erased);\n      } else {\n        var eras = term.eras;\n        var name = term.name;\n        var body = term.body;\n        return Lam(eras, name, body);\n      }\n    case \"App\":\n      if (erased && term.eras) {\n        return reduce(term.func, defs, hols, erased);\n      } else {\n        var eras = term.eras;\n        var func = reduce(term.func, defs, hols, erased);\n        switch (func.ctor) {\n          case \"Lam\":\n            return reduce(func.body(term.argm), defs, hols, erased);\n          default:\n            return App(eras, func, term.argm);\n        };\n      };\n    case \"Let\":\n      var name = term.name;\n      var expr = term.expr;\n      var body = term.body;\n      return reduce(body(expr), defs, hols, erased);\n    case \"Ann\":\n      return reduce(term.expr, defs, hols, erased);\n    case \"Loc\":\n      return reduce(term.expr, defs, hols, erased);\n    case \"Wat\":\n      return Wat(term.name);\n    case \"Hol\":\n      if (hols[term.name]) {\n        return reduce(hols[term.name](term.vals), defs, hols, erased);\n      } else {\n        return Hol(term.name, term.vals);\n      }\n    case \"Cse\":\n      if (hols[term.name]) {\n        var typ = hols[term.name];\n        return reduce(build_cse(term, hols[term.name]), defs, hols, erased);\n      } else {\n        //console.log(\"couldn't find\", term.name, stringify(term.func));\n        return term;\n      };\n    case \"Nat\":\n      return reduce(build_nat(term), defs, hols, erased);\n    case \"Chr\":\n      return reduce(build_chr(term), defs, hols, erased);\n    case \"Str\":\n      return reduce(build_str(term), defs, hols, erased);\n  };\n};\n\nfunction normalize(term, defs, hols = {}, erased = false, seen = {}) {\n  var norm = reduce(term, defs, hols, erased);\n  var term_hash = hash(term);\n  var norm_hash = hash(norm);\n  if (seen[term_hash] || seen[norm_hash]) {\n    return term;\n  } else {\n    var seen = {...seen, [term_hash]: true, [norm_hash]: true};\n    switch (norm.ctor) {\n      case \"Var\":\n        return Var(norm.indx);\n      case \"Ref\":\n        return Ref(norm.name);\n      case \"Typ\":\n        return Typ();\n      case \"All\":\n        var eras = norm.eras;\n        var self = norm.self;\n        var name = norm.name;\n        var bind = normalize(norm.bind, defs, hols, erased, seen);\n        var body = (s,x) => normalize(norm.body(s,x), defs, hols, erased, seen);\n        return All(eras, self, name, bind, body);\n      case \"Lam\":\n        var eras = norm.eras;\n        var name = norm.name;\n        var body = x => normalize(norm.body(x), defs, hols, erased, seen);\n        return Lam(eras, name, body);\n      case \"App\":\n        var eras = norm.eras;\n        var func = normalize(norm.func, defs, hols, erased, seen);\n        var argm = normalize(norm.argm, defs, hols, erased, seen);\n        return App(eras, func, argm);\n      case \"Let\":\n        return normalize(norm.body(norm.expr), defs, hols, erased, seen);\n      case \"Ann\":\n        return normalize(norm.expr, defs, hols, erased, seen);\n      case \"Loc\":\n        return normalize(norm.expr, defs, hols, erased, seen);\n      case \"Wat\":\n        return Wat(norm.name);\n      case \"Hol\":\n        return Hol(norm.name, norm.vals);\n      case \"Cse\":\n        return Cse(term.name, term.func, term.info);\n      case \"Nat\":\n        return Nat(term.natx);\n      case \"Chr\":\n        return Chr(term.chrx);\n      case \"Str\":\n        return Str(term.strx);\n    };\n  }\n};\n\n// Prepares a term to be stored on .fmc source\n// - Fills holes\n// - Applies static function calls (necessary for inference)\n// - Removes done Anns\n// - Removes Nat/Str if we're compiling to core\nfunction canonicalize(term, hols = {}, to_core = false) {\n  switch (term.ctor) {\n    case \"Var\":\n      return Var(term.indx);\n    case \"Ref\":\n      return Ref(term.name);\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var eras = term.eras;\n      var self = term.self;\n      var name = term.name;\n      var bind = canonicalize(term.bind, hols, to_core);\n      var body = (s,x) => canonicalize(term.body(s,x), hols, to_core);\n      return All(eras, self, name, bind, body);\n    case \"Lam\":\n      var eras = term.eras;\n      var name = term.name;\n      var body = x => canonicalize(term.body(x), hols, to_core);\n      return Lam(eras, name, body);\n    case \"App\":\n      var eras = term.eras;\n      var func = canonicalize(term.func, hols, to_core);\n      var argm = canonicalize(term.argm, hols, to_core);\n      switch (func.ctor) {\n        case \"Lam\":\n          return canonicalize(func.body(term.argm), hols, to_core);\n        default:\n          return App(eras, func, argm);\n      };\n    case \"Let\":\n      var name = term.name;\n      var expr = canonicalize(term.expr, hols, to_core);\n      var body = x => canonicalize(term.body(x), hols, to_core);\n      return Let(name, expr, body);\n    case \"Ann\":\n      if (term.done === true) {\n        return canonicalize(term.expr, hols, to_core);\n      } else {\n        var expr = canonicalize(term.expr, hols, to_core);\n        var type = canonicalize(term.type, hols, to_core);\n        return Ann(false, expr, type);\n      }\n    case \"Loc\":\n      return canonicalize(term.expr, hols, to_core);\n    case \"Wat\":\n      throw () => \"Incomplete program.\";\n    case \"Hol\":\n      if (hols[term.name]) {\n        return canonicalize(hols[term.name](term.vals), hols, to_core);\n      } else {\n        throw () => \"Unfilled hole: \" + term.name + \".\";\n      }\n    case \"Cse\":\n      if (hols[term.name]) {\n        return canonicalize(build_cse(term, hols[term.name]), hols, to_core);\n      } else {\n        throw () => \"Incomplete case.\";\n      }\n    case \"Nat\":\n      if (to_core) {\n        var done = Ref(\"Nat.zero\");\n        for (var i = 0n; i < term.natx; i += 1n) {\n          done = App(false, Ref(\"Nat.succ\"), done);\n        }\n        return done;\n      } else {\n        return term;\n      };\n  case \"Chr\":\n    if (to_core) {\n      var done = Ref(\"Char.new\");\n      var ccod = term.chrx.charCodeAt(0);\n      for (var i = 0; i < 16; ++i) {\n        done = App(false, done, Ref(((ccod>>>(16-i-1))&1) ? \"Bit.1\" : \"Bit.0\"));\n      };\n      return done;\n    } else {\n      return term;\n    };\n  case \"Str\":\n    if (to_core) {\n      var done = Ref(\"String.nil\");\n      for (var i = 0; i < term.strx.length; ++i) {\n        var chr = canonicalize(Chr(term.strx[term.strx.length-i-1]), hols, to_core);\n        done = App(false, App(false, Ref(\"String.cons\"), chr), done);\n      }\n      return done;\n    } else {\n      return term;\n    }\n  };\n};\n\n// Equality\n// ========\n\n// Computes the hash of a term. JS strings are hashed, so we just return one.\nfunction hash(term, dep = 0) {\n  switch (term.ctor) {\n    case \"Var\":\n      var indx = Number(term.indx.split(\"#\")[1]);\n      //console.log(\"ue\", indx);\n      if (indx < 0) {\n        return \"^\"+(dep+indx);\n      } else {\n        return \"#\"+indx;\n      }\n    case \"Ref\":\n      return \"$\" + term.name;\n    case \"Typ\":\n      return \"Type\";\n    case \"All\":\n      var bind = hash(term.bind, dep);\n      var body = hash(term.body(Var(\"#\"+(-dep-1)), Var(\"#\"+(-dep-2))), dep+2);\n      return \"\" + term.self + bind + body;\n    case \"Lam\":\n      var body = hash(term.body(Var(\"#\"+(-dep-1))), dep+1);\n      return \"\" + body;\n    case \"App\":\n      var func = hash(term.func, dep);\n      var argm = hash(term.argm, dep);\n      return \"@\" + func + argm;\n    case \"Let\":\n      var expr = hash(term.expr, dep);\n      var body = hash(term.body(Var(\"#\"+(-dep-1))), dep+1);\n      return \"$\" + expr + body;\n    case \"Ann\":\n      var expr = hash(term.expr, dep);\n      return expr;\n    case \"Loc\":\n      var expr = hash(term.expr, dep);\n      return expr;\n    case \"Wat\":\n      return \"?\" + term.name;\n    case \"Hol\":\n      return \"_\" + term.name;\n    case \"Cse\":\n      return \"-\"+Math.random();\n    case \"Nat\":\n      return \"{\"+term.natx+\"}\";\n    case \"Chr\":\n      return \"'\"+term.chrx+\"'\";\n    case \"Str\":\n      return '\"'+term.strx+'\"';\n  }\n};\n\n//var COUNT = 0;\n// Are two terms equal?\nfunction equal(a, b, defs, hols, dep = 0, rec = {}) {\n  //console.log(\"eq\", stringify(a), stringify(b));\n  let a1 = reduce(a, defs, hols, true);\n  let b1 = reduce(b, defs, hols, true);\n  var ah = hash(a1);\n  var bh = hash(b1);\n  var id = ah + \"==\" + bh;\n  if (ah === bh || rec[id]) {\n    return true;\n  } else {\n    rec[id] = true;\n    switch (a1.ctor + b1.ctor) {\n      case \"AllAll\":\n        var a1_body = a1.body(Var(a1.self+\"#\"+(dep)), Var(a1.name+\"#\"+(dep+1)));\n        var b1_body = b1.body(Var(a1.self+\"#\"+(dep)), Var(a1.name+\"#\"+(dep+1)));\n        return a1.eras === b1.eras\n            && a1.self === b1.self\n            && equal(a1.bind, b1.bind, defs, hols, dep+0, rec)\n            && equal(a1_body, b1_body, defs, hols, dep+2, rec);\n      case \"LamLam\":\n        if (a1.eras !== b1.eras) return [false,a1,b1];\n        var a1_body = a1.body(Var(a1.name+\"#\"+(dep)));\n        var b1_body = b1.body(Var(a1.name+\"#\"+(dep)));\n        return a1.eras === b1.eras\n            && equal(a1_body, b1_body, defs, hols, dep+1, rec);\n      case \"AppApp\":\n        return a1.eras === b1.eras\n            && equal(a1.func, b1.func, defs, hols, dep, rec)\n            && equal(a1.argm, b1.argm, defs, hols, dep, rec);\n      case \"LetLet\":\n        var a1_body = a1.body(Var(a1.name+\"#\"+(dep)));\n        var b1_body = b1.body(Var(a1.name+\"#\"+(dep)));\n        vis.push([a1.expr, b1.expr, dep]);\n        vis.push([a1_body, b1_body, dep+1]);\n        return equal(a1.expr, b1.expr, defs, hols, dep+0, rec)\n            && equal(a1_body, b1_body, defs, hols, dep+1, rec);\n      case \"AnnAnn\":\n        return equal(a1.expr, b1.expr, defs, hols, dep, rec);\n      case \"LocLoc\":\n        return equal(a1.expr, b1.expr, defs, hols, dep, rec);\n      default:\n        if (a1.ctor === \"Hol\") {\n          throw [a1.name, b];\n        } else if (b1.ctor === \"Hol\") {\n          throw [b1.name, a]\n        } else {\n          return false;\n        }\n    }\n  };\n};\n\n// Diagonalization\n// ===============\n\nfunction wide(next, then) {\n  return {ctor: \"call\", deep: false, next, then};\n};\n\nfunction deep(next, then) {\n  return {ctor: \"call\", deep: true, next, then};\n};\n\nfunction fail(msge) {\n  return {ctor: \"fail\", msge};\n};\n\nfunction done(retr) {\n  return {ctor: \"done\", retr};\n};\n\nfunction exec(fn) {\n  var wides = [[fn(), {ctor:\"Nil\"}]];\n  var deeps = [];\n  var index = 0;\n  var error = null;\n  while (index < wides.length || deeps.length > 0) {\n    if (deeps.length > 0) {\n      var got = deeps.pop();\n    } else {\n      var got = wides[index];\n      wides[index++] = null;\n    };\n    if (got) {\n      var [func, cont] = got;\n      switch (func.ctor) {\n        case \"done\":\n          switch (cont.ctor) {\n            case \"Nil\":\n              return func.retr;\n            case \"Ext\":\n              deeps.push([cont.head(func.retr), cont.tail]);\n              break;\n          }\n          break;\n        case \"fail\":\n          error = func.msge;\n          break;\n        case \"call\":\n          if (func.deep) {\n            for (let i = func.next.length - 1; i >= 0; --i) {\n              var next = func.next[i][0](...func.next[i][1]);\n              deeps.push([next, {ctor:\"Ext\",head:func.then,tail:cont}]);\n            }\n          } else {\n            for (let i = 0; i < func.next.length; ++i) {\n              var next = func.next[i][0](...func.next[i][1]);\n              wides.push([next, {ctor:\"Ext\",head:func.then,tail:cont}]);\n            }\n          };\n      };\n    };\n  };\n  throw error || \"Search failed.\";\n};\n\n// Type-Checking\n// =============\n\nfunction Err(loc, ctx, msg) {\n  return {\n    loc: loc,\n    ctx: ctx,\n    msg: msg,\n  };\n};\n\nfunction typeinfer(term, defs, show = stringify, hols = {}, ctx = Nil(), locs = null) {\n  switch (term.ctor) {\n    case \"Var\":\n      return \"{\" + done([hols, Var(term.indx)]) + \"}\";\n    case \"Ref\":\n      var got = defs[term.name];\n      if (got) {\n        if (got.core === undefined) {\n          var typ = typesynth(term.name, defs, show).type;\n        } else if (defs[term.name].core === null) {\n          var typ = defs[term.name].type;\n        } else {\n          var typ = defs[term.name].core.type;\n        }\n        return done([hols, typ]);\n      } else {\n        return fail(() => Err(locs, ctx, \"Undefined reference '\" + term.name + \"'.\"));\n      }\n    case \"Typ\":\n      return done([hols, Typ()]);\n    case \"All\":\n      var self_var = Ann(true, Var(term.self+\"#\"+ctx.size), term);\n      var name_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), term.bind);\n      var body_ctx = Ext({name:term.self,type:self_var.type}, ctx);\n      var body_ctx = Ext({name:term.name,type:name_var.type}, body_ctx);\n      return (\n        deep([[typecheck, [term.bind, Typ(), defs, show, hols, ctx, locs]]], ([hols,_]) =>\n        deep([[typecheck, [term.body(self_var,name_var), Typ(), defs, show, hols, body_ctx, locs]]], ([hols,_]) =>\n        done([hols, Typ()]))));\n    case \"App\":\n      return deep([[typeinfer, [term.func, defs, show, hols, ctx, locs]]], ([hols, func_typ]) => {\n        var func_typ = reduce(func_typ, defs, hols, false);\n        switch (func_typ.ctor) {\n          case \"All\":\n            var self_var = Ann(true, term.func, func_typ);\n            var name_var = Ann(true, term.argm, func_typ.bind);\n            return deep([[typecheck, [term.argm, func_typ.bind, defs, show, hols, ctx, locs]]], ([hols, _]) => {\n              var term_typ = func_typ.body(self_var, name_var);\n              if (func_typ.ctor === \"All\" && term.eras !== func_typ.eras) {\n                return fail(() => Err(locs, ctx, \"Mismatched erasure.\"));\n              };\n              return done([hols, term_typ]);\n            });\n          case \"Hol\":\n            var nam0 = new_name();\n            var nam1 = new_name();\n            var hols = {...hols, [func_typ.name]: (vals) => {\n              var all_bind = Hol(nam0, vals);\n              var all_body = (s,x) => Hol(nam1, Ext(x, Ext(s, vals)));\n              var all_term = All(term.eras, \"\", \"x\", all_bind, all_body);\n              return all_term;\n            }};\n            return deep([[typeinfer, [term, defs, show, hols, ctx, locs]]], done);\n          default:\n            return fail(() => Err(locs, ctx, \"Non-function application.\"));\n        };\n      });\n    case \"Let\":\n      return deep([[typeinfer, [term.expr, defs, show, hols, ctx, locs]]], ([hols, expr_typ]) => {\n        var expr_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), expr_typ);\n        var body_ctx = Ext({name:term.name,type:expr_var.type}, ctx);\n        return deep([[typeinfer, [term.body(expr_var), defs, show, hols, body_ctx, locs]]], ([hols, body_typ]) => {\n          return done([hols, body_typ]);\n        })\n      });\n    case \"Ann\":\n      if (!term.done) {\n        return deep([[typecheck, [term.expr, term.type, defs, show, hols, ctx, locs]]], ([hols, _]) => {\n          return done([hols, term.type]);\n        });\n      } else {\n        return done([hols, term.type]);\n      }\n    case \"Loc\":\n      var locs = {from: term.from, upto: term.upto};\n      return deep([[typeinfer, [term.expr, defs, show, hols, ctx, locs]]], done);\n    case \"Hol\":\n      var nam0 = new_name();\n      var hols = {...hols, [term.name]: (vals) => Ann(false, Hol(term.name, vals), Hol(nam0, vals))};\n      return done([hols, Hol(nam0, term.vals)]);\n    case \"Cse\":\n      return deep([[typeinfer, [term.func, defs, show, hols, ctx, locs]]], ([hols, func_typ]) => {\n        var func_typ = reduce(func_typ, defs, hols, false);\n        var hols = {...hols, [term.name]: func_typ};\n        var term_val = build_cse(term, func_typ);\n        return deep([[typeinfer, [term_val, defs, show, hols, ctx, locs]]], done);\n      });\n    case \"Nat\":\n      return done([hols, Ref(\"Nat\")]);\n    case \"Chr\":\n      return done([hols, Ref(\"Char\")]);\n    case \"Str\":\n      return done([hols, Ref(\"String\")]);\n  };\n  return fail(() => Err(locs, ctx, \"Can't infer type.\"));\n};\n\nfunction typecheck(term, type, defs, show = stringify, hols = {}, ctx = Nil(), locs = null) {\n  var typv = reduce(type, defs, hols, false);\n  switch (term.ctor) {\n    case \"Lam\":\n      if (typv.ctor === \"All\") {\n        var self_var = Ann(true, term, type);\n        var name_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), typv.bind);\n        var body_typ = typv.body(self_var, name_var);\n        if (term.eras !== typv.eras) {\n          return fail(() => Err(locs, ctx, \"Type mismatch.\"));\n        };\n        var body_ctx = Ext({name:term.name,type:name_var.type}, ctx);\n        return (\n          deep([[typecheck, [term.body(name_var), body_typ, defs, show, hols, body_ctx, locs]]], ([hols, _]) =>\n          done([hols, type])));\n      } else if (typv.ctor === \"Hol\") {\n        var nam0 = new_name();\n        var nam1 = new_name();\n        var hols = {...hols, [typv.name]: (vals) => {\n          var all_bind = Hol(nam0, vals);\n          var all_body = (s,x) => Hol(nam1, Ext(x, Ext(s, vals)));\n          var all_term = All(term.eras, \"\", \"x\", all_bind, all_body);\n          return all_term;\n        }};\n        return deep([[typecheck, [term, type, defs, show, hols, ctx, locs]]], done);\n      } else {\n        return fail(() => Err(locs, ctx, \"Lambda has a non-function type.\"));\n      }\n    case \"Let\":\n      return deep([[typeinfer, [term.expr, defs, show, hols, ctx, locs]]], ([hols, expr_typ]) => {\n        var expr_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), expr_typ);\n        var body_ctx = Ext({name:term.name,type:expr_var.type}, ctx);\n        return deep([[typecheck, [term.body(expr_var), type, defs, show, hols, body_ctx, locs]]], ([hols, _]) => {\n          return done([hols, type]);\n        });\n      });\n    case \"Loc\":\n      var locs = {from: term.from, upto: term.upto};\n      return deep([[typecheck, [term.expr, type, defs, show, hols, ctx, locs]]], ([hols, _]) => {\n        return done([hols, type]);\n      });\n    case \"Hol\":\n      // Registers this hole as unfilled\n      if (!hols[term.name]) {\n        hols[term.name] = null;\n      };\n\n      // If we try to type-check a hole and it is of type `(x : A) -> B`, we\n      // first try keeping it as it is. If that doesn't work, then we specialize\n      // it as `(x) ?` and try again.\n      if (typv.ctor === \"All\") {\n        var path0 = [() => done([hols,type]), []]\n        var nam1 = new_name();\n        var path1_hols = {...hols, [term.name]: (vals) => {\n          return Lam(typv.eras, typv.name||(\"x\"+ctx.size), x => Hol(nam1, Ext(x, vals)));\n        }};\n        var path1 = [typecheck, [path1_hols[term.name](term.vals), type, defs, show, path1_hols, ctx, locs]];\n        return deep([path0, path1], ([hols, _]) => done([hols,type]));\n\n      // If the hole is avariable or an application, then it could possibly be\n      // generated by the variables in the scope of the hole. For example, if a\n      // hole `?x : A` has the following variables in scope:\n      // - f : A -> A\n      // - g : A -> A -> A\n      // - h : A -> B\n      // - i : A -> A -> B\n      // - x : A\n      // - y : A\n      // Then `x`, `y`, `f(x)`, `f(f(x))`, `g(x)(y)`, and other combinations\n      // could be used to fill the hole. As such, we specialize the hole to 4\n      // alternatives: `{(f _), (g _ _), x, y}`, and start a wide search to see\n      // if any of those work. We don't include `h(_)` since the type returned\n      // by `h` is `B`, so it wouldn't be right. TODO: usage information to\n      // shrink search space on linear variables?\n      } else if (typv.ctor === \"App\" || typv.ctor === \"Var\") {\n        var new_hols = [];\n        //console.log(\"----------------\", show(typv));\n        fold(term.vals, i => null, (val, cont) => i => {\n          // Get the return type of the context variable\n          var cmp0 = reduce(val.type, defs, hols, false);\n          var cmp1 = typv;\n          while (cmp0.ctor === \"All\") { cmp0 = reduce(cmp0.body(Ref(\"^\"), Ref(\"^\")), {}); }\n          while (cmp0.ctor === \"App\") { cmp0 = reduce(cmp0.func, {}); }\n          while (cmp1.ctor === \"App\") { cmp1 = reduce(cmp1.func, {}); }\n          //console.log(\"cmp0\", show(cmp0));\n          //console.log(\"cmp1\", show(cmp1));\n          // Checks if it is compatible with the hole's type\n          try {\n            var is_compatible = equal(cmp0, cmp1, defs, {});\n          } catch (e) {\n            var is_compatible = true;\n          }\n          //console.log(\"- \", show(val.expr), \":\", show(val.type), \"|\", is_compatible);\n          //is_compatible = true;\n          // If so, specialize the hole as this var applied to other holes\n          if (is_compatible) {\n            var nam0 = new_name();\n            new_hols.push({...hols, [term.name]: (vals) => {\n              var hole = at(vals, i);\n              var type = reduce(val.type, defs, hols, false);\n              var arit = 0; \n              while (type.ctor === \"All\") {\n                hole = App(type.eras, hole, Hol(nam0 + (arit++), vals));\n                type = reduce(type.body(Ref(\"^\"),Ref(\"^\")), defs, hols, false);\n              };\n              return hole;\n            }});\n          };\n          cont(i + 1);\n        })(0);\n        var wides = new_hols.map((hols,i) => {\n          return [typecheck, [hols[term.name](term.vals), type, defs, show, hols, ctx, locs]];\n        });\n        return wide(wides, ([hols,_]) => done([hols, type]));\n\n      // Otherwise, we don't have any useful information, so we just keep it\n      } else {\n        return done([hols, type]);\n      };\n    case \"Wat\":\n      var ctx = fold(ctx, Nil(), ({name,type}, ctx) => {\n        var type = normalize(type, {}, hols, true);\n        return Ext({name,type}, ctx);\n      });\n      var err = Err(locs, ctx,\n        \"\\x1b[1mHole \\x1b[4m\"+term.name+\"\\x1b[0m\\x1b[1m:\\x1b[0m\\n\" +\n        \"With type: \"+show(normalize(type,{},hols,true),ctx));\n      var msg = require(\"./FormalityLang.js\").stringify_err(err, null).replace(/\\n*$/g,\"\");\n      HOLE_LOGS[term.name] = msg;\n      return done([hols, type]);\n    default:\n      return deep([[typeinfer, [term, defs, show, hols, ctx, locs]]], ([hols, infr]) => {\n        try {\n          var eq = equal(type, infr, defs, hols, ctx.size);\n          if (!eq) {\n            return fail(() => {\n              var type0_str = show(normalize(type, {}, hols, true), ctx);\n              var infr0_str = show(normalize(infr, {}, hols, true), ctx);\n              var err_ctx = fold(ctx, Nil(), ({name,type}, ctx) => {\n                var type = normalize(type, {}, hols, true);\n                return Ext({name,type}, ctx);\n              });\n              return Err(locs, err_ctx,\n                \"Found type... \\x1b[2m\"+infr0_str+\"\\x1b[0m\\n\" +\n                \"Instead of... \\x1b[2m\"+type0_str+\"\\x1b[0m\")\n            });\n          } else {\n            return done([hols, type]);\n          }\n        // Equal filled a hole, so we try again\n        } catch (e) {\n          var hols = {...hols, [e[0]]: x => e[1]};\n          return deep([[typecheck, [term, type, defs, show, hols, ctx, locs]]], done);\n        };\n      });\n  };\n};\n\nfunction typesynth(name, defs, show = stringify) {\n  if (!defs[name].core) {\n    defs[name].core = null;\n    var term = defs[name].term;\n    var type = defs[name].type;\n    var [hols,_] = exec(() => \n      deep([[typecheck, [type, Typ(), defs, show, {}, Nil(), null]]], ([hols,_]) =>\n      deep([[typecheck, [term, type, defs, show, {}, Nil(), null]]], ([hols,type]) => {\n        for (var hol in hols) {\n          if (hols[hol] === null) {\n            return fail(() => Err(null, ctx, \"Unsolved hole: '\" + hol + \"'.\"));\n          }\n        }\n        return done([hols,type])\n      })));\n    var core_term = parse(stringify(canonicalize(term, hols)), 0, \"term\");\n    var core_type = parse(stringify(canonicalize(type, hols)), 0, \"term\");\n    defs[name].core = {term: core_term, type: core_type};\n  }\n  return defs[name].core;\n};\n\n// Names\n// =====\n\nfunction nth_name(n) {\n  var str = \"\";\n  ++n;\n  while (n > 0) {\n    --n;\n    str += String.fromCharCode(97 + n % 26);\n    n = Math.floor(n / 26);\n  }\n  return str;\n};\n\nvar name_count = 0;\nfunction new_name() {\n  return nth_name(name_count++).toUpperCase();\n};\n\nvar HOLE_LOGS = {};\n\nfunction clear_hole_logs() {\n  for (var key in HOLE_LOGS) {\n    delete HOLE_LOGS[key];\n  }\n};\n\nmodule.exports = {\n  Var,\n  Ref,\n  Typ,\n  All,\n  Lam,\n  App,\n  Let,\n  Ann,\n  Loc,\n  Wat,\n  Hol,\n  Cse,\n  Nat,\n  Chr,\n  Str,\n  Ext,\n  Nil,\n  find,\n  fold,\n  stringify,\n  parse,\n  build_cse,\n  build_nat,\n  unloc,\n  reduce,\n  normalize,\n  canonicalize,\n  hash,\n  equal,\n  Err,\n  new_name,\n  typeinfer,\n  typecheck,\n  typesynth,\n  HOLE_LOGS,\n  clear_hole_logs,\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","module.exports = {\n  comp: require(\"./FormalityComp.js\"),\n  lang: require(\"./FormalityLang.js\"),\n  core: require(\"./FormalityCore.js\"),\n  synt: require(\"./FormalitySynt.js\"),\n  comp: require(\"./FormalityComp.js\"),\n  tojs: require(\"./FormalityToJS.js\"),\n  optx: require(\"./FormalityOptx.js\"),\n  inet: require(\"./FormalityInet.js\"),\n};\n","var {\n  Var, Ref, Typ, All,\n  Lam, App, Let, Ann,\n  Loc, Ext, Nil, Wat,\n  Hol, Cse, Nat, Chr,\n  Str,\n  unloc,\n  reduce,\n  normalize,\n  Err,\n  typeinfer,\n  typecheck,\n  equal,\n  find,\n  fold,\n  new_name,\n  stringify: synt_stringify,\n} = require(\"./FormalitySynt.js\");\n\n// Parsing\n// =======\n\nfunction Tag(ctor, text) {\n  return {ctor, text};\n};\n\nfunction get_var(ctx, name, not_found) {\n  var got = find(ctx, (bnd, i) => bnd[0] === name);\n  if (!got) {\n    if (not_found) {\n      return not_found();\n    } else {\n      throw \"Unbound: \" + name + \".\";\n    }\n  } else {\n    return got.value[1];\n  }\n};\n\n// Is this a space character?\nfunction is_space(chr) {\n  return chr === \" \" || chr === \"\\t\" || chr === \"\\n\";\n};\n\n// Is this a name-valid character?\nfunction is_name(chr) {\n  var val = chr.charCodeAt(0);\n  return (val >= 46 && val < 47)   // .\n      || (val >= 48 && val < 58)   // 0-9\n      || (val >= 65 && val < 91)   // A-Z\n      || (val >= 95 && val < 96)   // _\n      || (val >= 97 && val < 123); // a-z\n};\n\n// Returns the first valid parser\nfunction choose(fns, err) {\n  for (var i = 0; i < fns.length; ++i) {\n    var parsed = fns[i]();\n    if (parsed !== null) {\n      return parsed;\n    }\n  };\n  return null;\n};\n\n// Chains two parsers\nfunction chain(a, fn) {\n  return a ? fn(a[0], a[1]) : null;\n};\n\n// Drop characters while a condition is met.\nfunction drop_while(cond, code, [indx,tags]) {\n  var drops = \"\";\n  while (indx < code.length && cond(code[indx])) {\n    if (tags) {\n      drops += code[indx];\n    }\n    indx++;\n  };\n  if (tags && drops.length > 0) {\n    tags = tags&&Ext(Tag(\"nul\",drops),tags);\n  }\n  return [indx, tags];\n};\n\n// Drop spaces\nfunction drop_spaces(code, [indx,tags]) {\n  return drop_while(is_space, code, [indx,tags]);\n};\n\n// Drops spaces and comments\nfunction next(code, [indx,tags]) {\n  while (true) {\n    var [indx,tags] = drop_spaces(code, [indx,tags]);\n    if (code[indx] === \"/\") {\n      var [indx,tags] = drop_while(c => c !== \"\\n\", code, [indx,tags]);\n    } else if (code[indx] === \"#\") {\n      var [indx,tags] = drop_while(c => c !== \"#\", code, [indx+1, tags&&Ext(Tag(\"nul\",\"#\"),tags)]);\n      indx += 1;\n      tags = tags&&Ext(Tag(\"nul\",\"#\"),tags);\n    } else {\n      break;\n    }\n  };\n  return [indx, tags];\n};\n\nfunction hole(name, xs) {\n  return Hol(name, fold(xs, Nil(), (h,t) => Ext(h[1],t)));\n};\n\nfunction parse_error(code, indx, expected, err) {\n  if (err) {\n    var expec = expected.replace(/\\n/g, \"<newline>\");\n    var found = (code[indx] || \"<end-of-file>\").replace(/\\n/g, \"<newline>\");\n    throw ( \"Parse error: expected \"+expec+\", found '\"+found+\"'.\\n\"\n          + highlight_code(code, indx, indx+1));\n  } else {\n    return null;\n  }\n};\n\n// Drops spaces and parses an exact string\nfunction parse_txt(code, [indx,tags], str, err = false) {\n  var txt = \"\";\n  while (str.length > 0 && indx < code.length) {\n    if (str[0] === code[indx]) {\n      txt += code[indx++];\n      str = str.slice(1);\n    } else {\n      break;\n    }\n  }\n  if (str.length === 0) {\n    return [[indx,tags&&Ext(Tag(\"txt\",txt),tags)], txt];\n  } else {\n    return parse_error(code, indx, \"'\"+str+\"'\", err);\n  }\n};\n\n// Parses one of two strings\nfunction parse_one(code, [indx,tags], ch0, ch1, err) {\n  return choose([\n    () => chain(parse_txt(code, [indx,tags], ch0, false), ([indx,tags],_) => [[indx,tags], false]),\n    () => chain(parse_txt(code, [indx,tags], ch1, err  ), ([indx,tags],_) => [[indx,tags], true]),\n  ]);\n};\n\nfunction parse_mny(parser) {\n  return function(code, [indx,tags], err = false) {\n    var parses = [];\n    var parsed = parser(code, [indx,tags], false);\n    while (parsed) {\n      var [[indx,tags], parse] = parsed;\n      parses.push(parse);\n      var parsed = parser(code, next(code, [indx,tags]), false);\n    };\n    return [[indx,tags], parses];\n  };\n};\n\n// Parses an optional value\nfunction parse_may(parser) {\n  return function(code, [indx,tags], err) {\n    var parsed = parser(code, [indx,tags], err);\n    if (parsed) {\n      return parsed;\n    } else {\n      return [[indx,tags], null];\n    }\n  }\n};\n\n// Parses an optional string\nfunction parse_opt(code, [indx,tags], str, err) {\n  return choose([\n    () => chain(parse_txt(code, [indx,tags], str, false), ([indx,tags],_) => [[indx,tags], true]),\n    () => [[indx,tags], false],\n  ]);\n};\n\n// Parses comma separated arguments `(x,y,z)` or `<x,y,z>`\nfunction parse_app_list(parser) {\n  return (code, [indx,tags], err) => {\n    var parse_next = (code, [indx,tags], err) =>\n      chain(parse_txt(code,next(code,[indx,tags]),\",\",err), ([indx,tags], skip) =>\n      chain(parser(code,[indx,tags],err), ([indx,tags], res) => \n      [[indx,tags], res]));\n    return (\n      chain(parse_one(code, [indx,tags], \"(\", \"<\", false), ([indx,tags], eras) =>\n      chain(parser(code, [indx,tags], false), ([indx,tags], init) =>\n      chain(parse_mny(parse_next)(code, [indx,tags], err), ([indx,tags], parses) =>\n      chain(parse_txt(code, next(code,[indx,tags]), eras ? \">\" : \")\", err), ([indx,tags], skip) =>\n      [[indx,tags], [eras, [init].concat(parses)]])))));\n  };\n};\n\n// parse binder `x: A`\nfunction parse_bnd(code, [indx,tags], err) {\n  return choose([\n    () => (\n      chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], name) =>\n      chain(parse_txt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n      chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], type) => \n      [[indx,tags], [name, type]]\n      )))),\n    () => (\n      chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], name) =>\n      chain(parse_txt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n      [[indx,tags], [name, null]]\n      ))),\n    ]);\n};\n\n// Parses a valid name, non-empty\nfunction parse_nam(code, [indx,tags], allow_empty = false, err = false, tag = \"nam\") {\n  var nam = \"\";\n  while (indx < code.length) {\n    if (is_name(code[indx])) {\n      nam += code[indx++];\n    } else {\n      break;\n    }\n  }\n  tags = tags&&Ext(Tag(tag,nam),tags);\n  if (nam.length > 0 || allow_empty) {\n    return [[indx,tags], nam];\n  } else {\n    parse_error(code, indx, \"a name\", err);\n  }\n};\n\n// Parses a parenthesis, `(<term>)`\nfunction parse_par(code, [indx,tags], err = false) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"(\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], term) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \")\", err), ([indx,tags], skip) =>\n    [[indx,tags], term]))));\n};\n\n// Parses a dependent function type, `(<name> : <term>) -> <term>`\nfunction parse_all(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], self) =>\n    chain(parse_app_list(parse_bnd)(code, [indx,tags], err), ([indx,tags], [eras,binds]) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"->\", err), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      var fold = (ctx,i) => {\n        let slf = i == 0 ? self : \"\";\n        let nam = binds[i][0];\n        let bnd = binds[i][1](ctx);\n        return ((i < binds.length - 1)\n          ? All(eras,slf,nam,bnd,(s,x) => fold(Ext([nam,x],Ext([slf,s],ctx)),i+1))\n          : All(eras,slf,nam,bnd,(s,x) => body(Ext([nam,x],Ext([slf,s],ctx)))));\n      };\n      return Loc(from, indx, fold(xs,0))\n    }])))))\n};\n\n// Parses a lambda, `(<name>) <term>`\nfunction parse_lam(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  var pnam = (c,i,e) => parse_nam(c,next(c,i),true,e)\n  var nam0 = new_name();\n  return (\n    chain(parse_app_list(pnam)(code, next(code, [indx,tags]), false), ([indx,tags], [eras, binds]) =>\n    chain(parse_trm(code, next(code,[indx,tags]), err), ([indx,tags], body) =>\n    [[indx,tags], (xs) => {\n       var fold = (ctx,i) =>\n         (i < binds.length - 1)\n         ? Lam(eras, binds[i], (x) => fold(Ext([binds[i],x],ctx),i+1))\n         : Lam(eras, binds[i], (x) => body(Ext([binds[i],x],ctx)))\n      return Loc(from, indx, fold(xs,0));\n    }])));\n};\n\n// Parses a named lambda, `<name>(<term>) => <term>`\nfunction parse_fun(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  var pnam = (c,i,e) => parse_nam(c,next(c,i),true,e)\n  return (\n    chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], self) =>\n    chain(parse_app_list(pnam)(code, next(code, [indx,tags]), false), ([indx,tags], [eras, binds]) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=>\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, next(code,[indx,tags]), err), ([indx,tags], body) =>\n    [[indx,tags], (xs) => {\n       var fold = (ctx,i) =>\n         (i < binds.length - 1)\n         ? Lam(eras, binds[i], (x) => fold(Ext([binds[i],x],ctx),i+1))\n         : Lam(eras, binds[i], (x) => body(Ext([binds[i],x],ctx)))\n      return Loc(from, indx, fold(xs,0))\n    }])))));\n};\n\n// Parses an arrow comment, `<name> => <term>`\nfunction parse_acm(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], self) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=>\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, next(code,[indx,tags]), err), ([indx,tags], term) =>\n    [[indx,tags], (xs) => Loc(from, indx, term(xs))]))));\n};\n\n// Parses a local definition, `let x = val; body`\nfunction parse_let(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_one(code, next(code, [indx,tags]), \"def \", \"let \", false), ([indx,tags], dups) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n    chain(parse_opt(code, next(code, [indx,tags]), \"=\", err), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], expr) =>\n    chain(parse_opt(code, [indx,tags], \";\", err), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      if (dups) {\n        var tbody = (x) => body(Ext([name,x],xs));\n        return Loc(from, indx, Let(name, expr(xs), tbody));\n      } else {\n        return body(Ext([name,expr(xs)],xs));\n      };\n    }])))))));\n};\n\n// Parses a monadic application of 4 args, `use a b c = x; y` ~> `x((a) (b) (c) (d) y)`\nfunction parse_us4(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"use \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam2) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam3) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      return Loc(from, indx,\n        App(false, func(xs),\n        Lam(false, nam0, (x) =>\n        Lam(false, nam1, (y) =>\n        Lam(false, nam2, (z) =>\n        Lam(false, nam3, (w) =>\n        body(Ext([nam3,w], Ext([nam2,z], Ext([nam1,y], Ext([nam0,x], xs)))))))))));\n    }])))))))));\n};\n\n// Parses a monadic application of 3 args, `use a b c = x; y` ~> `x((a) (b) (c) y)`\nfunction parse_us3(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"use \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam2) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      return Loc(from, indx,\n        App(false, func(xs),\n        Lam(false, nam0, (x) =>\n        Lam(false, nam1, (y) =>\n        Lam(false, nam2, (z) =>\n        body(Ext([nam2,z], Ext([nam1,y], Ext([nam0,x], xs)))))))));\n    }]))))))));\n};\n\n// Parses a monadic application of 2 args, `use a b = x; y` ~> `x((a) (b) y)`\nfunction parse_us2(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"use \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      return Loc(from, indx,\n        App(false, func(xs),\n        Lam(false, nam0, (x) =>\n        Lam(false, nam1, (y) =>\n        body(Ext([nam1,y], Ext([nam0,x], xs)))))));\n    }])))))));\n};\n\n// Parses a monadic application of 1 arg, `use a = x; y` ~> `x((a) y)`\nfunction parse_us1(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"use \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], name) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      return Loc(from, indx,\n        App(false, func(xs),\n        Lam(false, name, (x) =>\n        body(Ext([name,x],xs)))));\n    }]))))));\n};\n\n// Parses a monadic application of 0 args, `use x; y` ~> `x(y)`\nfunction parse_us0(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"use \"), ([indx,tags], skip) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], argm) =>\n    [[indx,tags], xs => {\n      return Loc(from, indx, App(false, func(xs), argm(xs)));\n    }])))));\n};\n\n// Parses a projection, `get a = x; y` ~> `x<() _>((a) y)`\nfunction parse_gt1(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"get \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], name) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) => {\n      var nam0 = new_name();\n      return [[indx,tags], xs => {\n        return Loc(from, indx,\n          App(false, App(true, func(xs), hole(nam0, xs)),\n          Lam(false, name, (x) =>\n          body(Ext([name,x],xs)))));\n      }]\n    }))))));\n};\n\n// Parses a projection of 2 elements, `get = x; y` ~> `x<() _>(y)`\nfunction parse_gt2(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"get \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) => {\n      var hol0 = new_name();\n      return [[indx,tags], xs => {\n        return Loc(from, indx,\n          App(false, App(true, func(xs), hole(hol0, xs)),\n          Lam(false, nam0, (x) =>\n          Lam(false, nam1, (y) =>\n          body(Ext([nam1,y], Ext([nam0,x], xs)))))));\n      }];\n    })))))));\n};\n\n// Parses a projection of 3 elements, `get = x; y` ~> `x<() _>(y)`\nfunction parse_gt3(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"get \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam2) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) => {\n      var hol0 = new_name();\n      return [[indx,tags], xs => {\n        return Loc(from, indx,\n          App(false, App(true, func(xs), hole(hol0, xs)),\n          Lam(false, nam0, (x) =>\n          Lam(false, nam1, (y) =>\n          Lam(false, nam2, (z) =>\n          body(Ext([nam2,z], Ext([nam1,y], Ext([nam0,x], xs)))))))));\n      }];\n    }))))))));\n};\n\n// Parses a projection of 4 elements, `get = x; y` ~> `x<() _>(y)`\nfunction parse_gt4(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"get \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam0) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam1) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam2) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false), ([indx,tags], nam3) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"=\"), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], func) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) => {\n      var hol0 = new_name();\n      return [[indx,tags], xs => {\n        return Loc(from, indx,\n          App(false, App(true, func(xs), hole(hol0, xs)),\n          Lam(false, nam0, (x) =>\n          Lam(false, nam1, (y) =>\n          Lam(false, nam2, (z) =>\n          Lam(false, nam3, (w) =>\n          body(Ext([nam3,w], Ext([nam2,z], Ext([nam1,y], Ext([nam0,x], xs)))))))))));\n      }];\n    })))))))));\n};\n\n// TODO: generic parser for N uses/gets instead of hard-coding N\n\n// Parses the type of types, `Type`\nfunction parse_typ(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"Type\", false), ([indx,tags], skip) =>\n    [[indx,tags], xs => Loc(from, indx, Typ())]));\n};\n\n// Parses an assumption, `?a`\nfunction parse_wat(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, [indx,tags], \"?\", false), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n    [[indx,tags], xs => Wat(name)])));\n};\n\n// Parses a hole that Formality will try to auto-complete, `_`\nfunction parse_hol(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, [indx,tags], \"_\", false), ([indx,tags], skip) => {\n      var nam0 = new_name();\n      return [[indx,tags], xs => hole(nam0, xs)];\n    }));\n};\n\n// Parses an case expression, `case x as t : m;` ~> `x<(t) m>`\nfunction parse_cse(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  function parse_bar(code, [indx, tags], err) {\n    return (\n      chain(parse_txt(code, next(code, [indx,tags]), \"|\", false), ([indx,tags], skip) =>\n      chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], term) =>\n      chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n      [[indx,tags], term]))));\n  };\n  function parse_mot(code, [indx, tags], err) {\n    return (\n      chain(parse_txt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n      chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], moti) => \n      chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n      [[indx,tags], moti]))));\n  };\n  function parse_wth(code, [indx, tags], err) {\n    return (\n      chain(parse_txt(code, next(code, [indx,tags]), \"with \", false), ([indx,tags], skip) =>\n      chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n      chain(parse_txt(code, next(code, [indx,tags]), \":\", err), ([indx,tags], skip) =>\n      chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], type) => \n      chain(parse_txt(code, next(code, [indx,tags]), \"=\", err), ([indx,tags], skip) =>\n      chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], term) => \n      chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n      [[indx,tags], [name,type,term]]))))))));\n  };\n  function parse_val(code, [indx, tags], err) {\n    return choose([\n      () => (\n        chain(parse_nam(code, next(code, [indx,tags]), false, false), ([indx,tags], name) =>\n        chain(parse_txt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n        [[indx,tags], [name, parsed_var(from, [indx,tags], name)]]))),\n      () => (\n        chain(parse_trm(code, next(code, [indx,tags]), false), ([indx,tags], func) =>\n        chain(parse_txt(code, next(code, [indx,tags]), \"as \", false), ([indx,tags], skip) =>\n        chain(parse_nam(code, next(code, [indx,tags]), true, false), ([indx,tags], name) =>\n        chain(parse_txt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n        [[indx,tags], [name, func]]))))),\n      () => (\n        chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], func) =>\n        chain(parse_txt(code, next(code, [indx,tags]), \":\", err), ([indx,tags], skip) =>\n        [[indx,tags], [\"self\", func]]))),\n    ]);\n  };\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"case \", false), ([indx,tags], skip) =>\n    chain(parse_val(code, next(code, [indx,tags]), err), ([indx,tags], cval) =>\n    chain(parse_mny(parse_wth)(code, [indx,tags], err), ([indx,tags], wths) =>\n    chain(parse_mny(parse_bar)(code, [indx,tags], err), ([indx,tags], bars) =>\n    chain(parse_may(parse_mot)(code, [indx,tags], err), ([indx,tags], moti) => {\n      var uniq_name = new_name();\n      var hole_name = new_name();\n      return [[indx,tags], xs => {\n        var [name, func] = cval;\n        var func_term = func(xs);\n        if (!moti) {\n          moti = xs => hole(hole_name, xs);\n        }\n        var func_moti = xs => (function go(i, xs) {\n          if (i === wths.length) {\n            return moti(xs);\n          } else {\n            var [wnam, wtyp, wter] = wths[i];\n            return All(false, \"\", wnam, wtyp(xs), (s,x) => go(i+1, Ext([wnam,x],Ext([\"\",s],xs))));\n          };\n        })(0, xs);\n        var func_bars = bars.map(bar => xs => (function go(i, xs) {\n          if (i === wths.length) {\n            return bar(xs);\n          } else {\n            var [wnam, wtyp, wter] = wths[i];\n            return Lam(false, wnam, (x) => go(i+1, Ext([wnam,x],xs)));\n          };\n        })(0, xs));\n        var term = Cse(name+\"#\"+uniq_name, func_term, [xs, [func_moti].concat(func_bars)]);\n        for (var [wnam, wtyp, wter] of wths) {\n          term = App(false, term, wter(xs));\n        };\n        return term;\n      }];\n    }))))));\n};\n\nfunction parse_ite(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"if \", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], cond) =>\n    chain(parse_opt(code, next(code, [indx,tags]), \"then\", err), ([indx,tags], skip) =>\n    chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], ctru) =>\n    chain(parse_opt(code, next(code, [indx,tags]), \"else\", err), ([indx,tags], skip) =>\n    chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], cfal) => {\n      var nam0 = new_name();\n      return [[indx,tags], xs => {\n        var term = cond(xs);\n        var term = App(true, term, Lam(false, \"\", x => hole(nam0, Ext([\"\",x],xs))));\n        var term = App(false, term, ctru(xs));\n        var term = App(false, term, cfal(xs));\n        return term;\n      }];\n    })))))));\n};\n\n// Parses the do-notation\nfunction parse_don(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  function parse_stt(mnam) {\n    return function parse_stt(code, [indx,tags], err) {\n      return choose([\n        () => // var x = expr; body\n          chain(parse_txt(code, next(code, [indx,tags]), \"var \", false), ([indx,tags], skip) =>\n          chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \"=\", err), ([indx,tags], skip) =>\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], expr) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n          chain(parse_stt(code, next(code, [indx,tags]), err), ([indx,tags], body) => {\n            var nam0 = new_name();\n            var nam1 = new_name();\n            return [[indx,tags], xs => {\n              var term = App(false, App(true, Ref(\"Monad.bind\"), Ref(mnam)), Ref(mnam+\".monad\"));\n              var term = App(true, term, hole(nam0, xs));\n              var term = App(true, term, hole(nam1, xs));\n              var term = App(false, term, expr(xs));\n              var term = App(false, term, Lam(false, name, (x) => body(Ext([name,x],xs))));\n              return term;\n            }];\n          })))))),\n        () => // return expr;\n          chain(parse_txt(code, next(code, [indx,tags]), \"return \", false), ([indx,tags], skip) =>\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], expr) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) => {\n            var nam0 = new_name();\n            return [[indx,tags], xs => {\n              var term = App(false, App(true, Ref(\"Monad.pure\"), Ref(mnam)), Ref(mnam+\".monad\"));\n              var term = App(true, term, hole(nam0, xs));\n              var term = App(false, term, expr(xs));\n              return term;\n            }];\n          }))),\n        () => // expr; body\n          chain(parse_trm(code, next(code, [indx,tags]), false), ([indx,tags], expr) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \";\", false), ([indx,tags], skip) =>\n          chain(parse_stt(code, next(code, [indx,tags]), false), ([indx,tags], body) => {\n            var nam0 = new_name();\n            var nam1 = new_name();\n            return [[indx,tags], xs => {\n              var term = App(false, App(true, Ref(\"Monad.bind\"), Ref(mnam)), Ref(mnam+\".monad\"));\n              var term = App(true, term, hole(nam0, xs));\n              var term = App(true, term, hole(nam1, xs));\n              var term = App(false, term, expr(xs));\n              var term = App(false, term, Lam(false, \"\", (x) => body(Ext([\"\",x],xs))));\n              return term;\n            }];\n          }))),\n        () => // expr;\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], expr) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) => {\n            return [[indx,tags], xs => {\n              return expr(xs);\n            }];\n          })),\n      ]);\n    };\n  };\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"do \"), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], mnam) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"{\", err), ([indx,tags], skip) =>\n    chain(parse_stt(mnam)(code, next(code, [indx,tags]), err), ([indx,tags], term) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"}\", err), ([indx,tags], skip) =>\n    [[indx,tags], xs => Loc(from, indx, term(xs))]))))));\n};\n\nfunction parsed_var(from, [indx,tags], name) {\n  return xs => {\n    if (tags && tags.head) tags.head.ctor = \"var\";\n    return Loc(from, indx, get_var(xs, name, () => {\n      if (/^[0-9]*$/.test(name)) {\n        if (tags && tags.head) tags.head.ctor = \"nat\";\n        return Nat(BigInt(name));\n      } else {\n        if (tags && tags.head) tags.head.ctor = \"ref\";\n        return Ref(name);\n      };\n    }));\n  };\n};\n\n// Parses variables, `<name>`\nfunction parse_var(code, [indx,tags], err = false) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_nam(code, next(code, [indx,tags]), false, false), ([indx,tags], name) => {\n      if (name.length === 0) {\n        return parse_error(code, indx, \"a variable\", err);\n      } else {\n        var tag_to_mutate = tags && tags.head;\n        return [[indx,tags], parsed_var(from, [indx,tags], name)]\n      };\n    }));\n};\n\n// Parses a single-line hole application, `<term>()`\nfunction parse_ia1(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"()\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      return [[indx,tags], xs => Loc(from, indx, App(false, func(xs), hole(nam0, xs)))]\n    }));\n};\n\n// Parses 1 implicit arguments, `f<>`\nfunction parse_ie1(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses 2 implicit arguments, `f<,>`\nfunction parse_ie2(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<,>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        var term = App(true, term, hole(nam1, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses 3 implicit arguments, `f<,,>`\nfunction parse_ie3(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<,,>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      var nam2 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        var term = App(true, term, hole(nam1, xs));\n        var term = App(true, term, hole(nam2, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses 4 implicit arguments, `f<,,,>`\nfunction parse_ie4(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<,,,>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      var nam2 = new_name();\n      var nam3 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        var term = App(true, term, hole(nam1, xs));\n        var term = App(true, term, hole(nam2, xs));\n        var term = App(true, term, hole(nam3, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses 5 implicit arguments, `f<,,,,>`\nfunction parse_ie5(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<,,,,>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      var nam2 = new_name();\n      var nam3 = new_name();\n      var nam4 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        var term = App(true, term, hole(nam1, xs));\n        var term = App(true, term, hole(nam2, xs));\n        var term = App(true, term, hole(nam3, xs));\n        var term = App(true, term, hole(nam4, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses 6 implicit arguments, `f<,,,,,>`\nfunction parse_ie6(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, [indx,tags], \"<,,,,,>\"), ([indx,tags], eras) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      var nam2 = new_name();\n      var nam3 = new_name();\n      var nam4 = new_name();\n      var nam5 = new_name();\n      return [[indx,tags], xs => {\n        var term = func(xs);\n        var term = App(true, term, hole(nam0, xs));\n        var term = App(true, term, hole(nam1, xs));\n        var term = App(true, term, hole(nam2, xs));\n        var term = App(true, term, hole(nam3, xs));\n        var term = App(true, term, hole(nam4, xs));\n        var term = App(true, term, hole(nam5, xs));\n        return Loc(from, indx, term);\n      }];\n    }));\n};\n\n// Parses a application `f(x,y,z) ~> f(x)(y)(z)`\nfunction parse_app(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_app_list(parse_trm)(code,[indx,tags],err), ([indx,tags], [eras,args]) =>\n      [[indx,tags], (xs) => {\n        var x = func(xs);\n        for (var i = 0; i < args.length; i++) {\n          x = App(eras,x,args[i](xs));\n        };\n        return Loc(from,indx,x);\n    }]));\n};\n\n// Parses a multi-line application, `<term> | <term>;`\nfunction parse_pip(code, [indx,tags], from, func, err) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"|\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], argm) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n    [[indx,tags], xs => Loc(from, indx, App(false, func(xs), argm(xs)))]))));\n};\n\n// Parses a non-dependent function type, `<term> -> <term>`\nfunction parse_arr(code, [indx,tags], from, bind, err) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"->\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], body) =>\n    [[indx,tags], xs => {\n      var tbind = bind(xs);\n      var tbody = (s,x) => body(Ext([\"\",x],Ext([\"\",s],xs)));\n      return Loc(from, indx, All(false, \"\", \"\", tbind, tbody));\n    }])));\n};\n\n// Parses an annotation, `<term> :: <term>`\nfunction parse_ann(code, [indx,tags], from, expr, err) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"::\", false), ([indx,tags], skip) =>\n    chain(parse_trm(code, [indx,tags], err), ([indx,tags], type) =>\n    [[indx,tags], xs => Loc(from, indx, Ann(false, expr(xs), type(xs)))])));\n};\n\n// Parses a char literal, 'f'\nfunction parse_chr(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"'\"), ([indx,tags], skip) =>\n    chain([[indx+1,tags&&Ext(Tag(\"chr\",code[indx]),tags)], code[indx]], ([indx,tags], chrx) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \"'\"), ([indx,tags], skip) =>\n    [[indx,tags], xs => Loc(from, indx, Ann(true, Chr(chrx), Ref(\"Char\")))]\n    ))));\n};\n\n// Parses a string literal, \"foo\"\nfunction parse_str(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"\\\"\"), ([indx,tags], skip) =>\n    chain((function go([indx,tags], slit) {\n      var strx = \"\";\n      while (code[indx] !== '\"') {\n        if (indx >= code.length) {\n          parse_error(code, indx, \"unterminated string literal\", true);\n        } else {\n          strx += code[indx++];\n        }\n      }\n      return [[indx+1,tags], Str(strx)];\n    })([indx,tags]), ([indx,tags], slit) =>\n    [[indx,tags], xs => Loc(from, indx, Ann(true, slit, Ref(\"String\")))])));\n};\n\n// Parses a list literal, `[a, b, c]` as a `List(A)`\nfunction parse_lst(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  function parse_els(code, [indx,tags], nam0) {\n    return chain(parse_opt(code, next(code, [indx,tags]), \"]\", false), ([indx,tags], done) => {\n      if (done) {\n        return [[indx,tags], xs => App(true, Ref(\"List.nil\"), hole(nam0, xs))];\n      } else {\n        return (\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], elem) =>\n          chain(parse_opt(code, next(code, [indx,tags]), \",\", false), ([indx,tags], skip) =>\n          chain(parse_els(code, next(code, [indx,tags]), nam0), ([indx,tags], tail) =>\n          [[indx,tags], xs => {\n            var term = Ref(\"List.cons\");\n            var term = App(true, term, hole(nam0, xs));\n            var term = App(false, term, elem(xs));\n            var term = App(false, term, tail(xs));\n            return term;\n          }]))));\n      }\n    });\n  };\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"[\", false), ([indx,tags], skip) => {\n      var nam0 = new_name();\n      return chain(parse_els(code, next(code, [indx,tags]), nam0), ([indx,tags], list) =>\n      [[indx,tags], xs => Loc(from, indx, list(xs))])\n    }));\n};\n\n// Parses a map literal, `{a: 1, b: 2, c: 3}` as a `List(Pair(A, B))`\nfunction parse_map(code, [indx,tags], err) {\n  var from = next(code, [indx,tags])[0];\n  function parse_els(code, [indx,tags], nam0, nam1) {\n    return chain(parse_opt(code, next(code, [indx,tags]), \"}\", false), ([indx,tags], done) => {\n      if (done) {\n        return [[indx,tags], xs => {\n          var Pair = Ref(\"Pair\");\n          var Pair = App(false, Pair, hole(nam0, xs));\n          var Pair = App(false, Pair, hole(nam1, xs));\n          return App(true, Ref(\"List.nil\"), Pair);\n        }];\n      } else {\n        return (\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], val0) =>\n          chain(parse_opt(code, next(code, [indx,tags]), \":\", false), ([indx,tags], skip) =>\n          chain(parse_trm(code, next(code, [indx,tags]), err), ([indx,tags], val1) =>\n          chain(parse_opt(code, next(code, [indx,tags]), \",\", false), ([indx,tags], skip) =>\n          chain(parse_els(code, next(code, [indx,tags]), nam0), ([indx,tags], tail) =>\n          [[indx,tags], xs => {\n            var pair = Ref(\"Pair.new\");\n            var pair = App(true, pair, hole(nam0, xs));\n            var pair = App(true, pair, hole(nam1, xs));\n            var pair = App(false, pair, val0(xs));\n            var pair = App(false, pair, val1(xs));\n            var Pair = Ref(\"Pair\");\n            var Pair = App(false, Pair, hole(nam0, xs));\n            var Pair = App(false, Pair, hole(nam1, xs));\n            var term = Ref(\"List.cons\");\n            var term = App(true, term, Pair);\n            var term = App(false, term, pair);\n            var term = App(false, term, tail(xs));\n            return term;\n          }]))))));\n      }\n    });\n  };\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"{\", false), ([indx,tags], skip) => {\n      var nam0 = new_name();\n      var nam1 = new_name();\n      return chain(parse_els(code, next(code, [indx,tags]), nam0, nam1), ([indx,tags], list) =>\n      [[indx,tags], xs => Loc(from, indx, list(xs))])\n    }));\n};\n\n// Parses a term\nfunction parse_trm(code, [indx = 0, tags = []], err) {\n  var [indx,tags] = next(code, [indx,tags]);\n  var from = indx;\n\n  // Parses the base term, trying each variant once\n  var base_parse = choose([\n    () => parse_all(code, [indx,tags], err),\n    () => parse_lam(code, [indx,tags], err),\n    () => parse_fun(code, [indx,tags], err),\n    () => parse_acm(code, [indx,tags], err),\n    () => parse_let(code, [indx,tags], err),\n    () => parse_us0(code, [indx,tags], err),\n    () => parse_us1(code, [indx,tags], err),\n    () => parse_us2(code, [indx,tags], err),\n    () => parse_us3(code, [indx,tags], err),\n    () => parse_us4(code, [indx,tags], err),\n    () => parse_gt1(code, [indx,tags], err),\n    () => parse_gt2(code, [indx,tags], err),\n    () => parse_gt3(code, [indx,tags], err),\n    () => parse_gt4(code, [indx,tags], err),\n    () => parse_par(code, [indx,tags], err),\n    () => parse_typ(code, [indx,tags], err),\n    () => parse_chr(code, [indx,tags], err),\n    () => parse_str(code, [indx,tags], err),\n    () => parse_lst(code, [indx,tags], err),\n    () => parse_map(code, [indx,tags], err),\n    () => parse_wat(code, [indx,tags], err),\n    () => parse_hol(code, [indx,tags], err),\n    () => parse_cse(code, [indx,tags], err),\n    () => parse_ite(code, [indx,tags], err),\n    () => parse_don(code, [indx,tags], err),\n    () => parse_var(code, [indx,tags], err),\n  ], err);\n\n  if (!base_parse && err) {\n    parse_error(code, indx, \"a term\", err);\n  } else if (!base_parse) {\n    return null;\n  } else {\n    // Parses postfix extensions, trying each variant repeatedly\n    var post_parse = base_parse;\n    while (true) {\n      var [[indx,tags], term] = post_parse;\n      post_parse = choose([\n        () => parse_ia1(code, [indx,tags], from, term, err),\n        () => parse_ie1(code, [indx,tags], from, term, err),\n        () => parse_ie2(code, [indx,tags], from, term, err),\n        () => parse_ie3(code, [indx,tags], from, term, err),\n        () => parse_ie4(code, [indx,tags], from, term, err),\n        () => parse_ie5(code, [indx,tags], from, term, err),\n        () => parse_ie6(code, [indx,tags], from, term, err),\n        () => parse_app(code, [indx,tags], from, term, err),\n        () => parse_pip(code, [indx,tags], from, term, err),\n        () => parse_arr(code, [indx,tags], from, term, err),\n        () => parse_ann(code, [indx,tags], from, term, err),\n      ], err);\n      if (!post_parse) {\n        return base_parse;\n      } else {\n        base_parse = post_parse;\n      }\n    }\n  }\n\n  return null;\n};\n\n// Parses a sequence of `<x: term, y: term...> (a: term, b: term...) ...`.\n// Returns a list of erasure/bind/term: `[{eras:bool, name:text, term:term}]`.\nfunction parse_bds(code, [indx,tags], err) {\n  var parser = parse_mny(parse_app_list(parse_bnd));\n  return chain(parser(code, next(code, [indx,tags]), err), ([indx,tags], bnds) => {\n    // [(bool,[(string,term)])] -> [(bool,string,term)]\n    var flat_bnds = [];\n    for (var i = 0; i < bnds.length; ++i) {\n      for (var j = 0; j < bnds[i][1].length; ++j) {\n        flat_bnds.push({\n          eras: bnds[i][0],\n          name: bnds[i][1][j][0],\n          term: bnds[i][1][j][1]\n        });\n      }\n    }\n    return [[indx,tags], flat_bnds];\n  });\n};\n\n// Parses a sequence of `<term, term...> (term, term...) ...`.\n// Returns a list of erasure/term: `[(bool, term)]`.\nfunction parse_ars(code, [indx,tags], err) {\n  var parser = parse_mny(parse_app_list(parse_trm));\n  return chain(parser(code, next(code, [indx,tags]), err), ([indx,tags], args) => {\n    // [(bool,[term])] -> [(bool, term)]\n    var flat_args = [];\n    for (var i = 0; i < args.length; ++i) {\n      for (var j = 0; j < args[i][1].length; ++j) {\n        flat_args.push({\n          eras: args[i][0], \n          term: args[i][1][j]\n        });\n      }\n    }\n    return [[indx,tags], flat_args];\n  });\n};\n\nfunction parse_ctr(code, [indx,tags], err) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"|\", false), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n    chain(parse_bds(code, next(code, [indx,tags]), err), ([indx,tags], fils) =>\n    chain(parse_opt(code, next(code, [indx,tags]), \"~\", err), ([indx,tags], skip) =>\n    chain(parse_ars(code, next(code, [indx,tags]), err), ([indx,tags], inds) =>\n    chain(parse_txt(code, next(code, [indx,tags]), \";\", err), ([indx,tags], skip) =>\n    [[indx,tags], {name, fils, inds}]\n    )))))));\n};\n\nfunction parse_adt(code, [indx,tags], err) {\n  return (\n    chain(parse_txt(code, next(code, [indx,tags]), \"T \", false), ([indx,tags], skip) =>\n    chain(parse_nam(code, next(code, [indx,tags]), false, err), ([indx,tags], name) =>\n    chain(parse_bds(code, next(code, [indx,tags]), err), ([indx,tags], pars) =>\n    chain(parse_opt(code, next(code, [indx,tags]), \"~\", err), ([indx,tags], hasi) => \n    chain(parse_bds(code, next(code, [indx,tags]), err), ([indx,tags], inds) =>\n    chain(parse_mny(parse_ctr)(code, next(code, [indx,tags]), err), ([indx,tags], ctrs) => {\n    return [[indx,tags], {name, pars, inds, ctrs}];\n    })))))));\n};\n\n// Parses a defs\nfunction parse(code, indx = 0, tags_list = Nil()) {\n  //var LOG = x => console.log(require(\"util\").inspect(x, {showHidden: false, depth: null}));\n  var defs = {};\n  function parse_defs(code, [indx,tags]) {\n    var [indx,tags] = next(code, [indx,tags]);\n    if (indx === code.length) {\n      return [indx,tags];\n    } else {\n      // Parses datatype definitions\n      var parsed_adt = parse_adt(code, [indx,tags], true);\n      if (parsed_adt) {\n        var [[indx,tags], adt] = parsed_adt;\n        defs[adt.name] = {\n          type: adt_type_type(adt),\n          term: adt_type_term(adt),\n        };\n        for (var c = 0; c < adt.ctrs.length; ++c) {\n          defs[adt.name+\".\"+adt.ctrs[c].name] = {\n            type: adt_ctor_type(adt, c),\n            term: adt_ctor_term(adt, c),\n          };\n        }\n        return parse_defs(code, [indx,tags]);\n      // Parses function definitions\n      } else {\n        return (\n          chain(parse_nam(code, next(code, [indx,tags]), false, true, \"def\"), ([indx,tags], name) =>\n          chain(parse_bds(code, next(code, [indx,tags]), false), ([indx,tags], bnds) =>\n          chain(parse_txt(code, next(code, [indx,tags]), \":\", true), ([indx,tags], skip) =>\n          chain(parse_trm(code, next(code, [indx,tags]), true), ([indx,tags], type) =>\n          chain(parse_trm(code, next(code, [indx,tags]), true), ([indx,tags], term) => {\n            defs[name] = {\n              type: def_type(bnds, type),\n              term: def_term(bnds, term),\n            };\n            return parse_defs(code, [indx,tags]);\n          }))))));\n      };\n    };\n  };\n  var [indx,tags_list] = parse_defs(code, [indx,tags_list]);\n  var tags = [];\n  if (tags_list) {\n    for (var def in defs) {\n      // This is an innofensive hack to improve tags. Since the parser doesn't\n      // track bound names and, instead, returns a `Ctx -> Term` which then add\n      // the names, we don't have the information of what names are variables and\n      // what names are references. To distinguish without complicating the\n      // parser, I just mutate the tag of a name inside `parse_var`, but, for the\n      // mutation to happen, we must make one recursive pass before returning the\n      // term, so we just call `synt_stringify` here. This mutates to tag of\n      // variables and references from `[\"nam\",name]` to `[\"var\",name]` or\n      // `[\"ref\",name]`, allowing hyperlinking on moonad.org. Since tags aren't\n      // essential, this can be just ignored in pure implementations.\n      synt_stringify(defs[def].term);\n      synt_stringify(defs[def].type);\n    }\n    while (tags_list.ctor === \"Ext\") {\n      tags.push(tags_list.head);\n      tags_list = tags_list.tail;\n    }\n    tags.reverse();\n  }\n  return {defs, indx, tags};\n};\n\n// Stringification\n// ===============\n\n// Stringifies a character literal\nfunction stringify_chr(chr) {\n  var val = 0;\n  for (var i = 0; i < 16; ++i) {\n    if (chr.ctor === \"App\" && chr.argm.ctor === \"Ref\") {\n      if (chr.argm.name === \"Bit.0\") {\n        val = val;\n        chr = chr.func;\n      } else if (chr.argm.name === \"Bit.1\") {\n        val = val | (1 << i);\n        chr = chr.func;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  };\n  if (chr.ctor === \"Ref\" && chr.name === \"Char.new\") {\n    return String.fromCharCode(val);\n  } else {\n    return null;\n  };\n};\n\n// Stringifies a string literal\nfunction stringify_str(term) {\n  if (term.ctor === \"Ref\" && term.name === \"String.nil\") {\n    return \"\";\n  } else if (term.ctor === \"App\"\n    && term.func.ctor === \"App\"\n    && term.func.func.ctor === \"Ref\"\n    && term.func.func.name === \"String.cons\") {\n    var chr = stringify_chr(term.func.argm);\n    if (chr !== null) {\n      return chr + stringify_str(term.argm);\n    } else {\n      return null;\n    }\n  }\n};\n\n// Stringifies a nat literal\nfunction stringify_nat(term) {\n  if (term.ctor === \"Ref\" && term.name === \"Nat.zero\") {\n    return \"0\";\n  } else if (term.ctor === \"App\"\n    && term.func.ctor === \"Ref\"\n    && term.func.name === \"Nat.succ\") {\n    var pred = stringify_nat(term.argm);\n    if (pred) {\n      return String(1 + Number(pred));\n    }\n  } else {\n    return null;\n  }\n};\n\nfunction match(pattern, term, ret = {}) {\n  if (typeof pattern === \"string\" && pattern[0] === \"$\") {\n    ret[pattern.slice(1)] = term;\n    return ret;\n  } else if (typeof pattern === \"object\" && typeof term === \"object\") {\n    for (var key in pattern) {\n      if (!match(pattern[key], term[key], ret)) {\n        return null;\n      }\n    }\n    return ret;\n  } else if (typeof pattern === \"string\" && typeof term === \"string\") {\n    return pattern === term ? ret : null;\n  } else if (typeof pattern === \"boolean\" && typeof term === \"boolean\") {\n    return pattern === term ? ret : null;\n  } else if (typeof pattern === \"number\" && typeof term === \"number\") {\n    return pattern === term ? ret : null;\n  } else {\n    return null;\n  }\n};\n\nfunction matching(term, patterns) {\n  for (var [pattern, then] of patterns) {\n    var got = match(pattern, term);\n    if (got) {\n      return then(got);\n    };\n  };\n  return null;\n};\n\n// List.cons<T>(a)(List.cons<T>(b)(List.nil<T>))\nfunction stringify_lst(term, type = null, vals = Nil()) {\n  var cons = App(false, App(false, App(true, Ref(\"List.cons\"), \"$type\"), \"$head\"), \"$tail\");\n  var nil  = App(true, Ref(\"List.nil\"), \"$type\");\n  return matching(term, [\n    [cons, ({type, head, tail}) => {\n      return stringify_lst(tail, type, Ext(head, vals));\n    }],\n    [nil, ({type}) => {\n      return \"[\"\n        + stringify_trm(type) + \";\"\n        + (vals.ctor === \"Nil\" ? \"\" : \" \")\n        + fold(vals, b=>\"\", (h,t) => b => (b ? \"\" : \", \")\n        + stringify_trm(h)+t(0))(1)\n        + \"]\";\n    }]\n  ]);\n};\n\n// Stringifies a term\nfunction stringify_trm(term) {\n  var lit;\n  if (lit = stringify_chr(term)) {\n    return \"'\"+lit+\"'\";\n  } else if (lit = stringify_str(term)) {\n    return \"\\\"\"+lit+\"\\\"\";\n  } else if (lit = stringify_lst(term)) {\n    return lit;\n  } else {\n    switch (term.ctor) {\n      case \"Var\":\n        return term.indx.split(\"#\")[0];\n      case \"Ref\":\n        return term.name;\n      case \"Typ\":\n        return \"Type\";\n      case \"All\":\n        var self = term.self;\n        var lpar = term.name === \"\" ? \"\" : (term.eras ? \"<\" : \"(\");\n        var name = term.name;\n        var colo = term.name === \"\" ? \"\" : \": \";\n        var bind = stringify_trm(term.bind);\n        var rpar = term.name === \"\" ? \"\" : (term.eras ? \">\" : \")\");\n        var body = stringify_trm(term.body(Var(self+\"#\"), Var(name+\"#\")));\n        if (term.bind.ctor === \"All\" && name === \"\") {\n          return self+lpar+name+colo+\"(\"+bind+\")\"+rpar+\" -> \"+body;\n        } else {\n          return self+lpar+name+colo+bind+rpar+\" -> \"+body;\n        }\n      case \"Lam\":\n        var name = term.name;\n        var lpar = term.eras ? \"<\" : \"(\";\n        var body = stringify_trm(term.body(Var(name+\"#\")));\n        var rpar = term.eras ? \">\" : \")\";\n        return lpar+name+rpar+\" \"+body;\n      case \"App\":\n        var func = stringify_trm(term.func);\n        var lpar = term.eras ? \"<\" : \"(\";\n        var argm = stringify_trm(term.argm);\n        var rpar = term.eras ? \">\" : \")\";\n        if (func[0] === \"(\") {\n          return \"(\"+func+\")\"+lpar+argm+rpar;\n        } else {\n          return func+lpar+argm+rpar;\n        }\n      case \"Let\":\n        var name = term.name;\n        var expr = stringify_trm(term.expr);\n        var body = stringify_trm(term.body(Var(name+\"#\")));\n        return \"let \"+name+\" = \"+expr+\"; \"+body;\n      case \"Ann\":\n        if (term.done) {\n          return stringify_trm(term.expr);\n        } else {\n          var expr = stringify_trm(term.expr);\n          var type = stringify_trm(term.type);\n          if (expr[0] === \"(\") {\n            return \"(\"+expr+\") :: \"+type;\n          } else {\n            return expr+\" :: \"+type;\n          }\n        }\n      case \"Loc\":\n        var expr = stringify_trm(term.expr);\n        return expr;\n      case \"Hol\":\n        return \"_\"+term.name; // +\"{\"+fold(term.vals,\"\",(h,t)=>stringify(h)+\";\"+t)+\"}\";\n      case \"Wat\":\n        return \"?\"+term.name;\n      case \"Nat\":\n        return \"\"+term.natx;\n      case \"Chr\":\n        return \"'\"+term.chrx+\"'\";\n      case \"Str\":\n        return '\"'+term.strx+'\"';\n    }\n  }\n};\n\n// Stringifies a term\nfunction stringify(term) {\n  return stringify_trm(unloc(term));\n};\n\n// Stringifies a context\nfunction stringify_ctx(ctx, text = \"\") {\n  switch (ctx.ctor) {\n    case \"Ext\":\n      var name = ctx.head.name;\n      var type = stringify(ctx.head.type, ctx.tail);\n      if (name.length > 0) {\n        var text = \"- \" + name + \" : \" + type + \"\\n\" + text;\n      }\n      return stringify_ctx(ctx.tail, text);\n    case \"Nil\":\n      return text;\n  };\n};\n\n// Stringifies all terms of a defs\nfunction stringify_defs(defs) {\n  var text = \"\";\n  for (var name in defs) {\n    var type = stringify(defs[name].type, Nil());\n    var term = stringify(defs[name].term, Nil());\n    text += name + \" : \" + type + \"\\n  \" + term + \"\\n\\n\";\n  }\n  return text;\n};\n\n// Errors\n// ======\n\nfunction highlight_code(code, from, to) {\n  var lines = [\"\"];\n  var from_line = 0;\n  var to_line = Infinity;\n  var err_line = null;\n  lines.push(\"\\x1b[2m     1| \\x1b[0m\");\n  for (var i = 0; i < code.length + 1; ++i) {\n    if (code[i] === \"\\n\") {\n      var line_num_str = (\"      \"+(lines.length)).slice(-6);\n      lines.push(\"\\x1b[2m\" + line_num_str + \"| \\x1b[0m\");\n    } else {\n      var chr = code[i] || \"<eof>\";\n      if (from <= i && i < to) {\n        if (err_line === null) {\n          err_line = lines.length - 1;\n        }\n        var chr = \"\\x1b[4m\\x1b[31m\" + chr + \"\\x1b[0m\";\n      } else {\n        var chr = \"\\x1b[2m\" + chr + \"\\x1b[0m\";\n      }\n      lines[lines.length - 1] += chr;\n    };\n    if (i === from) {\n      from_line = lines.length - 1;\n    };\n    if (i === to) {\n      to_line = lines.length - 1;\n    };\n  };\n  from_line = Math.max(from_line - 4, 1);\n  to_line = Math.min(to_line + 3, lines.length - 1);\n  err_line = err_line || (lines.length - 2);\n  var err = \"On line \" + err_line + \":\\n\";\n  var err = err + lines.slice(from_line, to_line).join(\"\\n\");\n  return err;\n};\n\nfunction stringify_err(err, code) {\n  if (code) {\n    code = code[code.length-1] !== \"\\n\" ? code+\"\\n\" : code;\n  }\n  var index = 0;\n  if (!err.ctx) {\n    if (__dirname.indexOf(\"vic/dev\") !== -1) {\n      return err;\n    } else {\n      return \"Undecidable.\";\n    }\n  } else {\n    var str = \"\";\n    str += err.msg+\"\\n\";\n    if (err.ctx.ctor !== \"Nil\") {\n      str += \"With context:\\n\";\n      str += stringify_ctx(err.ctx)\n        .replace(/\\n*$/g,\"\")\n        .split(\"\\n\")\n        .map(line => \"\\x1b[2m\"+line+\"\\x1b[0m\")\n        .join(\"\\n\");\n    };\n    str += \"\\n\";\n    if (err.loc && code) {\n      str += highlight_code(code, err.loc.from, err.loc.upto);\n    };\n  };\n  return str;\n};\n\n// Generics\n// ========\n\n// Datatype and constructor derivers. The example goes from:\n//   T Vector <A: Type>                       ~ (len: Nat)\n//   | nil                                    ~ (Nat.zero);\n//   | ext<len: Nat>(x: A, xs: Vector(A,len)) ~ (Nat.succ(len));\n// To:\n//   Vector (A: Type, len: Nat) : Type \n//     (A, len)\n//     self(P: Nat -> Vector(A, len) -> Type) ->\n//     (nil: P(Nat.zero)(Vector.nil<A>)) ->\n//     (ext: <len: Nat> -> (x: A, xs: Vector(A,len)) -> P(Nat.succ(len))(Vector.ext<A>(len)(x)(xs))) ->\n//     P(len)(self)\n\nfunction adt_type_type({name, pars, inds, ctrs}) {\n  return (function args(p, i, ctx) {\n    //console.log(\"args\", p, i, pars.length);\n    // {args(0)} = <A> {args(1)}\n    // {args(1)} = (len) {args(2)}\n    // {args(2)} = self(P : {motive(0)}) -> {ctors(0)}\n    if (p < pars.length) {\n      return All(false, \"\", pars[p].name, pars[p].term(ctx), (s,x) => args(p + 1, i, Ext([pars[p].name,x], ctx)));\n    } else if (i < inds.length) {\n      return All(false, \"\", inds[i].name, inds[i].term(ctx), (s,x) => args(p, i + 1, Ext([inds[i].name,x], ctx)));\n    } else {\n      return Typ();\n    }\n  })(0, 0, Nil());\n}\n\nfunction adt_type_term({name, pars, inds, ctrs}) {\n  return (function args(p, i, ctx) {\n    //console.log(\"args\", p, i, pars.length);\n    // {args(0)} = <A> {args(1)}\n    // {args(1)} = (len) {args(2)}\n    // {args(2)} = self(P : {motive(0)}) -> {ctors(0)}\n    if (p < pars.length) {\n      return Lam(false, pars[p].name, x => args(p + 1, i, Ext([pars[p].name,x], ctx)));\n    } else if (i < inds.length) {\n      return Lam(false, inds[i].name, x => args(p, i + 1, Ext([inds[i].name,x], ctx)));\n    } else {\n      return All(true, \"self_\"+name, \"P\",\n        // {motive(0)} = (len: Nat) -> {motive(1)}\n        // {motive(1)} = Vector(A, len) -> Type\n        (function motive(i, ctx) {\n          //console.log(\"motive\", i);\n          if (i < inds.length) {\n            return All(false, \"\", inds[i].name,\n              inds[i].term(ctx),\n              (s,x) => motive(i + 1, Ext([inds[i].name,x], Ext([\"\",s], ctx))));\n          } else {\n            var slf = Ref(name);\n            for (var P = 0; P < pars.length; ++P) {\n              slf = App(false, slf, get_var(ctx, pars[P].name));\n            }\n            for (var I = 0; I < inds.length; ++I) {\n              slf = App(false, slf, get_var(ctx, inds[I].name));\n            }\n            return All(false, \"\", \"self\", slf, (s,x) => Typ());\n          }\n        })(0, ctx),\n        // {ctors(0)} = (nil: {fields(0,0)}) -> {ctors(1)}\n        // {ctors(1)} = (ext: {fields(1,0)}) -> {ctors(2)}\n        // {ctors(2)} = P(len)(self)\n        (s,x) => (function ctors(i, ctx) {\n          //console.log(\"ctors\", i);\n          if (i < ctrs.length) {\n            // {fields(0,0)} = P(Nat.zero)(Vector.nil<A>)\n            // {fields(1,0)} = <len: Nat> ->\n            // {fields(1,1)} = (x: A) ->\n            // {fields(1,2)} = (xs: Vector(A, len)) ->\n            // {fields(1,3)} = P(Nat.succ(len))(Vector.ext<A>(len)(x)(xs))\n            return All(false, \"\", ctrs[i].name, (function fields(j, ctx) {\n              //console.log(\"fields\", i, j);\n              if (j < ctrs[i].fils.length) {\n                var t_eras = ctrs[i].fils[j].eras;\n                var t_name = ctrs[i].fils[j].name;\n                var t_bind = ctrs[i].fils[j].term(ctx);\n                var t_body = (s,x) => fields(j + 1, Ext([t_name,x], Ext([\"\",s], ctx)));\n                return All(t_eras, \"\", t_name, t_bind, t_body);\n              } else {\n                var ret = get_var(ctx, \"P\");\n                for (var I = 0; I < inds.length; ++I) {\n                  if (I < ctrs[i].inds.length) {\n                    ret = App(ctrs[i].inds[I].eras, ret, ctrs[i].inds[I].term(ctx));\n                  } else {\n                    throw \"Insufficient indices for constructor '\" + ctrs[i].name + \"'.\";\n                  }\n                }\n                var slf = Ref(name+\".\"+ctrs[i].name);\n                for (var P = 0; P < pars.length; ++P) {\n                  slf = App(true, slf, get_var(ctx, pars[P].name));\n                }\n                //for (var I = 0; I < inds.length; ++I) {\n                  //slf = App(false, slf, get_var(ctx, inds[I].name));\n                //}\n                for (var F = 0; F < ctrs[i].fils.length; ++F) {\n                  slf = App(ctrs[i].fils[F].eras, slf, get_var(ctx, ctrs[i].fils[F].name));\n                }\n                ret = App(false, ret, slf);\n                return ret;\n              }\n            })(0, ctx),\n            (s,x) => ctors(i + 1, Ext([ctrs[i].name, s], Ext([\"\", x], ctx))));\n          } else {\n            var ret = get_var(ctx, \"P\");\n            for (var I = 0; I < inds.length; ++I) {\n              ret = App(false, ret, get_var(ctx, inds[I].name));\n            }\n            ret = App(false, ret, get_var(ctx, \"self_\"+name));\n            return ret;\n          }\n        })(0, Ext([\"P\",x], Ext([\"self_\"+name,s], ctx))));\n    }\n  })(0, 0, Nil());\n};\n\nfunction adt_ctor_type({name, pars, inds, ctrs}, c) {\n  return (function arg(p, i, f, ctx) {\n    if (p < pars.length) {\n      var t_eras = true;\n      var t_self = \"\";\n      var t_name = pars[p].name;\n      var t_bind = pars[p].term(ctx);\n      var t_body = (s,x) => arg(p + 1, i, f, Ext([t_name,x],Ext([\"\",s],ctx)));\n      return All(t_eras, t_self, t_name, t_bind, t_body);\n    } else if (f < ctrs[c].fils.length) {\n      var t_eras = ctrs[c].fils[f].eras;\n      var t_self = \"\";\n      var t_name = ctrs[c].fils[f].name;\n      var t_bind = ctrs[c].fils[f].term(ctx);\n      var t_body = (s,x) => arg(p, i, f + 1, Ext([t_name,x],Ext([\"\",s],ctx)));\n      return All(t_eras, t_self, t_name, t_bind, t_body);\n    } else {\n      var type = Ref(name);\n      for (var P = 0; P < pars.length; ++P) {\n        type = App(false, type, get_var(ctx, pars[P].name));\n      }\n      for (var I = 0; I < inds.length; ++I) {\n        type = App(false, type, ctrs[c].inds[I].term(ctx));\n      }\n      return type;\n    }\n  })(0, inds.length, 0, Nil())\n};\n\nfunction adt_ctor_term({name, pars, inds, ctrs}, c) {\n  return (function arg(p, i, f, ctx) {\n    if (p < pars.length) {\n      var t_eras = true;\n      var t_name = pars[p].name;\n      var t_body = x => arg(p + 1, i, f, Ext([t_name,x],ctx));\n      return Lam(t_eras, t_name, t_body);\n    } else if (f < ctrs[c].fils.length) {\n      var t_eras = ctrs[c].fils[f].eras;\n      var t_name = ctrs[c].fils[f].name;\n      var t_body = x => arg(p, i, f + 1, Ext([t_name,x], ctx));\n      return Lam(t_eras, t_name, t_body);\n    } else {\n      return Lam(true, \"P\", x => (function opt(k, ctx) {\n        if (k < ctrs.length) {\n          var t_eras = false;\n          var t_name = ctrs[k].name;\n          var t_body = x => opt(k + 1, Ext([t_name,x], ctx));\n          return Lam(t_eras, t_name, t_body);\n        } else {\n          var ret = get_var(ctx, ctrs[c].name);\n          for (var F = 0; F < ctrs[c].fils.length; ++F) {\n            var t_eras = ctrs[c].fils[F].eras;\n            var t_func = ret;\n            var t_argm = get_var(ctx, ctrs[c].fils[F].name);\n            ret = App(t_eras, t_func, t_argm);\n          }\n          return ret;\n        }\n      })(0, Ext([\"P\",x],ctx)));\n    }\n  })(0, inds.length, 0, Nil());\n};\n\nfunction def_type(bnds, type) {\n  return (function go(i, ctx) {\n    if (i < bnds.length) {\n      let t_eras = bnds[i].eras;\n      let t_self = \"\";\n      let t_name = bnds[i].name;\n      let t_type = bnds[i].term(ctx);\n      let t_body = (s,x) => go(i+1, Ext([t_name,x],Ext([\"\",s],ctx)));\n      return All(t_eras, t_self, t_name, t_type, t_body);\n    } else {\n      return type(ctx);\n    };\n  })(0, Nil());\n};\n\nfunction def_term(bnds, term) {\n  return (function go(i, ctx) {\n    if (i < bnds.length) {\n      let t_eras = bnds[i].eras;\n      let t_name = bnds[i].name;\n      let t_body = x => go(i+1, Ext([t_name,x],ctx));\n      return Lam(t_eras, t_name, t_body);\n    } else {\n      return term(ctx);\n    };\n  })(0, Nil());\n};\n\nmodule.exports = {\n  is_space,\n  is_name,\n  choose,\n  chain,\n  drop_while,\n  drop_spaces,\n  next,\n  parse_app_list,\n  parse_error,\n  parse_txt,\n  parse_one,\n  parse_opt,\n  parse_nam,\n  parse_par,\n  parse_all,\n  parse_lam,\n  parse_let,\n  parse_us2,\n  parse_us1,\n  parse_us0,\n  parse_typ,\n  parse_var,\n  parse_app,\n  parse_pip,\n  parse_arr,\n  parse_ann,\n  parse_chr,\n  parse_str,\n  parse_trm,\n  parse,\n  unloc,\n  stringify_chr,\n  stringify_str,\n  stringify_nat,\n  stringify,\n  stringify_ctx,\n  stringify_defs,\n  highlight_code,\n  stringify_err,\n};\n","var fmc = require(\"./FormalitySynt.js\");\nvar fml = require(\"./FormalityLang.js\");\n\nconst Var = (name)           => ({ctor:\"Var\",name});\nconst Ref = (name)           => ({ctor:\"Ref\",name});\nconst Nul = ()               => ({ctor:\"Nul\"});\nconst Lam = (name,body)      => ({ctor:\"Lam\",name,body});\nconst App = (func,argm)      => ({ctor:\"App\",func,argm});\nconst Let = (name,expr,body) => ({ctor:\"Let\",name,expr,body});\nconst Eli = (prim,expr)      => ({ctor:\"Eli\",prim,expr});\nconst Ins = (prim,expr)      => ({ctor:\"Ins\",prim,expr});\nconst Chr = (chrx)           => ({ctor:\"Chr\",chrx});\nconst Str = (strx)           => ({ctor:\"Str\",strx});\nconst Nat = (natx)           => ({ctor:\"Nat\",natx});\n\nvar is_prim = {\n  Unit   : 1,\n  Bool   : 1,\n  Nat    : 1,\n  Bits   : 1,\n  U16    : 1,\n  U32    : 1,\n  U64    : 1,\n  F64    : 1,\n  String : 1\n};\n\nfunction as_adt(term, defs) {\n  var term = fmc.reduce(term, defs);\n  if (term.ctor === \"All\" && term.self !== \"\") {\n    var term = term.body(fmc.Var(\"self\"), fmc.Var(\"P\"));\n    var ctrs = [];\n    while (term.ctor === \"All\") {\n      var ctr = (function go(term, flds) {\n        if (term.ctor === \"All\") {\n          return go(term.body(fmc.Var(\"\"), fmc.Var(term.name)), flds.concat(term.name));\n        } else if (term.ctor === \"App\" && term.func.ctor === \"Var\" && term.func.indx === \"P\") {\n          var argm = term.argm;\n          while (argm.ctor === \"App\") {\n            argm = argm.func;\n          };\n          if (argm.ctor === \"Ref\") {\n            return {name: argm.name, flds: flds};\n          }\n        }\n        return null;\n      })(term.bind, []);\n      if (ctr) {\n        ctrs.push(ctr);\n        term = term.body(fmc.Var(term.self), fmc.Var(term.name));\n      } else {\n        return null;\n      }\n    }\n    return ctrs;\n  }\n  return null;\n};\n\nfunction dependency_sort(defs, main) {\n  var seen = {};\n  var refs = [];\n  function go(term) {\n    switch (term.ctor) {\n      case \"Ref\":\n        if (!seen[term.name]) {\n          seen[term.name] = true;\n          go(defs[term.name].term);\n          refs.push(term.name);\n        }\n        break;\n      case \"Lam\":\n        go(term.body(fmc.Var(term.name)));\n        break;\n      case \"App\":\n        go(term.func);\n        go(term.argm);\n        break;\n      case \"Let\":\n        go(term.expr);\n        go(term.body(fmc.Var(term.name)));\n        break;\n      case \"Ann\":\n        go(term.expr);\n        break;\n      case \"Loc\":\n        go(term.expr);\n        break;\n      case \"Nat\":\n        break;\n      case \"Chr\":\n        break;\n      case \"Str\":\n        break;\n      default:\n        break;\n    };\n  };\n  go(defs[main].term);\n  return refs;\n};\n\nfunction prim_of(type, defs) {\n  for (var prim in is_prim) {\n    if (fmc.equal(type, fmc.Ref(prim), defs)) {\n      return prim;\n    }\n  };\n  return null;\n};\n\n// Note:\n// The name of bound variables get a '$depth$' appended to it. This helps making\n// them unique, but also solves some issues where JavaScript shadowing behavior\n// differs from Formality. For example:\n// `foo = x => y => { var x = x * x; return x; }`\n// Here, calling `foo(2)(2)` would return `NaN`, not `4`, because the outer\n// value of `x` isn't accessible inside the function's body due to the\n// declaration of `x` using a `var` statement.\n\nfunction infer(term, defs, ctx = fmc.Nil()) {\n  switch (term.ctor) {\n    case \"Var\":\n      return {\n        comp: Var(term.indx.replace(\"#\",\"$\")),\n        type: fmc.Var(term.indx),\n      };\n    case \"Ref\":\n      var got_def = defs[term.name];\n      return {\n        comp: Ref(term.name),\n        type: got_def.type,\n      };\n    case \"Typ\":\n      return {\n        comp: Nul(),\n        type: fmc.Typ(),\n      };\n    case \"App\":\n      var func_cmp = infer(term.func, defs, ctx);\n      var func_typ = fmc.reduce(func_cmp.type, defs);\n      switch (func_typ.ctor) {\n        case \"All\":\n          var self_var = fmc.Ann(true, term.func, func_typ);\n          var name_var = fmc.Ann(true, term.argm, func_typ.bind);\n          var argm_cmp = check(term.argm, func_typ.bind, defs, ctx);\n          var term_typ = func_typ.body(self_var, name_var);\n          var comp = func_cmp.comp;\n\n          var func_typ_adt = as_adt(func_typ, defs);\n          var func_typ_prim = prim_of(func_typ, defs);\n          if (func_typ_prim) {\n            comp = Eli(func_typ_prim, comp);\n          } else if (func_typ_adt) {\n            comp = Eli(func_typ_adt, comp);\n          };\n          if (!term.eras) {\n            comp = App(comp, argm_cmp.comp);\n          }\n          return {comp, type: term_typ};\n        default:\n          throw \"Non-function application.\";\n      };\n    case \"Let\":\n      var expr_cmp = infer(term.expr, defs, ctx);\n      var expr_var = fmc.Ann(true, term.dups ? fmc.Var(term.name+\"#\"+(ctx.size+1)) : term.expr, expr_cmp.type);\n      var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);\n      var body_cmp = infer(term.body(expr_var), defs, body_ctx);\n      return {\n        comp: term.dups ? Let(term.name+\"$\"+(ctx.size+1), expr_cmp.comp, body_cmp.comp) : body_cmp.comp,\n        type: body_cmp.type,\n      };\n    case \"All\":\n      return {\n        comp: Nul(),\n        type: fmc.Typ(),\n      };\n    case \"Ann\":\n      return check(term.expr, term.type, defs, ctx);\n    case \"Loc\":\n      return infer(term.expr, defs, ctx);\n    case \"Nat\":\n      return {\n        comp: Nat(term.natx),\n        type: fmc.Ref(\"Nat\"),\n      };\n    case \"Chr\":\n      return {\n        comp: Chr(term.chrx),\n        type: fmc.Ref(\"Char\"),\n      };\n    case \"Str\":\n      return {\n        comp: Str(term.strx),\n        type: fmc.Ref(\"String\"),\n      };\n  }\n};\n\nfunction check(term, type, defs, ctx = fmc.Nil()) {\n  var typv = fmc.reduce(type, defs);\n\n  if (typv.ctor === \"Typ\") {\n    var comp = Nul();\n    var type = fmc.Typ();\n    return {comp, type};\n  };\n\n  var comp = null;\n  switch (term.ctor) {\n    case \"Lam\":\n      if (typv.ctor === \"All\") {\n        var self_var = fmc.Ann(true, term, type);\n        var name_var = fmc.Ann(true, fmc.Var(term.name+\"#\"+(ctx.size+1)), typv.bind);\n        var body_typ = typv.body(self_var, name_var);\n        var body_ctx = fmc.Ext({name:term.name,type:name_var.type}, ctx);\n        var body_cmp = check(term.body(name_var), body_typ, defs, body_ctx);\n        if (term.eras) {\n          comp = body_cmp.comp;\n        } else {\n          comp = Lam(term.name+\"$\"+(ctx.size+1), body_cmp.comp);\n        }\n\n        var type_adt = as_adt(type, defs);\n        var type_prim = prim_of(type, defs);\n        if (type_prim) {\n          comp = Ins(type_prim, comp);\n        } else if (type_adt) {\n          comp = Ins(type_adt, comp);\n        }\n      } else {\n        throw \"Lambda has non-function type.\";\n      }\n      return {comp, type};\n    case \"Let\":\n      var expr_cmp = infer(term.expr, defs, ctx);\n      var expr_var = fmc.Ann(true, term.dups ? fmc.Var(term.name+\"#\"+(ctx.size+1)) : term.expr, expr_cmp.type);\n      var body_ctx = fmc.Ext({name:term.name,type:expr_var.type}, ctx);\n      var body_cmp = check(term.body(expr_var), type, defs, body_ctx);\n      return {\n        comp: term.dups ? Let(term.name+\"$\"+(ctx.size+1), expr_cmp.comp, body_cmp.comp) : body_cmp.comp,\n        type: body_cmp.type,\n      };\n    case \"Loc\":\n      return check(term.expr, type, defs);\n    default:\n      var term_cmp = infer(term, defs, ctx);\n      var comp = term_cmp.comp;\n      return {comp, type};\n  };\n};\n\nfunction core_to_comp(defs, main) {\n  var comp_nams = dependency_sort(defs, main).concat([main]);\n  var comp_defs = {};\n  for (var name of comp_nams) {\n    //TODO: caution, using fml.unloc on fmc term; consider adding fmc.unloc\n    comp_defs[name] = check(fml.unloc(defs[name].term), fml.unloc(defs[name].type), defs).comp;\n  };\n  return {\n    defs: comp_defs,\n    nams: comp_nams,\n  };\n};\n\nmodule.exports = {\n  Var, Ref, Nul, Lam,\n  App, Let, Eli, Ins,\n  Chr, Str, Nat,\n  is_prim,\n  dependency_sort,\n  check,\n  infer,\n  core_to_comp,\n};\n","var ma=this;function oa(q){var w=0;return function(){return w<q.length?{done:!1,value:q[w++]}:{done:!0}}}var pa=\"function\"==typeof Object.defineProperties?Object.defineProperty:function(q,w,h){q!=Array.prototype&&q!=Object.prototype&&(q[w]=h.value)};function qa(q){q=[\"object\"==typeof window&&window,\"object\"==typeof self&&self,\"object\"==typeof global&&global,q];for(var w=0;w<q.length;++w){var h=q[w];if(h&&h.Math==Math)return h}throw Error(\"Cannot find global object\");}var ra=qa(this);\nfunction sa(){sa=function(){};ra.Symbol||(ra.Symbol=ta)}function ua(q,w){this.P=q;pa(this,\"description\",{configurable:!0,writable:!0,value:w})}ua.prototype.toString=function(){return this.P};var ta=function(){function q(h){if(this instanceof q)throw new TypeError(\"Symbol is not a constructor\");return new ua(\"jscomp_symbol_\"+(h||\"\")+\"_\"+w++,h)}var w=0;return q}();\nfunction Ea(q,w){if(w){var h=ra;q=q.split(\".\");for(var l=0;l<q.length-1;l++){var m=q[l];m in h||(h[m]={});h=h[m]}q=q[q.length-1];l=h[q];w=w(l);w!=l&&null!=w&&pa(h,q,{configurable:!0,writable:!0,value:w})}}Ea(\"Math.imul\",function(q){return q?q:function(w,h){w=Number(w);h=Number(h);var l=w&65535,m=h&65535;return l*m+((w>>>16&65535)*m+l*(h>>>16&65535)<<16>>>0)|0}});\nEa(\"Array.prototype.fill\",function(q){return q?q:function(w,h,l){var m=this.length||0;0>h&&(h=Math.max(0,m+h));if(null==l||l>m)l=m;l=Number(l);0>l&&(l=Math.max(0,m+l));for(h=Number(h||0);h<l;h++)this[h]=w;return this}});function Fa(q){var w=null;return function(){return w=w||q()}}\nvar Ga=Fa(function(){return function(q,w){w&&(q.fd=w,q.prototype=Object.create(w.prototype,{constructor:{value:q,enumerable:!1,writable:!0,configurable:!0}}))}}),Ha=Fa(function(){function q(a,b,g){var f=a.a,k=b.a,t=g.a,y=0,A=f[0]|0,C=A&8191,B=A>>>13,D=f[1]|0;A=D&8191;var K=D>>>13,E=f[2]|0;D=E&8191;var T=E>>>13,F=f[3]|0;E=F&8191;var X=F>>>13,G=f[4]|0;F=G&8191;var Y=G>>>13,H=f[5]|0;G=H&8191;var Z=H>>>13,I=f[6]|0;H=I&8191;var aa=I>>>13,J=f[7]|0;I=J&8191;var ba=J>>>13,U=f[8]|0;J=U&8191;U>>>=13;var V=\nf[9]|0;f=V&8191;V>>>=13;var L=k[0]|0,ca=L&8191,da=L>>>13,M=k[1]|0;L=M&8191;var ea=M>>>13,N=k[2]|0;M=N&8191;var fa=N>>>13,O=k[3]|0;N=O&8191;var ha=O>>>13,P=k[4]|0;O=P&8191;var ia=P>>>13,Q=k[5]|0;P=Q&8191;var ja=Q>>>13,R=k[6]|0;Q=R&8191;var ka=R>>>13,S=k[7]|0;R=S&8191;var la=S>>>13,W=k[8]|0;S=W&8191;W>>>=13;var na=k[9]|0;k=na&8191;na>>>=13;g.b=a.b^b.b;g.length=19;var p=c(C,ca);a=c(C,da);a=a+c(B,ca)|0;b=c(B,da);var va=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(va>>>26)|0;va&=67108863;p=c(A,ca);a=c(A,\nda);a=a+c(K,ca)|0;b=c(K,da);p=p+c(C,L)|0;a=a+c(C,ea)|0;a=a+c(B,L)|0;b=b+c(B,ea)|0;var wa=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(wa>>>26)|0;wa&=67108863;p=c(D,ca);a=c(D,da);a=a+c(T,ca)|0;b=c(T,da);p=p+c(A,L)|0;a=a+c(A,ea)|0;a=a+c(K,L)|0;b=b+c(K,ea)|0;p=p+c(C,M)|0;a=a+c(C,fa)|0;a=a+c(B,M)|0;b=b+c(B,fa)|0;var xa=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(xa>>>26)|0;xa&=67108863;p=c(E,ca);a=c(E,da);a=a+c(X,ca)|0;b=c(X,da);p=p+c(D,L)|0;a=a+c(D,ea)|0;a=a+c(T,L)|0;b=b+c(T,ea)|0;p=p+c(A,M)|0;a=a+c(A,\nfa)|0;a=a+c(K,M)|0;b=b+c(K,fa)|0;p=p+c(C,N)|0;a=a+c(C,ha)|0;a=a+c(B,N)|0;b=b+c(B,ha)|0;var ya=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(ya>>>26)|0;ya&=67108863;p=c(F,ca);a=c(F,da);a=a+c(Y,ca)|0;b=c(Y,da);p=p+c(E,L)|0;a=a+c(E,ea)|0;a=a+c(X,L)|0;b=b+c(X,ea)|0;p=p+c(D,M)|0;a=a+c(D,fa)|0;a=a+c(T,M)|0;b=b+c(T,fa)|0;p=p+c(A,N)|0;a=a+c(A,ha)|0;a=a+c(K,N)|0;b=b+c(K,ha)|0;p=p+c(C,O)|0;a=a+c(C,ia)|0;a=a+c(B,O)|0;b=b+c(B,ia)|0;var za=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(za>>>26)|0;za&=67108863;p=c(G,\nca);a=c(G,da);a=a+c(Z,ca)|0;b=c(Z,da);p=p+c(F,L)|0;a=a+c(F,ea)|0;a=a+c(Y,L)|0;b=b+c(Y,ea)|0;p=p+c(E,M)|0;a=a+c(E,fa)|0;a=a+c(X,M)|0;b=b+c(X,fa)|0;p=p+c(D,N)|0;a=a+c(D,ha)|0;a=a+c(T,N)|0;b=b+c(T,ha)|0;p=p+c(A,O)|0;a=a+c(A,ia)|0;a=a+c(K,O)|0;b=b+c(K,ia)|0;p=p+c(C,P)|0;a=a+c(C,ja)|0;a=a+c(B,P)|0;b=b+c(B,ja)|0;var Aa=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(Aa>>>26)|0;Aa&=67108863;p=c(H,ca);a=c(H,da);a=a+c(aa,ca)|0;b=c(aa,da);p=p+c(G,L)|0;a=a+c(G,ea)|0;a=a+c(Z,L)|0;b=b+c(Z,ea)|0;p=p+c(F,M)|0;a=a+c(F,\nfa)|0;a=a+c(Y,M)|0;b=b+c(Y,fa)|0;p=p+c(E,N)|0;a=a+c(E,ha)|0;a=a+c(X,N)|0;b=b+c(X,ha)|0;p=p+c(D,O)|0;a=a+c(D,ia)|0;a=a+c(T,O)|0;b=b+c(T,ia)|0;p=p+c(A,P)|0;a=a+c(A,ja)|0;a=a+c(K,P)|0;b=b+c(K,ja)|0;p=p+c(C,Q)|0;a=a+c(C,ka)|0;a=a+c(B,Q)|0;b=b+c(B,ka)|0;var Ba=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(Ba>>>26)|0;Ba&=67108863;p=c(I,ca);a=c(I,da);a=a+c(ba,ca)|0;b=c(ba,da);p=p+c(H,L)|0;a=a+c(H,ea)|0;a=a+c(aa,L)|0;b=b+c(aa,ea)|0;p=p+c(G,M)|0;a=a+c(G,fa)|0;a=a+c(Z,M)|0;b=b+c(Z,fa)|0;p=p+c(F,N)|0;a=a+c(F,ha)|\n0;a=a+c(Y,N)|0;b=b+c(Y,ha)|0;p=p+c(E,O)|0;a=a+c(E,ia)|0;a=a+c(X,O)|0;b=b+c(X,ia)|0;p=p+c(D,P)|0;a=a+c(D,ja)|0;a=a+c(T,P)|0;b=b+c(T,ja)|0;p=p+c(A,Q)|0;a=a+c(A,ka)|0;a=a+c(K,Q)|0;b=b+c(K,ka)|0;p=p+c(C,R)|0;a=a+c(C,la)|0;a=a+c(B,R)|0;b=b+c(B,la)|0;var Ca=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(Ca>>>26)|0;Ca&=67108863;p=c(J,ca);a=c(J,da);a=a+c(U,ca)|0;b=c(U,da);p=p+c(I,L)|0;a=a+c(I,ea)|0;a=a+c(ba,L)|0;b=b+c(ba,ea)|0;p=p+c(H,M)|0;a=a+c(H,fa)|0;a=a+c(aa,M)|0;b=b+c(aa,fa)|0;p=p+c(G,N)|0;a=a+c(G,ha)|0;\na=a+c(Z,N)|0;b=b+c(Z,ha)|0;p=p+c(F,O)|0;a=a+c(F,ia)|0;a=a+c(Y,O)|0;b=b+c(Y,ia)|0;p=p+c(E,P)|0;a=a+c(E,ja)|0;a=a+c(X,P)|0;b=b+c(X,ja)|0;p=p+c(D,Q)|0;a=a+c(D,ka)|0;a=a+c(T,Q)|0;b=b+c(T,ka)|0;p=p+c(A,R)|0;a=a+c(A,la)|0;a=a+c(K,R)|0;b=b+c(K,la)|0;p=p+c(C,S)|0;a=a+c(C,W)|0;a=a+c(B,S)|0;b=b+c(B,W)|0;var Da=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(Da>>>26)|0;Da&=67108863;p=c(f,ca);a=c(f,da);a=a+c(V,ca)|0;b=c(V,da);p=p+c(J,L)|0;a=a+c(J,ea)|0;a=a+c(U,L)|0;b=b+c(U,ea)|0;p=p+c(I,M)|0;a=a+c(I,fa)|0;a=a+c(ba,\nM)|0;b=b+c(ba,fa)|0;p=p+c(H,N)|0;a=a+c(H,ha)|0;a=a+c(aa,N)|0;b=b+c(aa,ha)|0;p=p+c(G,O)|0;a=a+c(G,ia)|0;a=a+c(Z,O)|0;b=b+c(Z,ia)|0;p=p+c(F,P)|0;a=a+c(F,ja)|0;a=a+c(Y,P)|0;b=b+c(Y,ja)|0;p=p+c(E,Q)|0;a=a+c(E,ka)|0;a=a+c(X,Q)|0;b=b+c(X,ka)|0;p=p+c(D,R)|0;a=a+c(D,la)|0;a=a+c(T,R)|0;b=b+c(T,la)|0;p=p+c(A,S)|0;a=a+c(A,W)|0;a=a+c(K,S)|0;b=b+c(K,W)|0;p=p+c(C,k)|0;a=a+c(C,na)|0;a=a+c(B,k)|0;b=b+c(B,na)|0;C=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(C>>>26)|0;C&=67108863;p=c(f,L);a=c(f,ea);a=a+c(V,L)|0;b=c(V,\nea);p=p+c(J,M)|0;a=a+c(J,fa)|0;a=a+c(U,M)|0;b=b+c(U,fa)|0;p=p+c(I,N)|0;a=a+c(I,ha)|0;a=a+c(ba,N)|0;b=b+c(ba,ha)|0;p=p+c(H,O)|0;a=a+c(H,ia)|0;a=a+c(aa,O)|0;b=b+c(aa,ia)|0;p=p+c(G,P)|0;a=a+c(G,ja)|0;a=a+c(Z,P)|0;b=b+c(Z,ja)|0;p=p+c(F,Q)|0;a=a+c(F,ka)|0;a=a+c(Y,Q)|0;b=b+c(Y,ka)|0;p=p+c(E,R)|0;a=a+c(E,la)|0;a=a+c(X,R)|0;b=b+c(X,la)|0;p=p+c(D,S)|0;a=a+c(D,W)|0;a=a+c(T,S)|0;b=b+c(T,W)|0;p=p+c(A,k)|0;a=a+c(A,na)|0;a=a+c(K,k)|0;b=b+c(K,na)|0;A=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(A>>>26)|0;A&=67108863;\np=c(f,M);a=c(f,fa);a=a+c(V,M)|0;b=c(V,fa);p=p+c(J,N)|0;a=a+c(J,ha)|0;a=a+c(U,N)|0;b=b+c(U,ha)|0;p=p+c(I,O)|0;a=a+c(I,ia)|0;a=a+c(ba,O)|0;b=b+c(ba,ia)|0;p=p+c(H,P)|0;a=a+c(H,ja)|0;a=a+c(aa,P)|0;b=b+c(aa,ja)|0;p=p+c(G,Q)|0;a=a+c(G,ka)|0;a=a+c(Z,Q)|0;b=b+c(Z,ka)|0;p=p+c(F,R)|0;a=a+c(F,la)|0;a=a+c(Y,R)|0;b=b+c(Y,la)|0;p=p+c(E,S)|0;a=a+c(E,W)|0;a=a+c(X,S)|0;b=b+c(X,W)|0;p=p+c(D,k)|0;a=a+c(D,na)|0;a=a+c(T,k)|0;b=b+c(T,na)|0;D=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(D>>>26)|0;D&=67108863;p=c(f,N);a=c(f,\nha);a=a+c(V,N)|0;b=c(V,ha);p=p+c(J,O)|0;a=a+c(J,ia)|0;a=a+c(U,O)|0;b=b+c(U,ia)|0;p=p+c(I,P)|0;a=a+c(I,ja)|0;a=a+c(ba,P)|0;b=b+c(ba,ja)|0;p=p+c(H,Q)|0;a=a+c(H,ka)|0;a=a+c(aa,Q)|0;b=b+c(aa,ka)|0;p=p+c(G,R)|0;a=a+c(G,la)|0;a=a+c(Z,R)|0;b=b+c(Z,la)|0;p=p+c(F,S)|0;a=a+c(F,W)|0;a=a+c(Y,S)|0;b=b+c(Y,W)|0;p=p+c(E,k)|0;a=a+c(E,na)|0;a=a+c(X,k)|0;b=b+c(X,na)|0;E=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(E>>>26)|0;E&=67108863;p=c(f,O);a=c(f,ia);a=a+c(V,O)|0;b=c(V,ia);p=p+c(J,P)|0;a=a+c(J,ja)|0;a=a+c(U,P)|0;\nb=b+c(U,ja)|0;p=p+c(I,Q)|0;a=a+c(I,ka)|0;a=a+c(ba,Q)|0;b=b+c(ba,ka)|0;p=p+c(H,R)|0;a=a+c(H,la)|0;a=a+c(aa,R)|0;b=b+c(aa,la)|0;p=p+c(G,S)|0;a=a+c(G,W)|0;a=a+c(Z,S)|0;b=b+c(Z,W)|0;p=p+c(F,k)|0;a=a+c(F,na)|0;a=a+c(Y,k)|0;b=b+c(Y,na)|0;F=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(F>>>26)|0;F&=67108863;p=c(f,P);a=c(f,ja);a=a+c(V,P)|0;b=c(V,ja);p=p+c(J,Q)|0;a=a+c(J,ka)|0;a=a+c(U,Q)|0;b=b+c(U,ka)|0;p=p+c(I,R)|0;a=a+c(I,la)|0;a=a+c(ba,R)|0;b=b+c(ba,la)|0;p=p+c(H,S)|0;a=a+c(H,W)|0;a=a+c(aa,S)|0;b=b+c(aa,W)|\n0;p=p+c(G,k)|0;a=a+c(G,na)|0;a=a+c(Z,k)|0;b=b+c(Z,na)|0;G=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(G>>>26)|0;G&=67108863;p=c(f,Q);a=c(f,ka);a=a+c(V,Q)|0;b=c(V,ka);p=p+c(J,R)|0;a=a+c(J,la)|0;a=a+c(U,R)|0;b=b+c(U,la)|0;p=p+c(I,S)|0;a=a+c(I,W)|0;a=a+c(ba,S)|0;b=b+c(ba,W)|0;p=p+c(H,k)|0;a=a+c(H,na)|0;a=a+c(aa,k)|0;b=b+c(aa,na)|0;H=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(H>>>26)|0;H&=67108863;p=c(f,R);a=c(f,la);a=a+c(V,R)|0;b=c(V,la);p=p+c(J,S)|0;a=a+c(J,W)|0;a=a+c(U,S)|0;b=b+c(U,W)|0;p=p+c(I,k)|\n0;a=a+c(I,na)|0;a=a+c(ba,k)|0;b=b+c(ba,na)|0;I=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(I>>>26)|0;I&=67108863;p=c(f,S);a=c(f,W);a=a+c(V,S)|0;b=c(V,W);p=p+c(J,k)|0;a=a+c(J,na)|0;a=a+c(U,k)|0;b=b+c(U,na)|0;J=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(J>>>26)|0;J&=67108863;p=c(f,k);a=c(f,na);a=a+c(V,k)|0;b=c(V,na);B=(y+p|0)+((a&8191)<<13)|0;y=(b+(a>>>13)|0)+(B>>>26)|0;t[0]=va;t[1]=wa;t[2]=xa;t[3]=ya;t[4]=za;t[5]=Aa;t[6]=Ba;t[7]=Ca;t[8]=Da;t[9]=C;t[10]=A;t[11]=D;t[12]=E;t[13]=F;t[14]=G;t[15]=H;t[16]=\nI;t[17]=J;t[18]=B&67108863;0!==y&&(t[19]=y,g.length++);return g}function w(a,b){if(!a)throw Error(b||\"Assertion failed\");}function h(a,b,g){if(h.vc(a))return a;this.b=0;this.a=null;this.length=0;this.red=null;if(null!==a){if(\"le\"===b||\"be\"===b)g=b,b=10;this.pa(a||0,b||10,g||\"be\")}}function l(a,b,g){var f=0;for(g=Math.min(a.length,g);b<g;b++){var k=a.charCodeAt(b)-48;f<<=4;f=49<=k&&54>=k?f|k-49+10:17<=k&&22>=k?f|k-17+10:f|k&15}return f}function m(a,b,g){g.b=b.b^a.b;var f=a.length+b.length|0;g.length=\nf;f=f-1|0;var k=a.a[0]|0,t=b.a[0]|0;k*=t;var y=k/67108864|0;g.a[0]=k&67108863;for(var A=1;A<f;A++){var C=y>>>26,B=y&67108863;y=Math.min(A,b.length-1);for(var D=Math.max(0,A-a.length+1);D<=y;D++)k=a.a[A-D|0]|0,t=b.a[D]|0,k=k*t+B,C+=k/67108864|0,B=k&67108863;g.a[A]=B|0;y=C|0}0!==y?g.a[A]=y|0:g.length--;return g.L()}function x(a,b){this.name=a;this.p=new h(b,16);this.n=this.p.U();this.k=(new h(1)).ua(this.n).i(this.p);this.Ab=this.cc()}function d(){x.call(this,\"k256\",\"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\")}\nfunction u(a){\"string\"===typeof a?(a=h.P(a),this.G=a.p,this.ja=a):(w(a.Cd(1),\"modulus must be greater than 1\"),this.G=a,this.ja=null)}var e={};\"object\"===typeof module?e=h:e.Gb=h;h.Gb=h;h.Eb=26;h.vc=function(a){return a instanceof h?!0:null!==a&&\"object\"===typeof a&&a.constructor.Eb===h.Eb&&Array.isArray(a.a)};h.prototype.pa=function(a,b,g){if(\"number\"===typeof a)this.Yb(a,g);else if(\"object\"===typeof a)this.Ia(a,g);else{\"hex\"===b&&(b=16);w(b===(b|0)&&2<=b&&36>=b);a=a.toString().replace(/\\s+/g,\"\");\nvar f=0;\"-\"===a[0]&&f++;16===b?this.bc(a,f):this.td(a,b,f);\"-\"===a[0]&&(this.b=1);this.L();\"le\"===g&&this.Ia(this.H(),g)}};h.prototype.Yb=function(a,b){0>a&&(this.b=1,a=-a);67108864>a?(this.a=[a&67108863],this.length=1):4503599627370496>a?(this.a=[a&67108863,a/67108864&67108863],this.length=2):(w(9007199254740992>a),this.a=[a&67108863,a/67108864&67108863,1],this.length=3);\"le\"===b&&this.Ia(this.H(),b)};h.prototype.Ia=function(a,b){w(\"number\"===typeof a.length);if(0>=a.length)this.a=[0],this.length=\n1;else{this.length=Math.ceil(a.length/3);this.a=Array(this.length);for(var g=0;g<this.length;g++)this.a[g]=0;var f=0;if(\"be\"===b)for(g=a.length-1,b=0;0<=g;g-=3){var k=a[g]|a[g-1]<<8|a[g-2]<<16;this.a[b]|=k<<f&67108863;this.a[b+1]=k>>>26-f&67108863;f+=24;26<=f&&(f-=26,b++)}else if(\"le\"===b)for(b=g=0;g<a.length;g+=3)k=a[g]|a[g+1]<<8|a[g+2]<<16,this.a[b]|=k<<f&67108863,this.a[b+1]=k>>>26-f&67108863,f+=24,26<=f&&(f-=26,b++);this.L()}};h.prototype.bc=function(a,b){this.length=Math.ceil((a.length-b)/6);\nthis.a=Array(this.length);for(var g=0;g<this.length;g++)this.a[g]=0;var f,k=0;g=a.length-6;for(f=0;g>=b;g-=6){var t=l(a,g,g+6);this.a[f]|=t<<k&67108863;this.a[f+1]|=t>>>26-k&4194303;k+=24;26<=k&&(k-=26,f++)}g+6!==b&&(t=l(a,b,g+6),this.a[f]|=t<<k&67108863,this.a[f+1]|=t>>>26-k&4194303);this.L()};h.prototype.qc=function(a){a.a=Array(this.length);for(var b=0;b<this.length;b++)a.a[b]=this.a[b];a.length=this.length;a.b=this.b;a.red=this.red};h.prototype.clone=function(){var a=new h(null);this.qc(a);return a};\nh.prototype.Rb=function(a){for(;this.length<a;)this.a[this.length++]=0};h.prototype.L=function(){for(;1<this.length&&0===this.a[this.length-1];)this.length--;return this.qa()};h.prototype.qa=function(){1===this.length&&0===this.a[0]&&(this.b=0);return this};var n=\" 0 00 000 0000 00000 000000 0000000 00000000 000000000 0000000000 00000000000 000000000000 0000000000000 00000000000000 000000000000000 0000000000000000 00000000000000000 000000000000000000 0000000000000000000 00000000000000000000 000000000000000000000 0000000000000000000000 00000000000000000000000 000000000000000000000000 0000000000000000000000000\".split(\" \"),\nv=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],r=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1E7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64E6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243E5,28629151,33554432,39135393,45435424,52521875,60466176];h.prototype.toString=function(a,b){a=a||10;b=b|0||1;if(16===a||\"hex\"===a){var g=\"\";for(var f=a=0,k=0;k<this.length;k++){var t=\nthis.a[k],y=((t<<a|f)&16777215).toString(16);f=t>>>24-a&16777215;g=0!==f||k!==this.length-1?n[6-y.length]+y+g:y+g;a+=2;26<=a&&(a-=26,k--)}for(0!==f&&(g=f.toString(16)+g);0!==g.length%b;)g=\"0\"+g;0!==this.b&&(g=\"-\"+g);return g}if(a===(a|0)&&2<=a&&36>=a){f=v[a];k=r[a];g=\"\";t=this.clone();for(t.b=0;!t.w();)y=t.Da(k).toString(a),t=t.Dd(k),g=t.w()?y+g:n[f-y.length]+y+g;for(this.w()&&(g=\"0\"+g);0!==g.length%b;)g=\"0\"+g;0!==this.b&&(g=\"-\"+g);return g}w(!1,\"Base should be between 2 and 36\")};h.prototype.H=function(a,\nb){return this.hd(a,b)};h.prototype.hd=function(a,b){var g=Array,f=this.byteLength();b=b||Math.max(1,f);w(f<=b,\"byte array longer than desired length\");w(0<b,\"Requested array length <= 0\");this.L();var k=\"le\"===a;g=new g(b);a=this.clone();if(k){for(k=0;!a.w();k++)f=a.T(255),a.j(8),g[k]=f;for(;k<b;k++)g[k]=0}else{for(k=0;k<b-f;k++)g[k]=0;for(k=0;!a.w();k++)f=a.T(255),a.j(8),g[b-k-1]=f}return g};h.prototype.fb=Math.clz32?function(a){return 32-Math.clz32(a)}:function(a){var b=0;4096<=a&&(b+=13,a>>>=\n13);64<=a&&(b+=7,a>>>=7);8<=a&&(b+=4,a>>>=4);2<=a&&(b+=2,a>>>=2);return b+a};h.prototype.U=function(){return 26*(this.length-1)+this.fb(this.a[this.length-1])};h.prototype.byteLength=function(){return Math.ceil(this.U()/8)};h.prototype.l=function(){return this.clone().Pa()};h.prototype.Pa=function(){this.w()||(this.b^=1);return this};h.prototype.B=function(a){if(0!==this.b&&0===a.b)return this.b=0,this.i(a),this.b^=1,this.qa();if(0===this.b&&0!==a.b){a.b=0;var b=this.i(a);a.b=1;return b.qa()}if(this.length>\na.length)var g=this;else g=a,a=this;for(var f=b=0;f<a.length;f++)b=(g.a[f]|0)+(a.a[f]|0)+b,this.a[f]=b&67108863,b>>>=26;for(;0!==b&&f<g.length;f++)b=(g.a[f]|0)+b,this.a[f]=b&67108863,b>>>=26;this.length=g.length;if(0!==b)this.a[this.length]=b,this.length++;else if(g!==this)for(;f<g.length;f++)this.a[f]=g.a[f];return this};h.prototype.add=function(a){if(0!==a.b&&0===this.b){a.b=0;var b=this.sub(a);a.b^=1;return b}return 0===a.b&&0!==this.b?(this.b=0,b=a.sub(this),this.b=1,b):this.length>a.length?this.clone().B(a):\na.clone().B(this)};h.prototype.i=function(a){if(0!==a.b){a.b=0;var b=this.B(a);a.b=1;return b.qa()}if(0!==this.b)return this.b=0,this.B(a),this.b=1,this.qa();b=this.cmp(a);if(0===b)return this.b=0,this.length=1,this.a[0]=0,this;if(0<b)var g=this;else g=a,a=this;for(var f=0,k=0;k<a.length;k++)b=(g.a[k]|0)-(a.a[k]|0)+f,f=b>>26,this.a[k]=b&67108863;for(;0!==f&&k<g.length;k++)b=(g.a[k]|0)+f,f=b>>26,this.a[k]=b&67108863;if(0===f&&k<g.length&&g!==this)for(;k<g.length;k++)this.a[k]=g.a[k];this.length=Math.max(this.length,\nk);g!==this&&(this.b=1);return this.L()};h.prototype.sub=function(a){return this.clone().i(a)};var c=Math.imul;Math.imul||(q=m);h.prototype.Oc=function(a,b){var g=this.length+a.length;if(10===this.length&&10===a.length)a=q(this,a,b);else if(63>g)a=m(this,a,b);else throw\"removed\";return a};h.prototype.o=function(a){var b=new h(null);b.a=Array(this.length+a.length);return this.Oc(a,b)};h.prototype.ua=function(a){w(\"number\"===typeof a&&0<=a);var b=a%26;a=(a-b)/26;var g=67108863>>>26-b<<26-b,f;if(0!==\nb){var k=0;for(f=0;f<this.length;f++){var t=this.a[f]&g;this.a[f]=(this.a[f]|0)-t<<b|k;k=t>>>26-b}k&&(this.a[f]=k,this.length++)}if(0!==a){for(f=this.length-1;0<=f;f--)this.a[f+a]=this.a[f];for(f=0;f<a;f++)this.a[f]=0;this.length+=a}return this.L()};h.prototype.j=function(a){w(\"number\"===typeof a&&0<=a);var b=a%26,g=Math.min((a-b)/26,this.length),f=67108863^67108863>>>b<<b;var k=Math.max(0,-g);if(0!==g)if(this.length>g)for(this.length-=g,a=0;a<this.length;a++)this.a[a]=this.a[a+g];else this.a[0]=\n0,this.length=1;g=0;for(a=this.length-1;0<=a&&(0!==g||a>=k);a--){var t=this.a[a]|0;this.a[a]=g<<26-b|t>>>b;g=t&f}0===this.length&&(this.a[0]=0,this.length=1);return this.L()};h.prototype.ld=function(a){return this.clone().ua(a)};h.prototype.ab=function(a){return this.clone().j(a)};h.prototype.Na=function(a){w(\"number\"===typeof a);w(67108864>a);if(0>a)return this.Ca(-a);if(0!==this.b){if(1===this.length&&(this.a[0]|0)<a)return this.a[0]=a-(this.a[0]|0),this.b=0,this;this.b=0;this.Ca(a);this.b=1;return this}return this.Wb(a)};\nh.prototype.Wb=function(a){this.a[0]+=a;for(a=0;a<this.length&&67108864<=this.a[a];a++)this.a[a]-=67108864,a===this.length-1?this.a[a+1]=1:this.a[a+1]++;this.length=Math.max(this.length,a+1);return this};h.prototype.Ca=function(a){w(\"number\"===typeof a);w(67108864>a);if(0>a)return this.Na(-a);if(0!==this.b)return this.b=0,this.Na(a),this.b=1,this;this.a[0]-=a;if(1===this.length&&0>this.a[0])this.a[0]=-this.a[0],this.b=1;else for(a=0;a<this.length&&0>this.a[a];a++)this.a[a]+=67108864,--this.a[a+1];\nreturn this.L()};h.prototype.Ja=function(a,b,g){var f;this.Rb(a.length+g);var k=0;for(f=0;f<a.length;f++){var t=(this.a[f+g]|0)+k;k=(a.a[f]|0)*b;t-=k&67108863;k=(t>>26)-(k/67108864|0);this.a[f+g]=t&67108863}for(;f<this.length-g;f++)t=(this.a[f+g]|0)+k,k=t>>26,this.a[f+g]=t&67108863;if(0===k)return this.L();w(-1===k);for(f=k=0;f<this.length;f++)t=-(this.a[f]|0)+k,k=t>>26,this.a[f]=t&67108863;this.b=1;return this.L()};h.prototype.ic=function(a,b){var g=this.clone(),f=a,k=f.a[f.length-1]|0;a=26-this.fb(k);\n0!==a&&(f=f.ld(a),g.ua(a),k=f.a[f.length-1]|0);var t=g.length-f.length;if(\"mod\"!==b){var y=new h(null);y.length=t+1;y.a=Array(y.length);for(var A=0;A<y.length;A++)y.a[A]=0}A=g.clone().Ja(f,1,t);0===A.b&&(g=A,y&&(y.a[t]=1));for(--t;0<=t;t--){A=67108864*(g.a[f.length+t]|0)+(g.a[f.length+t-1]|0);A=Math.min(A/k|0,67108863);for(g.Ja(f,A,t);0!==g.b;)A--,g.b=0,g.Ja(f,1,t),g.w()||(g.b^=1);y&&(y.a[t]=A)}y&&y.L();g.L();\"div\"!==b&&0!==a&&g.j(a);return{u:y||null,J:g}};h.prototype.ga=function(a,b,g){w(!a.w());\nif(this.w())return{u:new h(0),J:new h(0)};var f;if(0!==this.b&&0===a.b){var k=this.l().ga(a,b);\"mod\"!==b&&(f=k.u.l());if(\"div\"!==b){var t=k.J.l();g&&0!==t.b&&t.B(a)}return{u:f,J:t}}return 0===this.b&&0!==a.b?(k=this.ga(a.l(),b),\"mod\"!==b&&(f=k.u.l()),{u:f,J:k.J}):0!==(this.b&a.b)?(k=this.l().ga(a.l(),b),\"div\"!==b&&(t=k.J.l(),g&&0!==t.b&&t.i(a)),{u:k.u,J:t}):a.length>this.length||0>this.cmp(a)?{u:new h(0),J:this}:1===a.length?\"div\"===b?{u:this.sc(a.a[0]),J:null}:\"mod\"===b?{u:null,J:new h(this.Da(a.a[0]))}:\n{u:this.sc(a.a[0]),J:new h(this.Da(a.a[0]))}:this.ic(a,b)};h.prototype.u=function(a){return this.ga(a,\"div\",!1).u};h.prototype.S=function(a){return this.ga(a,\"mod\",!0).J};h.prototype.mb=function(a){var b=this.ga(a);if(b.J.w())return b.u;var g=0!==b.u.b?b.J.i(a):b.J,f=a.ab(1);a=a.T(1);g=g.cmp(f);return 0>g||1===a&&0===g?b.u:0!==b.u.b?b.u.Ca(1):b.u.Na(1)};h.prototype.Da=function(a){w(67108863>=a);for(var b=67108864%a,g=0,f=this.length-1;0<=f;f--)g=(b*g+(this.a[f]|0))%a;return g};h.prototype.tc=function(a){w(0===\na.b);w(!a.w());var b=this,g=a.clone();b=0!==b.b?b.S(a):b.clone();a=new h(1);for(var f=new h(0),k=new h(0),t=new h(1),y=0;b.Ra()&&g.Ra();)b.j(1),g.j(1),++y;for(var A=g.clone(),C=b.clone();!b.w();){for(var B=0,D=1;0===(b.a[0]&D)&&26>B;++B,D<<=1);if(0<B)for(b.j(B);0<B--;){if(a.Y()||f.Y())a.B(A),f.i(C);a.j(1);f.j(1)}B=0;for(D=1;0===(g.a[0]&D)&&26>B;++B,D<<=1);if(0<B)for(g.j(B);0<B--;){if(k.Y()||t.Y())k.B(A),t.i(C);k.j(1);t.j(1)}0<=b.cmp(g)?(b.i(g),a.i(k),f.i(t)):(g.i(b),k.i(a),t.i(f))}return{I:k,M:t,\nBd:g.ua(y)}};h.prototype.Zb=function(a){w(0===a.b);w(!a.w());var b=this,g=a.clone();b=0!==b.b?b.S(a):b.clone();for(var f=new h(1),k=new h(0),t=g.clone();0<b.m(1)&&0<g.m(1);){for(var y=0,A=1;0===(b.a[0]&A)&&26>y;++y,A<<=1);if(0<y)for(b.j(y);0<y--;)f.Y()&&f.B(t),f.j(1);y=0;for(A=1;0===(g.a[0]&A)&&26>y;++y,A<<=1);if(0<y)for(g.j(y);0<y--;)k.Y()&&k.B(t),k.j(1);0<=b.cmp(g)?(b.i(g),f.i(k)):(g.i(b),k.i(f))}b=0===b.m(1)?f:k;0>b.m(0)&&b.B(a);return b};h.prototype.Ba=function(a){return this.tc(a).I.S(a)};h.prototype.Ra=\nfunction(){return 0===(this.a[0]&1)};h.prototype.Y=function(){return 1===(this.a[0]&1)};h.prototype.T=function(a){return this.a[0]&a};h.prototype.w=function(){return 1===this.length&&0===this.a[0]};h.prototype.m=function(a){var b=0>a;if(0!==this.b&&!b)return-1;if(0===this.b&&b)return 1;this.L();1<this.length?a=1:(b&&(a=-a),w(67108863>=a,\"Number is too big\"),b=this.a[0]|0,a=b===a?0:b<a?-1:1);return 0!==this.b?-a|0:a};h.prototype.cmp=function(a){if(0!==this.b&&0===a.b)return-1;if(0===this.b&&0!==a.b)return 1;\na=this.Db(a);return 0!==this.b?-a|0:a};h.prototype.Db=function(a){if(this.length>a.length)return 1;if(this.length<a.length)return-1;for(var b=0,g=this.length-1;0<=g;g--){var f=this.a[g]|0,k=a.a[g]|0;if(f!==k){f<k?b=-1:f>k&&(b=1);break}}return b};h.red=function(a){return new u(a)};h.prototype.A=function(a){w(!this.red,\"Already a number in reduction context\");w(0===this.b,\"red works only with positives\");return a.pc(this).ea(a)};h.prototype.ta=function(){w(this.red,\"fromRed works only with numbers in reduction context\");\nreturn this.red.oc(this)};h.prototype.ea=function(a){this.red=a;return this};h.prototype.$=function(a){w(this.red,\"redAdd works only with red numbers\");return this.red.add(this,a)};h.prototype.s=function(a){w(this.red,\"redIAdd works only with red numbers\");return this.red.B(this,a)};h.prototype.aa=function(a){w(this.red,\"redSub works only with red numbers\");return this.red.sub(this,a)};h.prototype.h=function(a){w(this.red,\"redISub works only with red numbers\");return this.red.i(this,a)};h.prototype.c=\nfunction(a){w(this.red,\"redMul works only with red numbers\");this.red.fa(this,a);return this.red.o(this,a)};h.prototype.f=function(){w(this.red,\"redSqr works only with red numbers\");this.red.za(this);return this.red.yb(this)};h.prototype.Uc=function(){w(this.red,\"redSqrt works only with red numbers\");this.red.za(this);return this.red.sqrt(this)};h.prototype.Za=function(){w(this.red,\"redInvm works only with red numbers\");this.red.za(this);return this.red.Ba(this)};h.prototype.la=function(){w(this.red,\n\"redNeg works only with red numbers\");this.red.za(this);return this.red.l(this)};var z={Fd:null,Kd:null,Jd:null,Ld:null};x.prototype.cc=function(){var a=new h(null);a.a=Array(Math.ceil(this.n/13));return a};x.prototype.Kc=function(a){do{this.split(a,this.Ab);a=this.Ic(a);a=a.B(this.Ab);var b=a.U()}while(b>this.n);b=b<this.n?-1:a.Db(this.p);0===b?(a.a[0]=0,a.length=1):0<b?a.i(this.p):a.L();return a};(function(a,b){function g(){}a.fd=b;g.prototype=b.prototype;a.prototype=new g;a.prototype.constructor=\na})(d,x);d.prototype.split=function(a,b){for(var g=Math.min(a.length,9),f=0;f<g;f++)b.a[f]=a.a[f];b.length=g;if(9>=a.length)a.a[0]=0,a.length=1;else{g=a.a[9];b.a[b.length++]=g&4194303;for(f=10;f<a.length;f++)b=a.a[f]|0,a.a[f-10]=(b&4194303)<<4|g>>>22,g=b;g>>>=22;a.a[f-10]=g;a.length=0===g&&10<a.length?a.length-10:a.length-9}};d.prototype.Ic=function(a){a.a[a.length]=0;a.a[a.length+1]=0;a.length+=2;for(var b=0,g=0;g<a.length;g++){var f=a.a[g]|0;b+=977*f;a.a[g]=b&67108863;b=64*f+(b/67108864|0)}0===\na.a[a.length-1]&&(a.length--,0===a.a[a.length-1]&&a.length--);return a};h.P=function(a){if(z[a])return z[a];var b=new d;return z[a]=b};u.prototype.za=function(a){w(0===a.b,\"red works only with positives\");w(a.red,\"red works only with red numbers\")};u.prototype.fa=function(a,b){w(0===(a.b|b.b),\"red works only with positives\");w(a.red&&a.red===b.red,\"red works only with red numbers\")};u.prototype.Oa=function(a){return this.ja?this.ja.Kc(a).ea(this):a.S(this.G).ea(this)};u.prototype.l=function(a){return a.w()?\na.clone():this.G.sub(a).ea(this)};u.prototype.add=function(a,b){this.fa(a,b);a=a.add(b);0<=a.cmp(this.G)&&a.i(this.G);return a.ea(this)};u.prototype.B=function(a,b){this.fa(a,b);a=a.B(b);0<=a.cmp(this.G)&&a.i(this.G);return a};u.prototype.sub=function(a,b){this.fa(a,b);a=a.sub(b);0>a.m(0)&&a.B(this.G);return a.ea(this)};u.prototype.i=function(a,b){this.fa(a,b);a=a.i(b);0>a.m(0)&&a.B(this.G);return a};u.prototype.o=function(a,b){this.fa(a,b);return this.Oa(a.o(b))};u.prototype.yb=function(a){return this.o(a,\na)};u.prototype.sqrt=function(a){if(a.w())return a.clone();var b=this.G.T(3);w(1===b%2);if(3===b)return b=this.G.add(new h(1)).j(2),this.pow(a,b);for(var g=this.G.bd(1),f=0;!g.w()&&0===g.T(1);)f++,g.j(1);w(!g.w());b=(new h(1)).A(this);var k=b.la(),t=this.G.bd(1).j(1),y=this.G.U();for(y=(new h(2*y*y)).A(this);0!==this.pow(y,t).cmp(k);)y.s(k);t=this.pow(y,g);k=this.pow(a,g.wd(1).j(1));a=this.pow(a,g);for(g=f;0!==a.cmp(b);){y=a;for(f=0;0!==y.cmp(b);f++)y=y.f();w(f<g);t=this.pow(t,(new h(1)).ua(g-f-1));\nk=k.c(t);t=t.f();a=a.c(t);g=f}return k};u.prototype.Ba=function(a){a=a.Zb(this.G);return 0!==a.b?(a.b=0,this.Oa(a).la()):this.Oa(a)};u.prototype.pow=function(a,b){if(b.w())return(new h(1)).A(this);if(0===b.m(1))return a.clone();var g=Array(16);g[0]=(new h(1)).A(this);g[1]=a;for(var f=2;f<g.length;f++)g[f]=this.o(g[f-1],a);a=g[0];var k=0,t=0,y=b.U()%26;0===y&&(y=26);for(f=b.length-1;0<=f;f--){var A=b.a[f];for(--y;0<=y;y--){var C=A>>y&1;a!==g[0]&&(a=this.yb(a));if(0===C&&0===k)t=0;else if(k<<=1,k|=\nC,t++,4===t||0===f&&0===y)a=this.o(a,g[k]),k=t=0}y=26}return a};u.prototype.pc=function(a){var b=a.S(this.G);return b===a?b.clone():b};u.prototype.oc=function(a){a=a.clone();a.red=null;return a};return e}),Ia=Fa(function(){function q(){}function w(l){return l.length>>>1}var h={};h.Ib=q;h.pd=50;q.P=!0;h.Gd=q.P?2147483647:1073741823;q.from=function(l,m){var x=null,d=w(l,m)|0;if((q.P?2147483647:1073741823)<d)throw new RangeError(\"Invalid typed array length\");q.P?(x=new Uint8Array(d),x.__proto__=q.prototype):\n(null===x&&(x=new q(d)),x.length=d);l=x.write(l,m);l!==d&&(x=x.slice(0,l));return x};q.P&&(q.prototype.__proto__=Uint8Array.prototype,q.__proto__=Uint8Array,sa(),sa(),sa(),\"undefined\"!==typeof Symbol&&Symbol.species&&q[Symbol.species]===q&&(sa(),Object.defineProperty(q,Symbol.species,{value:null,configurable:!0})));q.isBuffer=function(l){return!(null==l||!l.$b)};q.byteLength=w;q.prototype.$b=!0;q.prototype.write=function(l){var m=this.length;var x=Number(0)||0;var d=this.length-x;m?(m=Number(m),m>\nd&&(m=d)):m=d;d=l.length;if(0!==d%2)throw new TypeError(\"Invalid hex string\");m>d/2&&(m=d/2);for(d=0;d<m;++d){var u=parseInt(l.substr(2*d,2),16);if(isNaN(u))break;this[x+d]=u}return d};return h}),Ja=Fa(function(){function q(w,h){if(!w)throw Error(h||\"Assertion failed\");}q.P=function(){};return q}),La=Fa(function(){var q={};Ha();var w=Ja(),h=Ka();q.assert=w;q.H=h.H;q.Fb=h.Fb;q.Bb=h.Bb;q.encode=h.encode;q.Fc=function(l,m,x){x=Array(Math.max(l.U(),x)+1);x.fill(0);m=1<<m+1;l=l.clone();for(var d=0;d<x.length;d++){var u,\ne=l.T(m-1);l.Y()?(e>(m>>1)-1?u=(m>>1)-e:u=e,l.Ca(u)):u=0;x[d]=u;l.j(1)}return x};q.Ec=function(l,m){var x=[[],[]];l=l.clone();m=m.clone();for(var d=0,u=0;0<l.m(-d)||0<m.m(-u);){var e=l.T(3)+d&3,n=m.T(3)+u&3;3===e&&(e=-1);3===n&&(n=-1);if(0===(e&1))var v=0;else{var r=l.T(7)+d&7;v=3!==r&&5!==r||2!==n?e:-e}x[0].push(v);0===(n&1)?e=0:(r=m.T(7)+u&7,e=3!==r&&5!==r||2!==e?n:-n);x[1].push(e);2*d===v+1&&(d=1-d);2*u===e+1&&(u=1-u);l.j(1);m.j(1)}return x};q.Nd=function(){};q.Ed=function(){};return q}),Ma=Fa(function(){var q=\n{},w=Ja(),h=Ga();q.Jc=h;q.H=function(l,m){if(Array.isArray(l))return l.slice();if(!l)return[];var x=[];if(\"string\"===typeof l)if(!m)for(var d=m=0;d<l.length;d++){var u=l.charCodeAt(d);128>u?x[m++]=u:(2048>u?x[m++]=u>>6|192:(x[m++]=u>>12|224,x[m++]=u>>6&63|128),x[m++]=u&63|128)}else{if(\"hex\"===m)for(l=l.replace(/[^a-z0-9]+/ig,\"\"),0!==l.length%2&&(l=\"0\"+l),d=0;d<l.length;d+=2)x.push(parseInt(l[d]+l[d+1],16))}else for(d=0;d<l.length;d++)x[d]=l[d]|0;return x};q.Lc=function(l,m,x){m-=0;w(0===m%4);m=Array(m/\n4);for(var d=0,u=0;d<m.length;d++,u+=4)m[d]=(\"big\"===x?l[u]<<24|l[u+1]<<16|l[u+2]<<8|l[u+3]:l[u+3]<<24|l[u+2]<<16|l[u+1]<<8|l[u])>>>0;return m};q.ad=function(l){for(var m=Array(4*l.length),x=0,d=0;x<l.length;x++,d+=4){var u=l[x];m[d]=u>>>24;m[d+1]=u>>>16&255;m[d+2]=u>>>8&255;m[d+3]=u&255}return m};q.Vc=function(l,m){return l>>>m|l<<32-m};q.cd=function(l,m){return l+m>>>0};q.dd=function(l,m,x,d){return l+m+x+d>>>0};q.ed=function(l,m,x,d,u){return l+m+x+d+u>>>0};return q}),Na=Fa(function(){function q(h,\nl){return l.length===2*h+2?l:q(h,\"0x0\"+l.slice(2))}var w={};return w={length:function(h){return(h.length-2)/2},flatten:function(h){return\"0x\"+h.reduce(function(l,m){return l+m.slice(2)},\"\")},slice:function(h,l,m){return\"0x\"+m.slice(2*h+2,2*l+2)},tb:q,xc:function(h){h=h.toString(16);return 0===h.length%2?\"0x\"+h:\"0x0\"+h},jd:function(h){return parseInt(h.slice(2),16)},pb:function(h){return\"0x0\"===h?\"0x\":0===h.length%2?h:\"0x0\"+h.slice(2)},Qd:function(h){return\"0\"===h[2]?\"0x\"+h.slice(3):h}}}),Oa=Fa(function(){function q(){this.pending=\nnull;this.Ya=0;this.X=this.constructor.X;this.va=this.constructor.va;this.Ma=this.constructor.Ma;this.ia=this.constructor.ia/8;this.nb=\"big\";this.Ha=this.X/8;this.Lb=this.X/32}var w={},h=Ma(),l=Ja();w.Hb=q;q.prototype.update=function(m,x){m=h.H(m,x);this.pending?this.pending=this.pending.concat(m):this.pending=m;this.Ya+=m.length;if(this.pending.length>=this.Ha)for(m=this.pending,x=m.length%this.Ha,this.pending=m.slice(m.length-x,m.length),0===this.pending.length&&(this.pending=null),m=h.Lc(m,m.length-\nx,this.nb),x=0;x<m.length;x+=this.Lb)this.ra(m,x);return this};q.prototype.digest=function(m){this.update(this.ac());l(null===this.pending);return this.Mb(m)};q.prototype.ac=function(){var m=this.Ya,x=this.Ha,d=x-(m+this.ia)%x;x=Array(d+this.ia);x[0]=128;for(var u=1;u<d;u++)x[u]=0;m<<=3;if(\"big\"===this.nb){for(d=8;d<this.ia;d++)x[u++]=0;x[u++]=0;x[u++]=0;x[u++]=0;x[u++]=0;x[u++]=m>>>24&255;x[u++]=m>>>16&255;x[u++]=m>>>8&255;x[u++]=m&255}else for(x[u++]=m&255,x[u++]=m>>>8&255,x[u++]=m>>>16&255,x[u++]=\nm>>>24&255,x[u++]=0,x[u++]=0,x[u++]=0,x[u++]=0,d=8;d<this.ia;d++)x[u++]=0;return x};return w}),Pa=Fa(function(){function q(d){var u;for(u=0;48>u;u+=2){var e=d[0]^d[10]^d[20]^d[30]^d[40];var n=d[1]^d[11]^d[21]^d[31]^d[41];var v=d[2]^d[12]^d[22]^d[32]^d[42];var r=d[3]^d[13]^d[23]^d[33]^d[43];var c=d[4]^d[14]^d[24]^d[34]^d[44];var z=d[5]^d[15]^d[25]^d[35]^d[45];var a=d[6]^d[16]^d[26]^d[36]^d[46];var b=d[7]^d[17]^d[27]^d[37]^d[47];var g=d[8]^d[18]^d[28]^d[38]^d[48];var f=d[9]^d[19]^d[29]^d[39]^d[49];\nvar k=g^(v<<1|r>>>31);var t=f^(r<<1|v>>>31);d[0]^=k;d[1]^=t;d[10]^=k;d[11]^=t;d[20]^=k;d[21]^=t;d[30]^=k;d[31]^=t;d[40]^=k;d[41]^=t;k=e^(c<<1|z>>>31);t=n^(z<<1|c>>>31);d[2]^=k;d[3]^=t;d[12]^=k;d[13]^=t;d[22]^=k;d[23]^=t;d[32]^=k;d[33]^=t;d[42]^=k;d[43]^=t;k=v^(a<<1|b>>>31);t=r^(b<<1|a>>>31);d[4]^=k;d[5]^=t;d[14]^=k;d[15]^=t;d[24]^=k;d[25]^=t;d[34]^=k;d[35]^=t;d[44]^=k;d[45]^=t;k=c^(g<<1|f>>>31);t=z^(f<<1|g>>>31);d[6]^=k;d[7]^=t;d[16]^=k;d[17]^=t;d[26]^=k;d[27]^=t;d[36]^=k;d[37]^=t;d[46]^=k;d[47]^=\nt;k=a^(e<<1|n>>>31);t=b^(n<<1|e>>>31);d[8]^=k;d[9]^=t;d[18]^=k;d[19]^=t;d[28]^=k;d[29]^=t;d[38]^=k;d[39]^=t;d[48]^=k;d[49]^=t;k=d[0];t=d[1];var y=d[11]<<4|d[10]>>>28;var A=d[10]<<4|d[11]>>>28;var C=d[20]<<3|d[21]>>>29;var B=d[21]<<3|d[20]>>>29;var D=d[31]<<9|d[30]>>>23;var K=d[30]<<9|d[31]>>>23;var E=d[40]<<18|d[41]>>>14;var T=d[41]<<18|d[40]>>>14;var F=d[2]<<1|d[3]>>>31;var X=d[3]<<1|d[2]>>>31;e=d[13]<<12|d[12]>>>20;n=d[12]<<12|d[13]>>>20;var G=d[22]<<10|d[23]>>>22;var Y=d[23]<<10|d[22]>>>22;var H=\nd[33]<<13|d[32]>>>19;var Z=d[32]<<13|d[33]>>>19;var I=d[42]<<2|d[43]>>>30;var aa=d[43]<<2|d[42]>>>30;var J=d[5]<<30|d[4]>>>2;var ba=d[4]<<30|d[5]>>>2;var U=d[14]<<6|d[15]>>>26;var V=d[15]<<6|d[14]>>>26;v=d[25]<<11|d[24]>>>21;r=d[24]<<11|d[25]>>>21;var L=d[34]<<15|d[35]>>>17;var ca=d[35]<<15|d[34]>>>17;var da=d[45]<<29|d[44]>>>3;var M=d[44]<<29|d[45]>>>3;g=d[6]<<28|d[7]>>>4;f=d[7]<<28|d[6]>>>4;var ea=d[17]<<23|d[16]>>>9;var N=d[16]<<23|d[17]>>>9;var fa=d[26]<<25|d[27]>>>7;var O=d[27]<<25|d[26]>>>7;\nc=d[36]<<21|d[37]>>>11;z=d[37]<<21|d[36]>>>11;var ha=d[47]<<24|d[46]>>>8;var P=d[46]<<24|d[47]>>>8;var ia=d[8]<<27|d[9]>>>5;var Q=d[9]<<27|d[8]>>>5;var ja=d[18]<<20|d[19]>>>12;var R=d[19]<<20|d[18]>>>12;var ka=d[29]<<7|d[28]>>>25;var S=d[28]<<7|d[29]>>>25;var la=d[38]<<8|d[39]>>>24;var W=d[39]<<8|d[38]>>>24;a=d[48]<<14|d[49]>>>18;b=d[49]<<14|d[48]>>>18;d[0]=k^~e&v;d[1]=t^~n&r;d[10]=g^~ja&C;d[11]=f^~R&B;d[20]=F^~U&fa;d[21]=X^~V&O;d[30]=ia^~y&G;d[31]=Q^~A&Y;d[40]=J^~ea&ka;d[41]=ba^~N&S;d[2]=e^~v&c;\nd[3]=n^~r&z;d[12]=ja^~C&H;d[13]=R^~B&Z;d[22]=U^~fa&la;d[23]=V^~O&W;d[32]=y^~G&L;d[33]=A^~Y&ca;d[42]=ea^~ka&D;d[43]=N^~S&K;d[4]=v^~c&a;d[5]=r^~z&b;d[14]=C^~H&da;d[15]=B^~Z&M;d[24]=fa^~la&E;d[25]=O^~W&T;d[34]=G^~L&ha;d[35]=Y^~ca&P;d[44]=ka^~D&I;d[45]=S^~K&aa;d[6]=c^~a&k;d[7]=z^~b&t;d[16]=H^~da&g;d[17]=Z^~M&f;d[26]=la^~E&F;d[27]=W^~T&X;d[36]=L^~ha&ia;d[37]=ca^~P&Q;d[46]=D^~I&J;d[47]=K^~aa&ba;d[8]=a^~k&e;d[9]=b^~t&n;d[18]=da^~g&ja;d[19]=M^~f&R;d[28]=E^~F&U;d[29]=T^~X&V;d[38]=ha^~ia&y;d[39]=P^~Q&A;d[48]=\nI^~J&ea;d[49]=aa^~ba&N;d[0]^=x[u];d[1]^=x[u+1]}}var w={},h=\"0123456789abcdef\".split(\"\"),l=[1,256,65536,16777216],m=[0,8,16,24],x=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648];return w={rb:function(d){return function(u,\ne){var n,v;if(\"0x\"!==u.slice(0,2)||(void 0===e?0:e))var r=u;else for(r=[],e=2,v=u.length;e<v;e+=2)r.push(parseInt(u.slice(e,e+2),16));v=[0,0,0,0,0,0,0,0,0,0];var c=!0;var z=n=0;u=1600-(d<<1)>>5;e=d>>5;v=v.concat(v,v,v,v);var a=void 0;for(var b=r,g=b.length,f=[],k=u<<2,t=0;t<g;){if(c)for(c=!1,f[0]=n,r=1;r<u+1;++r)f[r]=0;if(\"string\"!==typeof b)for(r=z;t<g&&r<k;++t)f[r>>2]|=b[t]<<m[r++&3];else for(r=z;t<g&&r<k;++t)z=b.charCodeAt(t),128>z?f[r>>2]|=z<<m[r++&3]:(2048>z?f[r>>2]|=(192|z>>6)<<m[r++&3]:(55296>\nz||57344<=z?f[r>>2]|=(224|z>>12)<<m[r++&3]:(z=65536+((z&1023)<<10|b.charCodeAt(++t)&1023),f[r>>2]|=(240|z>>18)<<m[r++&3],f[r>>2]|=(128|z>>12&63)<<m[r++&3]),f[r>>2]|=(128|z>>6&63)<<m[r++&3]),f[r>>2]|=(128|z&63)<<m[r++&3]);a=r;if(r>=k){z=r-k;n=f[u];for(r=0;r<u;++r)v[r]^=f[r];q(v);c=!0}else z=r}r=a;f[r>>2]|=l[r&3];if(a===k)for(f[0]=f[u],r=1;r<u+1;++r)f[r]=0;f[u-1]|=2147483648;for(r=0;r<u;++r)v[r]^=f[r];q(v);c=\"\";for(n=0;n<e;){for(r=0;r<u&&n<e;++r,++n)z=v[r],c+=h[z>>4&15]+h[z&15]+h[z>>12&15]+h[z>>8&15]+\nh[z>>20&15]+h[z>>16&15]+h[z>>28&15]+h[z>>24&15];0===n%u&&q(v)}return\"0x\"+c}}(256)}}),Sa=Fa(function(){var q={};q.md=La();q.yd=Qa();q.sa=Ra();return q}),Ta=Fa(function(){function q(u,e){this.type=u;this.p=new h(e.p,16);this.red=e.ja?h.red(e.ja):h.Hd(this.p);this.od=(new h(0)).A(this.red);this.Ea=(new h(1)).A(this.red);this.kd=(new h(2)).A(this.red);this.n=e.n&&new h(e.n,16);this.v=e.v&&this.Qc(e.v,e.Cc);this.dc=Array(4);this.ec=Array(4);this.fc=Array(4);this.hc=Array(4);this.Ga=this.n?this.n.U():0;\nu=this.n&&this.p.u(this.n);!u||0<u.m(100)||this.n.A(this.red)}function w(u,e){this.curve=u;this.type=e;this.D=null}var h=Ha(),l=La(),m=l.Fc,x=l.Ec,d=l.assert;q.prototype.Sb=function(u,e){d(u.D);u=u.ib();var n=m(e,1,this.Ga),v=(1<<u.step+1)-(0===u.step%2?2:1);v/=3;for(var r=[],c=0;c<n.length;c+=u.step){for(var z=0,a=c+u.step-1;e>=c;e--)z=(z<<1)+n[a];r.push(z)}e=this.O(null,null,null);for(n=this.O(null,null,null);0<v;v--){for(c=0;c<r.length;c++)z=r[c],z===v?n=n.ca(u.C[c]):z===-v&&(n=n.ca(u.C[c].l()));\ne=e.add(n)}return e.Cb()};q.prototype.lb=function(u,e,n,v){for(var r=this.dc,c=this.ec,z=this.fc,a=0,b=0;b<n;b++){var g=u[b],f=g.jb(1);r[b]=f.da;c[b]=f.C}for(b=n-1;1<=b;b-=2){var k=b-1,t=b;if(1!==r[k]||1!==r[t])z[k]=m(e[k],r[k],this.Ga),z[t]=m(e[t],r[t],this.Ga),a=Math.max(z[k].length,a),a=Math.max(z[t].length,a);else{var y=[u[k],null,null,u[t]];0===u[k].y.cmp(u[t].y)?(y[1]=u[k].add(u[t]),y[2]=u[k].xa().ca(u[t].l())):0===u[k].y.cmp(u[t].y.la())?(y[1]=u[k].xa().ca(u[t]),y[2]=u[k].add(u[t].l())):(y[1]=\nu[k].xa().ca(u[t]),y[2]=u[k].xa().ca(u[t].l()));var A=[-3,-1,-5,-7,0,7,5,1,3],C=x(e[k],e[t]);a=Math.max(C[0].length,a);z[k]=Array(a);z[t]=Array(a);for(f=0;f<a;f++)z[k][f]=A[3*((C[0][f]|0)+1)+((C[1][f]|0)+1)],z[t][f]=0,c[k]=y}}u=this.O(null,null,null);e=this.hc;for(b=a;0<=b;b--){for(a=0;0<=b;){r=!0;for(f=0;f<n;f++)e[f]=z[f][b]|0,0!==e[f]&&(r=!1);if(!r)break;a++;b--}0<=b&&a++;u=u.rc(a);if(0>b)break;for(f=0;f<n;f++)a=e[f],0!==a&&(0<a?g=c[f][a-1>>1]:0>a&&(g=c[f][-a-1>>1].l()),u=\"affine\"===g.type?u.ca(g):\nu.add(g))}for(b=0;b<n;b++)c[b]=null;return v?u:u.Cb()};q.ya=w;w.prototype.cb=function(){return this.curve.cb(this)};w.prototype.Nb=function(u){var e=this.curve.p.byteLength(),n=this.qb().H(\"be\",e);return u?[this.La().Ra()?2:3].concat(n):[4].concat(n,this.La().H(\"be\",e))};w.prototype.encode=function(u,e){return l.encode(this.Nb(e),u)};w.prototype.Rc=function(u){if(!this.D){var e={F:null,K:null,beta:null};e.K=this.jb(8);e.F=this.ib(4,u);e.beta=this.hb();this.D=e}};w.prototype.Vb=function(u){if(!this.D)return!1;\nvar e=this.D.F;return e?e.C.length>=Math.ceil((u.U()+1)/e.step):!1};w.prototype.ib=function(u,e){if(this.D&&this.D.F)return this.D.F;for(var n=[this],v=this,r=0;r<e;r+=u){for(var c=0;c<u;c++)v=v.ba();n.push(v)}return{step:u,C:n}};w.prototype.jb=function(u){if(this.D&&this.D.K)return this.D.K;for(var e=[this],n=(1<<u)-1,v=1===n?null:this.ba(),r=1;r<n;r++)e[r]=e[r-1].add(v);return{da:u,C:e}};return q}),Qa=Fa(function(){function q(m){this.curve=new (Ua())(m);this.v=this.curve.v;this.n=this.curve.n;this.hash=\nm.hash;l(this.v.cb(),\"Invalid curve\");l(this.v.o(this.n).R(),\"Invalid curve, G*N != O\")}var w={},h=Va(),l=La().assert;w.Jb=q;(function(m,x){Object.defineProperty(w,m,{configurable:!0,enumerable:!0,get:function(){var d=new q(x);Object.defineProperty(w,m,{configurable:!0,enumerable:!0,value:d});return d}})})(\"secp256k1\",{type:\"short\",ja:\"k256\",p:\"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\",I:\"0\",M:\"7\",n:\"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\",\ng:\"1\",hash:h.$a,beta:\"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\",Va:\"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\",Aa:[{I:\"3086d221a7d46bcde86c90e49284eb15\",M:\"-e4437ed6010e88286f547fa90abfe4c3\"},{I:\"114ca50f7a8e2f3f657c1108d9d44cfd8\",M:\"3086d221a7d46bcde86c90e49284eb15\"}],Cc:!1,v:[\"79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\"483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",{}]});return w}),Va=Fa(function(){var q={};\nq.md=Ma();q.xd=Oa();q.Yc={$a:Wa()};q.Hc=Xa();q.$a=q.Yc.$a;return q}),Ka=Fa(function(){function q(l){return 1===l.length?\"0\"+l:l}function w(l){for(var m=\"\",x=0;x<l.length;x++)m+=q(l[x].toString(16));return m}var h={H:function(l,m){if(Array.isArray(l))return l.slice();if(!l)return[];var x=[];if(\"string\"!==typeof l){for(m=0;m<l.length;m++)x[m]=l[m]|0;return x}if(\"hex\"===m)for(l=l.replace(/[^a-z0-9]+/ig,\"\"),0!==l.length%2&&(l=\"0\"+l),m=0;m<l.length;m+=2)x.push(parseInt(l[m]+l[m+1],16));else for(m=0;m<\nl.length;m++){var d=l.charCodeAt(m),u=d>>8;d&=255;u?x.push(u,d):x.push(d)}return x}};h.Fb=q;h.Bb=w;h.encode=function(l,m){return\"hex\"===m?w(l):l};return h}),Ya=Fa(function(){var q={},w=Ma().Vc;q.Ad=function(){};q.nc=function(h,l,m){return h&l^~h&m};q.Mc=function(h,l,m){return h&l^h&m^l&m};q.Md=function(){};q.Wc=function(h){return w(h,2)^w(h,13)^w(h,22)};q.Xc=function(h){return w(h,6)^w(h,11)^w(h,25)};q.Ac=function(h){return w(h,7)^w(h,18)^h>>>3};q.Bc=function(h){return w(h,17)^w(h,19)^h>>>10};return q}),\nWa=Fa(function(){function q(){if(!(this instanceof q))return new q;a.call(this);this.g=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];this.k=b;this.Kb=Array(64)}var w=Ma(),h=Oa(),l=Ya(),m=Ja(),x=w.cd,d=w.dd,u=w.ed,e=l.nc,n=l.Mc,v=l.Wc,r=l.Xc,c=l.Ac,z=l.Bc,a=h.Hb,b=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,\n264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];w.Jc(q,\na);q.X=512;q.va=256;q.Ma=192;q.ia=64;q.prototype.ra=function(g,f){for(var k=this.Kb,t=0;16>t;t++)k[t]=g[f+t];for(;t<k.length;t++)k[t]=d(z(k[t-2]),k[t-7],c(k[t-15]),k[t-16]);g=this.g[0];f=this.g[1];var y=this.g[2],A=this.g[3],C=this.g[4],B=this.g[5],D=this.g[6],K=this.g[7];m(this.k.length===k.length);for(t=0;t<k.length;t++){var E=u(K,r(C),e(C,B,D),this.k[t],k[t]),T=x(v(g),n(g,f,y));K=D;D=B;B=C;C=x(A,E);A=y;y=f;f=g;g=x(E,T)}this.g[0]=x(this.g[0],g);this.g[1]=x(this.g[1],f);this.g[2]=x(this.g[2],y);\nthis.g[3]=x(this.g[3],A);this.g[4]=x(this.g[4],C);this.g[5]=x(this.g[5],B);this.g[6]=x(this.g[6],D);this.g[7]=x(this.g[7],K)};q.prototype.Mb=function(g){return\"hex\"===g?w.Pd(this.g,\"big\"):w.ad(this.g)};return q}),Ua=Fa(function(){function q(e){d.call(this,\"short\",e);this.I=(new m(e.I,16)).A(this.red);this.M=(new m(e.M,16)).A(this.red);this.gd=this.kd.Za();this.eb=0===this.I.ta().m(0);this.zb=0===this.I.ta().sub(this.p).m(-3);this.ha=this.Ub(e);this.Pb=Array(4);this.Qb=Array(4)}function w(e,n,v,r){d.ya.call(this,\ne,\"affine\");null===n&&null===v?(this.y=this.x=null,this.V=!0):(this.x=new m(n,16),this.y=new m(v,16),r&&(this.x.wc(this.curve.red),this.y.wc(this.curve.red)),this.x.red||(this.x=this.x.A(this.curve.red)),this.y.red||(this.y=this.y.A(this.curve.red)),this.V=!1)}function h(e,n,v,r){d.ya.call(this,e,\"jacobian\");null===n&&null===v&&null===r?(this.y=this.x=this.curve.Ea,this.z=new m(0)):(this.x=new m(n,16),this.y=new m(v,16),this.z=new m(r,16));this.x.red||(this.x=this.x.A(this.curve.red));this.y.red||\n(this.y=this.y.A(this.curve.red));this.z.red||(this.z=this.z.A(this.curve.red));this.nd=this.z===this.curve.Ea}var l={};l=La();var m=Ha(),x=Ga(),d=Ta(),u=l.assert;x(q,d);l=q;q.prototype.Ub=function(e){if(this.eb&&this.v&&this.n&&1===this.p.Da(3)){if(e.beta)var n=(new m(e.beta,16)).A(this.red);else n=this.Tb(this.p),n=0>n[0].cmp(n[1])?n[0]:n[1],n=n.A(this.red);if(e.Va)var v=new m(e.Va,16);else v=this.Tb(this.n),0===this.v.o(v[0]).x.cmp(this.v.x.c(n))?v=v[0]:(v=v[1],u(0===this.v.o(v).x.cmp(this.v.x.c(n))));\nvar r;e.Aa?r=e.Aa.map(function(c){return{I:new m(c.I,16),M:new m(c.M,16)}}):r=this.rd(v);return{beta:n,Va:v,Aa:r}}};q.prototype.Ob=function(e){var n=this.ha.Aa,v=n[0],r=n[1],c=r.M.o(e).mb(this.n),z=v.M.l().o(e).mb(this.n);n=c.o(v.I);var a=z.o(r.I);v=c.o(v.M);r=z.o(r.M);e=e.sub(n).sub(a);n=v.add(r).l();return{Sa:e,Ta:n}};q.prototype.wb=function(e,n){e=new m(e,16);e.red||(e=e.A(this.red));var v=e.f().c(e).s(e.c(this.I)).s(this.M),r=v.Uc();if(0!==r.f().aa(v).cmp(this.od))throw Error(\"invalid point\");\nv=r.ta().Y();if(n&&!v||!n&&v)r=r.la();return this.W(e,r)};q.prototype.cb=function(e){if(e.V)return!0;var n=e.x;e=e.y;var v=this.I.c(n);n=n.f().c(n).s(v).s(this.M);return 0===e.f().h(n).m(0)};q.prototype.gb=function(e,n){for(var v=this.Pb,r=this.Qb,c=0;c<e.length;c++){var z=this.Ob(n[c]),a=e[c],b=a.hb();z.Sa.b&&(z.Sa.Pa(),a=a.l(!0));z.Ta.b&&(z.Ta.Pa(),b=b.l(!0));v[2*c]=a;v[2*c+1]=b;r[2*c]=z.Sa;r[2*c+1]=z.Ta}e=this.lb(v,r,2*c,void 0);for(n=0;n<2*c;n++)v[n]=null,r[n]=null;return e};x(w,d.ya);q.prototype.W=\nfunction(e,n,v){return new w(this,e,n,v)};q.prototype.Qc=function(e,n){return w.P(this,e,n)};w.prototype.hb=function(){if(this.curve.ha){var e=this.D;if(e&&e.beta)return e.beta;var n=this.curve.W(this.x.c(this.curve.ha.beta),this.y);if(e){var v=this.curve,r=function(c){return v.W(c.x.c(v.ha.beta),c.y)};e.beta=n;n.D={beta:null,K:e.K&&{da:e.K.da,C:e.K.C.map(r)},F:e.F&&{step:e.F.step,C:e.F.C.map(r)}}}return n}};w.prototype.toJSON=function(){};w.P=function(e,n,v){function r(z){return e.W(z[0],z[1],v)}\n\"string\"===typeof n&&(n=JSON.parse(n));var c=e.W(n[0],n[1],v);if(!n[2])return c;n=n[2];c.D={beta:null,F:n.F&&{step:n.F.step,C:[c].concat(n.F.C.map(r))},K:n.K&&{da:n.K.da,C:[c].concat(n.K.C.map(r))}};return c};w.prototype.R=function(){return this.V};w.prototype.add=function(e){if(this.V)return e;if(e.V)return this;if(this.ob(e))return this.ba();if(this.l().ob(e)||0===this.x.cmp(e.x))return this.curve.W(null,null);var n=this.y.aa(e.y);0!==n.m(0)&&(n=n.c(this.x.aa(e.x).Za()));e=n.f().h(this.x).h(e.x);\nn=n.c(this.x.aa(e)).h(this.y);return this.curve.W(e,n)};w.prototype.qb=function(){return this.x.ta()};w.prototype.La=function(){return this.y.ta()};w.prototype.o=function(e){e=new m(e,16);return this.R()?this:this.Vb(e)?this.curve.Sb(this,e):this.curve.ha?this.curve.gb([this],[e]):this.curve.vd(this,e)};w.prototype.Nc=function(e,n,v){n=[this,n];e=[e,v];return this.curve.ha?this.curve.gb(n,e):this.curve.lb(n,e,2)};w.prototype.ob=function(e){return this===e||this.V===e.V&&(this.V||0===this.x.cmp(e.x)&&\n0===this.y.cmp(e.y))};w.prototype.l=function(e){if(this.V)return this;var n=this.curve.W(this.x,this.y.la());if(e&&this.D){e=this.D;var v=function(r){return r.l()};n.D={K:e.K&&{da:e.K.da,C:e.K.C.map(v)},F:e.F&&{step:e.F.step,C:e.F.C.map(v)}}}return n};w.prototype.xa=function(){return this.V?this.curve.O(null,null,null):this.curve.O(this.x,this.y,this.curve.Ea)};x(h,d.ya);q.prototype.O=function(e,n,v){return new h(this,e,n,v)};h.prototype.Cb=function(){if(this.R())return this.curve.W(null,null);var e=\nthis.z.Za(),n=e.f(),v=this.x.c(n);e=this.y.c(n).c(e);return this.curve.W(v,e)};h.prototype.l=function(){return this.curve.O(this.x,this.y.la(),this.z)};h.prototype.add=function(e){if(this.R())return e;if(e.R())return this;var n=e.z.f(),v=this.z.f(),r=this.x.c(n),c=e.x.c(v);n=this.y.c(n.c(e.z));v=e.y.c(v.c(this.z));c=r.aa(c);v=n.aa(v);if(0===c.m(0))return 0!==v.m(0)?this.curve.O(null,null,null):this.ba();var z=c.f(),a=z.c(c);z=r.c(z);r=v.f().s(a).h(z).h(z);n=v.c(z.h(r)).h(n.c(a));e=this.z.c(e.z).c(c);\nreturn this.curve.O(r,n,e)};h.prototype.ca=function(e){if(this.R())return e.xa();if(e.R())return this;var n=this.z.f(),v=this.x,r=e.x.c(n),c=this.y;e=e.y.c(n).c(this.z);r=v.aa(r);e=c.aa(e);if(0===r.m(0))return 0!==e.m(0)?this.curve.O(null,null,null):this.ba();var z=r.f();n=z.c(r);z=v.c(z);v=e.f().s(n).h(z).h(z);c=e.c(z.h(v)).h(c.c(n));r=this.z.c(r);return this.curve.O(v,c,r)};h.prototype.rc=function(e){if(0===e||this.R())return this;if(!e)return this.ba();if(this.curve.eb||this.curve.zb){for(var n=\nthis,v=0;v<e;v++)n=n.ba();return n}n=this.curve.I;var r=this.curve.gd,c=this.x;v=this.y;var z=this.z,a=z.f().f(),b=v.$(v);for(v=0;v<e;v++){var g=c.f(),f=b.f(),k=f.f();g=g.$(g).s(g).s(n.c(a));f=c.c(f);c=g.f().h(f.$(f));f=f.h(c);g=g.c(f);g=g.s(g).h(k);z=b.c(z);v+1<e&&(a=a.c(k));b=g}return this.curve.O(c,b.c(r),z)};h.prototype.ba=function(){return this.R()?this:this.curve.eb?this.jc():this.curve.zb?this.ud():this.qd()};h.prototype.jc=function(){if(this.nd){var e=this.x.f();var n=this.y.f();var v=n.f();\nn=this.x.$(n).f().h(e).h(v);n=n.s(n);e=e.$(e).s(e);var r=e.f().h(n).h(n),c=v.s(v);c=c.s(c);c=c.s(c);v=r;n=e.c(n.h(r)).h(c);e=this.y.$(this.y)}else e=this.x.f(),n=this.y.f(),v=n.f(),n=this.x.$(n).f().h(e).h(v),n=n.s(n),e=e.$(e).s(e),r=e.f(),c=v.s(v),c=c.s(c),c=c.s(c),v=r.h(n).h(n),n=e.c(n.h(v)).h(c),e=this.y.c(this.z),e=e.s(e);return this.curve.O(v,n,e)};h.prototype.R=function(){return 0===this.z.m(0)};return l}),Xa=Fa(function(){function q(l,m,x){if(!(this instanceof q))return new q(l,m,x);this.Fa=\nl;this.X=l.X/8;this.va=l.va/8;this.Xa=this.Qa=null;this.pa(w.H(m,x))}var w=Ma(),h=Ja();q.prototype.pa=function(l){l.length>this.X&&(l=(new this.Fa).update(l).digest());h(l.length<=this.X);for(var m=l.length;m<this.X;m++)l.push(0);for(m=0;m<l.length;m++)l[m]^=54;this.Qa=(new this.Fa).update(l);for(m=0;m<l.length;m++)l[m]^=106;this.Xa=(new this.Fa).update(l)};q.prototype.update=function(l,m){this.Qa.update(l,m);return this};q.prototype.digest=function(l){this.Xa.update(this.Qa.digest());return this.Xa.digest(l)};\nreturn q}),Ra=Fa(function(){function q(e){if(!(this instanceof q))return new q(e);\"string\"===typeof e&&(x(m.hasOwnProperty(e),\"Unknown curve \"+e),e=m[e]);e instanceof m.Jb&&(e={curve:e});this.curve=e.curve.curve;this.n=this.curve.n;this.Pc=this.n.ab(1);this.v=this.curve.v;this.v=e.curve.v;this.v.Rc(e.curve.n.U()+1);this.hash=e.hash||e.curve.hash}var w=Ha(),h=Za(),l=La(),m=Qa(),x=l.assert,d=$a(),u=ab();q.prototype.Ua=function(e,n){return d.yc(this,e,n)};q.prototype.kb=function(e,n){var v=8*e.byteLength()-\nthis.n.U();0<v&&(e=e.ab(v));return!n&&0<=e.cmp(this.n)?e.sub(this.n):e};q.prototype.sign=function(e,n,v,r){\"object\"===typeof v&&(r=v,v=null);r||(r={});n=this.Ua(n,v);e=this.kb(new w(e,16));var c=this.n.byteLength();v=n.Z.H(\"be\",c);c=e.H(\"be\",c);c=new h({hash:this.hash,uc:v,nonce:c,ub:r.ub,vb:r.vb||\"utf8\"});for(var z=this.n.sub(new w(1)),a=0;;a++){var b=r.k?r.k(a):new w(c.Dc(this.n.byteLength()));b=this.kb(b,!0);if(!(0>=b.m(1)||0<=b.cmp(z))){var g=this.v.o(b);if(!g.R()){var f=g.qb();v=f.S(this.n);\nif(0!==v.m(0)&&(b=b.Ba(this.n).o(v.o(n.Z).B(e)),b=b.S(this.n),0!==b.m(0)))return e=(g.La().Y()?1:0)|(0!==f.cmp(v)?2:0),r.mc&&0<b.cmp(this.Pc)&&(b=this.n.sub(b),e^=1),new u({r:v,ma:b,wa:e})}}}};q.prototype.Tc=function(e,n,v){x((3&v)===v,\"The recovery param is more than two bits\");n=new u(n,void 0);var r=this.n,c=new w(e);e=n.r;var z=n.ma,a=v&1;v>>=1;if(0<=e.cmp(this.curve.p.S(this.curve.n))&&v)throw Error(\"Unable to find sencond key candinate\");e=v?this.curve.wb(e.add(this.curve.n),a):this.curve.wb(e,\na);n=n.r.Ba(r);c=r.sub(c).o(n).S(r);r=z.o(n).S(r);return this.v.Nc(c,e,r)};return q}),Za=Fa(function(){function q(m){if(!(this instanceof q))return new q(m);this.hash=m.hash;this.sb=this.hash.va;this.Wa=m.Wa||this.hash.Ma;this.N=this.na=this.xb=this.Ka=null;var x=h.H(m.uc,m.zd||\"hex\"),d=h.H(m.nonce,m.Id||\"hex\");m=h.H(m.ub,m.vb||\"hex\");l(x.length>=this.Wa/8,\"Not enough entropy. Minimum is: \"+this.Wa+\" bits\");this.pa(x,d,m)}var w=Va(),h=Ka(),l=Ja();q.prototype.pa=function(m,x,d){m=m.concat(x).concat(d);\nthis.na=Array(this.sb/8);this.N=Array(this.sb/8);for(x=0;x<this.N.length;x++)this.na[x]=0,this.N[x]=1;this.ra(m);this.Ka=1;this.xb=281474976710656};q.prototype.oa=function(){return new w.Hc(this.hash,this.na)};q.prototype.ra=function(m){var x=this.oa().update(this.N).update([0]);m&&(x=x.update(m));this.na=x.digest();this.N=this.oa().update(this.N).digest();m&&(this.na=this.oa().update(this.N).update([1]).update(m).digest(),this.N=this.oa().update(this.N).digest())};q.prototype.Dc=function(m){if(this.Ka>\nthis.xb)throw Error(\"Reseed is required\");if(\"string\"!==typeof u){var x=d;var d=u;var u=null}d&&(d=h.H(d,x||\"hex\"),this.ra(d));for(x=[];x.length<m;)this.N=this.oa().update(this.N).digest(),x=x.concat(this.N);m=x.slice(0,m);this.ra(d);this.Ka++;return h.encode(m,u)};return q}),$a=Fa(function(){function q(h,l){this.sa=h;this.ka=this.Z=null;l.Z&&this.Xb(l.Z,l.Sc);l.ka&&this.sd(l.ka,l.Od)}var w=Ha();La();q.yc=function(h,l,m){return l instanceof q?l:new q(h,{Z:l,Sc:m})};q.prototype.Gc=function(){var h=\n!1,l=\"hex\";\"string\"===typeof h&&(l=h,h=null);this.ka||(this.ka=this.sa.v.o(this.Z));return l?this.ka.encode(l,h):this.ka};q.prototype.Xb=function(h,l){this.Z=new w(h,l||16);this.Z=this.Z.S(this.sa.curve.n)};q.prototype.sign=function(h,l,m){return this.sa.sign(h,this,l,m)};return q}),ab=Fa(function(){function q(l){if(l instanceof q)return l;h(l.r&&l.ma,\"Signature without r or s\");this.r=new w(l.r,16);this.ma=new w(l.ma,16);void 0===l.wa?this.wa=null:this.wa=l.wa}var w=Ha(),h=La().assert;return q}),\nbb=Fa(function(){var q={};(function(w){function h(e){for(var n=d(e.slice(2)),v=\"0x\",r=0;40>r;r++)v+=7<parseInt(n[r+2],16)?e[r+2].toUpperCase():e[r+2];return v}var l=Na(),m=Ha(),x=new (Sa().sa)(\"secp256k1\"),d=Pa().rb,u={zc:function(e){e=\"0x\"+(\"0x\"===e.slice(0,2)?new m(e.slice(2),16):new m(e,10)).toString(\"hex\");return\"0x0\"===e?\"0x\":e}};q={kc:h,lc:function(e){e=w.from(e.slice(2),\"hex\");e=\"0x\"+x.Ua(e).Gc().slice(2);e=d(e);return h(\"0x\"+e.slice(-40))},Zc:function(e,n,v){v=void 0===v?27:v;e=x.Ua(w.from(n.slice(2),\n\"hex\")).sign(w.from(e.slice(2),\"hex\"),{mc:!0});v=[u.zc(l.xc(v+e.wa)),l.tb(32,l.pb(\"0x\"+e.r.toString(16))),l.tb(32,l.pb(\"0x\"+e.ma.toString(16)))];n=(e=\"undefined\"!=typeof Symbol&&Symbol.iterator&&v[Symbol.iterator])?e.call(v):{next:oa(v)};v=n.next().value;e=n.next().value;n=n.next().value;return l.flatten([e,n,v])},$c:function(e,n){n=[l.slice(64,l.length(n),n),l.slice(0,32,n),l.slice(32,64,n)];n={bb:l.jd(n[0]),r:n[1].slice(2),ma:n[2].slice(2)};e=\"0x\"+x.Tc(w.from(e.slice(2),\"hex\"),n,2>n.bb?n.bb:1-n.bb%\n2).encode(\"hex\",!1).slice(2);e=d(e);return h(\"0x\"+e.slice(-40))}}}).call(ma,Ia().Ib);return q})();module.exports.addressChecksum=bb.kc;module.exports.addressFromKey=bb.lc;module.exports.signMessage=bb.Zc;module.exports.signerAddress=bb.$c;module.exports.keccak=Pa().rb;\n","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","// PtrNum types\nconst PTR = 0;\nconst NUM = 1;\n\n// Node types\nconst NOD = 0;\nconst OP1 = 1;\nconst OP2 = 2;\nconst ITE = 3;\n\n// Base types\nconst Pointer = (addr, port) => ({typ: PTR, val: (addr << 2) + (port & 3)});\nconst addr_of = (ptrn) => ptrn.val >>> 2;\nconst slot_of = (ptrn) => ptrn.val & 3;\nconst Numeric = (numb) => ({typ: NUM, val: numb});\nconst numb_of = (ptrn) => ptrn.val;\nconst type_of = (ptrn) => ptrn.typ;\nconst ptrn_eq = (a, b) => a.typ === b.typ && a.val === b.val;\nconst ptrn_st = a => a.typ + \":\" + a.val;\n\nclass Net {\n  // A net stores nodes (this.nodes), reclaimable memory addrs (this.freed) and active pairs (this.redex)\n  constructor() {\n    this.nodes = []; // nodes\n    this.freed = []; // integers\n    this.redex = []; // array of (integer, integer) tuples representing addrs\n    this.find_redex = true;\n  }\n\n  // Allocates a new node, return its addr\n  alloc_node(type, kind) {\n\n    // If there is reclaimable memory, use it\n    if (this.freed.length > 0) {\n      var addr = this.freed.pop();\n\n    // Otherwise, extend the array of nodes\n    } else {\n      var addr = this.nodes.length / 4;\n    }\n\n    // Fill the memory with an empty node without pointers\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = (kind << 6) + ((type & 0x7) << 3);\n    return addr;\n  }\n\n  // Deallocates a node, allowing its space to be reclaimed\n  free_node(addr) {\n    this.nodes[addr * 4 + 0] = addr * 4 + 0;\n    this.nodes[addr * 4 + 1] = addr * 4 + 1;\n    this.nodes[addr * 4 + 2] = addr * 4 + 2;\n    this.nodes[addr * 4 + 3] = 0;\n    this.freed.push(addr);\n  }\n\n  is_free(addr) {\n    return this.nodes[addr * 4 + 0] === addr * 4 + 0\n        && this.nodes[addr * 4 + 1] === addr * 4 + 1\n        && this.nodes[addr * 4 + 2] === addr * 4 + 2\n        && this.nodes[addr * 4 + 3] === 0;\n  }\n\n  // Returns if given slot holds a number\n  is_numeric(addr, slot) {\n    return (this.nodes[addr * 4 + 3] >>> slot) & 1; \n  }\n\n  set_port(addr, slot, ptrn) {\n    if (type_of(ptrn) === NUM) {\n      this.nodes[addr * 4 + slot] = numb_of(ptrn);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] | (1 << slot);\n    } else {\n      this.nodes[addr * 4 + slot] = (addr_of(ptrn) << 2) + (slot_of(ptrn) & 3);\n      this.nodes[addr * 4 + 3] = this.nodes[addr * 4 + 3] & ~(1 << slot);\n    }\n  }\n\n  get_port(addr, slot) {\n    var val = this.nodes[addr * 4 + slot];\n    return !this.is_numeric(addr, slot) ? Pointer(val >>> 2, val & 3) : Numeric(val);\n  }\n\n  type_of(addr) {\n    return (this.nodes[addr * 4 + 3] >>> 3) & 0x7;\n  }\n\n  set_type(addr, type) {\n    this.nodes[addr * 4 + 3] = (this.nodes[addr * 4 + 3] & ~0b111000) | (type << 3);\n  }\n\n  kind_of(addr) {\n    return this.nodes[addr * 4 + 3] >>> 6;\n  }\n\n  // Given a pointer to a port, returns a pointer to the opposing port\n  enter_port(ptrn) {\n    if (type_of(ptrn) === NUM) { \n      throw \"Can't enter a numeric pointer.\";\n    } else {\n      return this.get_port(addr_of(ptrn), slot_of(ptrn));\n    }\n  }\n\n  // Connects two ports\n  link_ports(a_ptrn, b_ptrn) {\n    var a_numb = type_of(a_ptrn) === NUM;\n    var b_numb = type_of(b_ptrn) === NUM;\n\n    // Point ports to each-other\n    if (!a_numb) this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), b_ptrn);\n    if (!b_numb) this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), a_ptrn);\n\n    // If both are main ports, add this to the list of active pairs\n    if (this.find_redex && !(a_numb && b_numb) && (a_numb || slot_of(a_ptrn) === 0) && (b_numb || slot_of(b_ptrn) === 0)) {\n      this.redex.push(a_numb ? addr_of(b_ptrn) : addr_of(a_ptrn));\n    }\n  }\n\n  // Disconnects a port, causing both sides to point to themselves\n  unlink_port(a_ptrn) {\n    if (type_of(a_ptrn) === PTR) {\n      var b_ptrn = this.enter_port(a_ptrn);\n      if (type_of(b_ptrn) === PTR && ptrn_eq(this.enter_port(b_ptrn), a_ptrn)) {\n        this.set_port(addr_of(a_ptrn), slot_of(a_ptrn), a_ptrn);\n        this.set_port(addr_of(b_ptrn), slot_of(b_ptrn), b_ptrn);\n      }\n    }\n  }\n\n  // Rewrites an active pair\n  rewrite(a_addr) {\n    var a_ptrn = Pointer(a_addr, 0);\n    var b_ptrn = this.get_port(a_addr, 0);\n    if (type_of(b_ptrn) === NUM) {\n      var a_type = this.type_of(a_addr);\n      var a_kind = this.kind_of(a_addr);\n\n      // UnaryOperation\n      if (a_type === OP1) {\n        var dst = this.enter_port(Pointer(a_addr, 2));\n        var fst = numb_of(b_ptrn);\n        var snd = numb_of(this.enter_port(Pointer(a_addr, 1)));\n        switch (a_kind) {\n          case  0: var res = Numeric(fst + snd); break;\n          case  1: var res = Numeric(fst - snd); break;\n          case  2: var res = Numeric(fst * snd); break;\n          case  3: var res = Numeric(fst / snd); break;\n          case  4: var res = Numeric(fst % snd); break;\n          case  5: var res = Numeric(fst ** snd); break;\n          case  6: var res = Numeric(fst & snd); break;\n          case  7: var res = Numeric(fst | snd); break;\n          case  8: var res = Numeric(fst ^ snd); break;\n          case  9: var res = Numeric(~snd); break;\n          case 10: var res = Numeric(fst >>> snd); break;\n          case 11: var res = Numeric(fst << snd); break;\n          case 12: var res = Numeric(fst > snd ? 1 : 0); break;\n          case 13: var res = Numeric(fst < snd ? 1 : 0); break;\n          case 14: var res = Numeric(fst === snd ? 1 : 0); break;\n          default: throw \"[ERROR]\\nInvalid interaction.\";\n        }\n        this.link_ports(dst, res);\n        this.unlink_port(Pointer(a_addr, 0));\n        this.unlink_port(Pointer(a_addr, 2));\n        this.free_node(a_addr);\n      \n      // BinaryOperation\n      } else if (a_type === OP2) {\n        this.set_type(a_addr, OP1);\n        this.link_ports(Pointer(a_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.unlink_port(Pointer(a_addr, 1));\n        this.link_ports(Pointer(a_addr, 1), b_ptrn);\n    \n      // NumberDuplication\n      } else if (a_type === NOD) {\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(b_ptrn, this.enter_port(Pointer(a_addr, 2)));\n        this.free_node(a_addr);\n\n      // IfThenElse\n      } else if (a_type === ITE) {\n        var cond_val = numb_of(b_ptrn) === 0;\n        var pair_ptr = this.enter_port(Pointer(a_addr, 1));\n        this.set_type(a_addr, NOD);\n        this.link_ports(Pointer(a_addr, 0), pair_ptr);\n        this.unlink_port(Pointer(a_addr, 1));\n        var dest_ptr = this.enter_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 2 : 1), dest_ptr);\n        if (!cond_val) this.unlink_port(Pointer(a_addr, 2));\n        this.link_ports(Pointer(a_addr, cond_val ? 1 : 2), Pointer(a_addr, cond_val ? 1 : 2));\n\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n\n    } else {\n      var b_addr = addr_of(b_ptrn);\n      var a_type = this.type_of(a_addr);\n      var b_type = this.type_of(b_addr);\n      var a_kind = this.kind_of(a_addr);\n      var b_kind = this.kind_of(b_addr);\n\n      // NodeAnnihilation, UnaryAnnihilation, BinaryAnnihilation\n      if ( a_type === NOD && b_type === NOD && a_kind === b_kind\n        || a_type === OP1 && b_type === OP1\n        || a_type === OP2 && b_type === OP2\n        || a_type === ITE && b_type === ITE) {\n        var a_aux1_dest = this.enter_port(Pointer(a_addr, 1));\n        var b_aux1_dest = this.enter_port(Pointer(b_addr, 1));\n        this.link_ports(a_aux1_dest, b_aux1_dest);\n        var a_aux2_dest = this.enter_port(Pointer(a_addr, 2));\n        var b_aux2_dest = this.enter_port(Pointer(b_addr, 2));\n        this.link_ports(a_aux2_dest, b_aux2_dest);\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // NodeDuplication, BinaryDuplication\n      } else if\n        (  a_type === NOD && b_type === NOD && a_kind !== b_kind\n        || a_type === NOD && b_type === OP2\n        || a_type === NOD && b_type === ITE) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var r_addr = this.alloc_node(a_type, a_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(r_addr, 1), Pointer(p_addr, 1));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(r_addr, 2), Pointer(q_addr, 1));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(r_addr, 0), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n\n      // UnaryDuplication\n      } else if\n        (  a_type === NOD && b_type === OP1\n        || a_type === ITE && b_type === OP1) {\n        var p_addr = this.alloc_node(b_type, b_kind);\n        var q_addr = this.alloc_node(b_type, b_kind);\n        var s_addr = this.alloc_node(a_type, a_kind);\n        this.link_ports(Pointer(p_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(q_addr, 1), this.enter_port(Pointer(b_addr, 1)));\n        this.link_ports(Pointer(s_addr, 1), Pointer(p_addr, 2));\n        this.link_ports(Pointer(s_addr, 2), Pointer(q_addr, 2));\n        this.link_ports(Pointer(p_addr, 0), this.enter_port(Pointer(a_addr, 1)));\n        this.link_ports(Pointer(q_addr, 0), this.enter_port(Pointer(a_addr, 2)));\n        this.link_ports(Pointer(s_addr, 0), this.enter_port(Pointer(b_addr, 2)));\n        for (var i = 0; i < 3; i++) {\n          this.unlink_port(Pointer(a_addr, i));\n          this.unlink_port(Pointer(b_addr, i));\n        }\n        this.free_node(a_addr);\n        if (a_addr !== b_addr) {\n          this.free_node(b_addr);\n        }\n      \n      // Permutations\n      } else if (a_type === OP1 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === OP2 && b_type === NOD) {\n        return this.rewrite(b_addr);\n      } else if (a_type === ITE && b_type === NOD) {\n        return this.rewrite(b_addr);\n\n      // InvalidInteraction\n      } else {\n        throw \"[ERROR]\\nInvalid interaction.\";\n      }\n    }\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This could be performed in parallel and doesn't need GC.\n  reduce_strict(stats = {mlen: 0, rwts:0, step:0}) {\n    var rwts = 0;\n    var mlen = 0;\n    while (this.redex.length > 0) {\n      for (var i = 0, l = this.redex.length; i < l; ++i) {\n        this.rewrite(this.redex.pop());\n        stats.mlen = Math.max(stats.mlen, this.nodes.length / 4);\n        ++stats.rwts;\n      }\n      ++stats.step;\n    }\n    return stats;\n  }\n\n  // Rewrites active pairs until none is left, reducing the graph to normal form.\n  // This avoids unecessary computations, but is sequential and would need GC.\n  reduce_lazy(stats = {mlen: 0, rwts:0, step:0}) {\n    this.find_redex = false;\n    var warp = [];\n    var back = [];\n    var prev = Pointer(0, 1);\n    var next = this.enter_port(prev);\n    var rwts = 0;\n    while (true) {\n      ++stats.step;\n      if (type_of(next) === PTR && (addr_of(next) === 0 || this.is_free(addr_of(next)))) {\n        if (warp.length === 0) {\n          break;\n        } else {\n          prev = warp.pop();\n          next = this.enter_port(prev);\n        }\n      } else {\n        if (slot_of(prev) === 0 && (type_of(next) === NUM || slot_of(next) === 0)) {\n          try {\n            this.rewrite(addr_of(prev));\n          } catch (e) {\n            return;\n          }\n          stats.rwts += 1;\n          stats.mlen = Math.max(stats.mlen, this.nodes.length / 4);\n          do { prev = back.pop(); } while (type_of(prev) !== PTR);\n          next = this.enter_port(prev);\n          ++rwts;\n        } else if (type_of(next) === NUM) {\n          [prev,next] = [next,prev];\n        } else if (slot_of(next) === 0) {\n          if (this.type_of(addr_of(next)) !== OP1) {\n            warp.push(Pointer(addr_of(next), 1));\n          }\n          prev = Pointer(addr_of(next), 2);\n          next = this.enter_port(prev);\n        } else {\n          back.push(prev);\n          prev = Pointer(addr_of(next), 0);\n          next = this.enter_port(prev);\n        }\n      }\n    }\n    this.find_redex = true;\n    return stats;\n  }\n\n  // Returns a string that is preserved on reduction, good for debugging\n  denote(ptrn = this.enter_port(Pointer(0, 1)), exit = []) {\n    function path_to_string(path) {\n      var str = \"<\";\n      while (path) {\n        str += path.head === 1 ? \"a\" : \"b\";\n        path = path.tail; \n      }\n      str += \">\";\n      return str;\n    }\n    while (true) {\n      if (type_of(ptrn) === PTR) {\n        var ai = addr_of(ptrn);\n        var as = slot_of(ptrn)\n        var ak = this.kind_of(ai);\n        switch (this.type_of(ai)) {\n          case NOD:\n            if (slot_of(ptrn) === 0) {\n              if (exit[ak]) {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = new_exit[ak].tail;\n                ptrn = this.enter_port(Pointer(ai, Number(exit[ak].head)));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              } else {\n                var lft = this.denote(this.enter_port(Pointer(ai, 1)), exit);\n                var rgt = this.denote(this.enter_port(Pointer(ai, 2)), exit);\n                return \"(\" + ak + \" \" + lft + \" \" + rgt + \")\";\n              }\n            } else {\n              if (ai === 0) {\n                while (exit[exit.length - 1] === null) exit.pop();\n                return exit.map(path_to_string).join(\":\");\n              } else {\n                var new_exit = exit.slice(0);\n                new_exit[ak] = {head: as, tail: new_exit[ak] || null};\n                ptrn = this.enter_port(Pointer(ai, 0));\n                exit = new_exit;\n                continue; // tail-call: denote(ptrn, exit)\n              }\n            }\n            break;\n          default:\n            return \"<TODO>\";\n        }\n      } else {\n        return \"#\" + numb_of(ptrn);\n      }\n    }\n  }\n\n  to_string() {\n    const pointer = (ptrn) => {\n      if (type_of(ptrn) === NUM) {\n        return \"#\" + numb_of(ptrn);\n      } else {\n        return addr_of(ptrn) + \"abc\"[slot_of(ptrn)];\n      }\n    };\n    var text = '';\n    for (var i = 0; i < this.nodes.length / 4; i++) {\n      if (this.is_free(i)) {\n        text += i + \": ~\\n\";\n      } else {\n        var type = this.type_of(i);\n        var kind = this.kind_of(i);\n        text += i + ': ';\n        text += \"[\" + type + \":\" + kind + \"| \";\n        text += pointer(this.get_port(i, 0)) + \" \";\n        text += pointer(this.get_port(i, 1)) + \" \";\n        text += pointer(this.get_port(i, 2)) + \"]\";\n        text += \" ... \" + this.is_numeric(i,0) + \" \" + this.is_numeric(i,1) + \" \" + this.is_numeric(i,2);\n        text += \"\\n\";\n      }\n    }\n    return text;\n  }\n}\n\nmodule.exports = {Pointer, addr_of, slot_of, Numeric, numb_of, type_of, ptrn_eq, ptrn_st, Net, NUM, PTR, NOD, OP1, OP2, ITE};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","module.exports = require('events').EventEmitter;\n","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","require(\"./IBMPlexMono-Light.ttf\");\nconst logo = require(\"./moonad_logo.png\").default;\n\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\n\nconst front = require(\"./front.js\");\nconst Moonad = require(\"./components/Moonad.js\");\n\nwindow.onload = () => render(h(Moonad), document.getElementById(\"main\"));\n","export default __webpack_public_path__ + \"162ab1e6029db4beb906bb26c116458e.ttf\";","export default __webpack_public_path__ + \"24ab2ffd0bab1405a3aebba574edc861.png\";","// Term\n// ====\n\nconst Var = (indx)                     => ({ctor:\"Var\",indx});\nconst Ref = (name)                     => ({ctor:\"Ref\",name});\nconst Typ = ()                         => ({ctor:\"Typ\"});\nconst All = (eras,self,name,bind,body) => ({ctor:\"All\",eras,self,name,bind,body});\nconst Lam = (eras,name,body)           => ({ctor:\"Lam\",eras,name,body});\nconst App = (eras,func,argm)           => ({ctor:\"App\",eras,func,argm});\nconst Let = (name,expr,body)           => ({ctor:\"Let\",name,expr,body});\nconst Ann = (done,expr,type)           => ({ctor:\"Ann\",done,expr,type});\nconst Loc = (from,upto,expr)           => ({ctor:\"Loc\",from,upto,expr});\n\n// List\n// ====\n\nconst Nil = ()          => ({ctor:\"Nil\",size: 0});\nconst Ext = (head,tail) => ({ctor:\"Ext\",head,tail,size:tail.size+1});\n\n// Finds first value satisfying `cond` in a list\nfunction find(list, cond, indx = 0) {\n  switch (list.ctor) {\n    case \"Nil\":\n      return null;\n    case \"Ext\":\n      if (cond(list.head, indx)) {\n        return {value:list.head, index:indx};\n      } else {\n        return find(list.tail, cond, indx + 1);\n      };\n  };\n};\n\n// Syntax\n// ======\n\nfunction stringify(term, depth = 0) {\n  switch (term.ctor) {\n    case \"Var\":\n      return term.indx.split(\"#\")[0];\n    case \"Ref\":\n      return term.name;\n    case \"Typ\":\n      return \"*\";\n    case \"All\":\n      var bind = term.eras ? \"\" : \"\";\n      var self = term.self || (\"x\"+(depth+0));\n      var name = term.name || (\"x\"+(depth+1));\n      var type = stringify(term.bind, depth);\n      var body = stringify(term.body(Var(self+\"#\"), Var(name+\"#\")), depth+2);\n      return bind + self + \"(\" + name + \":\" + type + \") \" + body;\n    case \"Lam\":\n      var bind = term.eras ? \"\" : \"\";\n      var name = term.name || (\"x\"+(depth+0));\n      var body = stringify(term.body(Var(name+\"#\")), depth);\n      return bind + name + \" \" + body;\n    case \"App\":\n      var open = term.eras ? \"<\" : \"(\";\n      var func = stringify(term.func, depth);\n      var argm = stringify(term.argm, depth);\n      var clos = term.eras ? \">\" : \")\";\n      return open + func + \" \" + argm + clos;\n    case \"Let\":\n      var name = term.name || (\"x\"+(depth+0));\n      var expr = stringify(term.expr, depth);\n      var body = stringify(term.body(Var(name+\"#\")), depth+1);\n      return \"$\" + name + \"=\" + expr + \";\" + body;\n    case \"Ann\":\n      var type = stringify(term.type, depth);\n      var expr = stringify(term.expr, depth);\n      return \":\" + type + \" \" + expr;\n    case \"Loc\":\n      return stringify(term.expr, depth);\n  };\n};\n\nfunction parse(code, indx, mode = \"defs\") {\n  function is_name(chr) {\n    var val = chr.charCodeAt(0);\n    return (val >= 46 && val < 47)   // .\n        || (val >= 48 && val < 58)   // 0-9\n        || (val >= 65 && val < 91)   // A-Z\n        || (val >= 95 && val < 96)   // _\n        || (val >= 97 && val < 123); // a-z\n  };\n  function parse_name() {\n    if (indx < code.length && is_name(code[indx])) {\n      return code[indx++] + parse_name();\n    } else {\n      return \"\";\n    }\n  };\n  function parse_nuls() {\n    while (code[indx] === \" \" || code[indx] === \"\\n\") {\n      ++indx;\n    };\n  };\n  function parse_char(chr) {\n    if (indx >= code.length) {\n      throw \"Unexpected eof.\";\n    } else if (code[indx] !== chr) {\n      throw 'Expected \"'+chr+'\", found '+JSON.stringify(code[indx])+' at '+indx+'.';\n    }\n    ++indx;\n  };\n  function parse_term() {\n    parse_nuls();\n    var chr = code[indx++];\n    switch (chr) {\n      case \"*\":\n        return ctx => Typ();\n      case \"\":\n      case \"\":\n        var eras = chr === \"\";\n        var self = parse_name();\n        var skip = parse_char(\"(\");\n        var name = parse_name();\n        var skip = parse_char(\":\");\n        var bind = parse_term();\n        var skip = parse_char(\")\");\n        var body = parse_term();\n        return ctx => All(eras, self, name, bind(ctx), (s,x) => body(Ext([name,x],Ext([self,s],ctx))));\n      case \"\":\n      case \"\":\n        var eras = chr === \"\";\n        var name = parse_name();\n        var body = parse_term();\n        return ctx => Lam(eras, name, (x) => body(Ext([name,x],ctx)));\n      case \"(\":\n      case \"<\":\n        var eras = chr === \"<\";\n        var func = parse_term();\n        var argm = parse_term();\n        var skip = parse_char(eras ? \">\" : \")\");\n        return ctx => App(eras, func(ctx), argm(ctx));\n      case \"$\":\n        var name = parse_name();\n        var skip = parse_char(\"=\");\n        var expr = parse_term();\n        var skip = parse_char(\";\");\n        var body = parse_term();\n        return ctx => Let(name, expr(ctx), x => body(Ext([name,x],ctx)));\n      case \":\":\n        var type = parse_term();\n        var expr = parse_term();\n        return ctx => Ann(false, expr(ctx), type(ctx));\n      default:\n        if (is_name(chr)) {\n          var name = chr + parse_name();\n          return ctx => {\n            var got = find(ctx, (x) => x[0] === name);\n            return got ? got.value[1] : Ref(name);\n          };\n        } else {\n          throw \"Unexpected symbol: '\" + chr + \"'.\";\n        }\n    };\n  };\n  function parse_defs() {\n    parse_nuls();\n    var name = parse_name();\n    if (name.length > 0) {\n      var skip = parse_char(\":\");\n      var type = parse_term()(Nil());\n      var term = parse_term()(Nil());\n      defs[name] = {type, term};\n      parse_defs();\n    }\n  };\n  var indx = 0;\n  if (mode === \"defs\") {\n    var defs = {};\n    parse_defs();\n    return {defs};\n  } else {\n    return parse_term()(Nil());\n  }\n};\n\n// Evaluation\n// ==========\n\nfunction reduce(term, defs, erased = false) {\n  switch (term.ctor) {\n    case \"Var\":\n      return Var(term.indx);\n    case \"Ref\":\n      if (defs[term.name]) {\n        var got = defs[term.name].term;\n        if (got.ctor === \"Loc\" && got.expr.ctor === \"Ref\" && got.expr.name === term.name) {\n          return got;\n        } else {\n          return reduce(got, defs, erased);\n        };\n      } else {\n        return Ref(term.name);\n      }\n    case \"Typ\":\n      return Typ();\n    case \"All\":\n      var eras = term.eras;\n      var self = term.self;\n      var name = term.name;\n      var bind = term.bind;\n      var body = term.body;\n      return All(eras, self, name, bind, body);\n    case \"Lam\":\n      if (erased && term.eras) {\n        return reduce(term.body(Lam(false, \"\", x => x)), defs, erased);\n      } else {\n        var eras = term.eras;\n        var name = term.name;\n        var body = term.body;\n        return Lam(eras, name, body);\n      }\n    case \"App\":\n      if (erased && term.eras) {\n        return reduce(term.func, defs, erased);\n      } else {\n        var eras = term.eras;\n        var func = reduce(term.func, defs, erased);\n        switch (func.ctor) {\n          case \"Lam\":\n            return reduce(func.body(term.argm), defs, erased);\n          default:\n            return App(eras, func, term.argm);\n        };\n      };\n    case \"Let\":\n      var name = term.name;\n      var expr = term.expr;\n      var body = term.body;\n      return reduce(body(expr), defs, erased);\n    case \"Ann\":\n      return reduce(term.expr, defs, erased);\n    case \"Loc\":\n      return reduce(term.expr, defs, erased);\n  };\n}\n\nfunction normalize(term, defs, erased = false, seen = {}) {\n  var norm = reduce(term, defs, erased);\n  var term_hash = hash(term);\n  var norm_hash = hash(norm);\n  if (seen[term_hash] || seen[norm_hash]) {\n    return term;\n  } else {\n    var seen = {...seen, [term_hash]: true, [norm_hash]: true};\n    var norm = reduce(term, defs, erased);\n    switch (norm.ctor) {\n      case \"Var\":\n        return Var(norm.indx);\n      case \"Ref\":\n        return Ref(norm.name);\n      case \"Typ\":\n        return Typ();\n      case \"All\":\n        var eras = norm.eras;\n        var self = norm.self;\n        var name = norm.name;\n        var bind = normalize(norm.bind, defs, erased, seen);\n        var body = (s,x) => normalize(norm.body(s,x), defs, erased, seen);\n        return All(eras, self, name, bind, body);\n      case \"Lam\":\n        var eras = norm.eras;\n        var name = norm.name;\n        var body = x => normalize(norm.body(x), defs, erased, seen);\n        return Lam(eras, name, body);\n      case \"App\":\n        var eras = norm.eras;\n        var func = normalize(norm.func, defs, erased, seen);\n        var argm = normalize(norm.argm, defs, erased, seen);\n        return App(eras, func, argm);\n      case \"Let\":\n        return normalize(norm.body(norm.expr), defs, erased, seen);\n      case \"Ann\":\n        return normalize(norm.expr, defs, erased, seen);\n      case \"Loc\":\n        return normalize(norm.expr, defs, erased, seen);\n    };\n  };\n};\n\n// Equality\n// ========\n\n// Computes the hash of a term. JS strings are hashed, so we just return one.\nfunction hash(term, dep = 0) {\n  switch (term.ctor) {\n    case \"Var\":\n      var indx = Number(term.indx.split(\"#\")[1]);\n      if (indx < 0) {\n        return \"^\"+(dep+indx);\n      } else {\n        return \"#\"+indx;\n      }\n    case \"Ref\":\n      return \"$\" + term.name;\n    case \"Typ\":\n      return \"Type\";\n    case \"All\":\n      var bind = hash(term.bind, dep);\n      var body = hash(term.body(Var(\"#\"+(-dep-1)), Var(\"#\"+(-dep-2))), dep+2);\n      return \"\" + term.self + bind + body;\n    case \"Lam\":\n      var body = hash(term.body(Var(\"#\"+(-dep-1))), dep+1);\n      return \"\" + body;\n    case \"App\":\n      var func = hash(term.func, dep);\n      var argm = hash(term.argm, dep);\n      return \"@\" + func + argm;\n    case \"Let\":\n      var expr = hash(term.expr, dep);\n      var body = hash(term.body(Var(\"#\"+(-dep-1))), dep+1);\n      return \"$\" + expr + body;\n    case \"Ann\":\n      var expr = hash(term.expr, dep);\n      return expr;\n    case \"Loc\":\n      var expr = hash(term.expr, dep);\n      return expr;\n  }\n};\n\n// Are two terms equal?\nfunction equal(a, b, defs, dep = 0, seen = {}) {\n  let a1 = reduce(a, defs, true);\n  let b1 = reduce(b, defs, true);\n  var ah = hash(a1);\n  var bh = hash(b1);\n  var id = ah + \"==\" + bh;\n  if (ah === bh || seen[id]) {\n    return true;\n  } else {\n    seen[id] = true;\n    switch (a1.ctor + b1.ctor) {\n      case \"AllAll\":\n        var a1_body = a1.body(Var(\"#\"+(dep)), Var(\"#\"+(dep+1)));\n        var b1_body = b1.body(Var(\"#\"+(dep)), Var(\"#\"+(dep+1)));\n        return a1.eras === b1.eras\n            && a1.self === b1.self\n            && equal(a1.bind, b1.bind, defs, dep+0, seen)\n            && equal(a1_body, b1_body, defs, dep+2, seen);\n      case \"LamLam\":\n        if (a1.eras !== b1.eras) return [false,a1,b1];\n        var a1_body = a1.body(Var(\"#\"+(dep)));\n        var b1_body = b1.body(Var(\"#\"+(dep)));\n        return a1.eras === b1.eras\n            && equal(a1_body, b1_body, defs, dep+1, seen);\n      case \"AppApp\":\n        return a1.eras === b1.eras\n            && equal(a1.func, b1.func, defs, dep, seen)\n            && equal(a1.argm, b1.argm, defs, dep, seen);\n      case \"LetLet\":\n        var a1_body = a1.body(Var(\"#\"+(dep)));\n        var b1_body = b1.body(Var(\"#\"+(dep)));\n        vis.push([a1.expr, b1.expr, dep]);\n        vis.push([a1_body, b1_body, dep+1]);\n        return equal(a1.expr, b1.expr, defs, dep+0, seen)\n            && equal(a1_body, b1_body, defs, dep+1, seen);\n      case \"AnnAnn\":\n        return equal(a1.expr, b1.expr, defs, dep, seen);\n      case \"LocLoc\":\n        return equal(a1.expr, b1.expr, defs, dep, seen);\n      default:\n        return false;\n    }\n  };\n}\n\n\n// Type-Checking\n// =============\n\nfunction Err(loc, ctx, msg) {\n  return {\n    loc: loc,\n    ctx: ctx,\n    msg: msg,\n  };\n};\n\nfunction typeinfer(term, defs, show = stringify, ctx = Nil(), locs = null) {\n  switch (term.ctor) {\n    case \"Var\":\n      return Var(term.indx);\n    case \"Ref\":\n      var got = defs[term.name];\n      if (got) {\n        return got.type;\n      } else {\n        throw () => Err(locs, ctx, \"Undefined reference '\" + term.name + \"'.\");\n      }\n    case \"Typ\":\n      return Typ();\n    case \"App\":\n      var func_typ = reduce(typeinfer(term.func, defs, show, ctx), defs);\n      switch (func_typ.ctor) {\n        case \"All\":\n          var self_var = Ann(true, term.func, func_typ);\n          var name_var = Ann(true, term.argm, func_typ.bind);\n          typecheck(term.argm, func_typ.bind, defs, show, ctx);\n          var term_typ = func_typ.body(self_var, name_var);\n          if (func_typ.ctor === \"All\" && term.eras !== func_typ.eras) {\n            throw () => Err(locs, ctx, \"Mismatched erasure.\");\n          };\n          return term_typ;\n        default:\n          throw () => Err(locs, ctx, \"Non-function application.\");\n      };\n    case \"Let\":\n      var expr_typ = typeinfer(term.expr, defs, show, ctx);\n      var expr_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), expr_typ);\n      var body_ctx = Ext({name:term.name,type:expr_var.type}, ctx);\n      var body_typ = typeinfer(term.body(expr_var), defs, show, body_ctx);\n      return body_typ;\n    case \"All\":\n      var self_var = Ann(true, Var(term.self+\"#\"+ctx.size), term);\n      var name_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), term.bind);\n      var body_ctx = Ext({name:term.self,type:self_var.type}, ctx);\n      var body_ctx = Ext({name:term.name,type:name_var.type}, body_ctx);\n      typecheck(term.bind, Typ(), defs, show, ctx);\n      typecheck(term.body(self_var,name_var), Typ(), defs, show, body_ctx);\n      return Typ();\n    case \"Ann\":\n      if (!term.done) {\n        typecheck(term.expr, term.type, defs, show, ctx);\n      }\n      return term.type;\n    case \"Loc\":\n      var locs = {from: term.from, upto: term.upto};\n      return typeinfer(term.expr, defs, show, ctx, locs);\n  }\n  throw () => Err(locs, ctx, \"Can't infer type.\");\n};\n\nfunction typecheck(term, type, defs, show = stringify, ctx = Nil(), locs = null) {\n  var typv = reduce(type, defs);\n  switch (term.ctor) {\n    case \"Lam\":\n      if (typv.ctor === \"All\") {\n        var self_var = Ann(true, term, type);\n        var name_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), typv.bind);\n        var body_typ = typv.body(self_var, name_var);\n        if (term.eras !== typv.eras) {\n          throw () => Err(locs, ctx, \"Type mismatch.\");\n        };\n        var body_ctx = Ext({name:term.name,type:name_var.type}, ctx);\n        typecheck(term.body(name_var), body_typ, defs, show, body_ctx);\n      } else {\n        throw () => Err(locs, ctx, \"Lambda has a non-function type.\");\n      }\n      break;\n    case \"Let\":\n      var expr_typ = typeinfer(term.expr, defs, show, ctx);\n      var expr_var = Ann(true, Var(term.name+\"#\"+(ctx.size+1)), expr_typ);\n      var body_ctx = Ext({name:term.name,type:expr_var.type}, ctx);\n      typecheck(term.body(expr_var), type, defs, show, body_ctx);\n      break;\n    case \"Loc\":\n      var locs = {from: term.from, upto: term.upto};\n      typecheck(term.expr, type, defs, show, ctx, locs);\n      break;\n    default:\n      var infr = typeinfer(term, defs, show, ctx);\n      var eq = equal(type, infr, defs, ctx.size);\n      if (!eq) {\n        var type0_str = show(normalize(type, {}, true), ctx);\n        var infr0_str = show(normalize(infr, {}, true), ctx);\n        throw () => Err(locs, ctx,\n          \"Found type... \\x1b[2m\"+infr0_str+\"\\x1b[0m\\n\" +\n          \"Instead of... \\x1b[2m\"+type0_str+\"\\x1b[0m\");\n      }\n      break;\n  };\n  return {term,type};\n};\n\nfunction typesynth(name, defs, show = stringify) {\n  var term = defs[name].term;\n  var type = defs[name].type;\n  defs[name].core = {term, type};\n  return typecheck(term, type, defs, show);\n};\n\nmodule.exports = {\n  Var,\n  Ref,\n  Typ,\n  All,\n  Lam,\n  App,\n  Let,\n  Ann,\n  Loc,\n  Ext,\n  Nil,\n  find,\n  stringify,\n  parse,\n  reduce,\n  normalize,\n  Err,\n  typeinfer,\n  typecheck,\n  typesynth,\n  equal,\n};\n","const fmc = require(\"./FormalitySynt.js\");\nconst fml = require(\"./FormalityLang.js\");\nconst cmp = require(\"./FormalityComp.js\");\n\nvar prim_types = {\n  Unit: {\n    inst: [[0, \"1\"]],\n    elim: {ctag: x => 'unit', ctor: [[]]},\n    cnam: ['unit'],\n  },\n  Bool: {\n    inst: [[0, \"true\"], [0, \"false\"]],\n    elim: {ctag: x => x+\"?'true':'false'\", ctor: [[], []]},\n    cnam: ['true', 'false'],\n  },\n  Nat: {\n    inst: [[0, \"0n\"], [1, p => \"1n+\"+p]],\n    elim: {ctag: x => x+\"===0n?'zero':'succ'\", ctor: [[], [x => \"(\"+x+\"-1n)\"]]},\n    cnam: ['zero', 'succ'],\n  },\n  Bits: {\n    inst: [[0, \"''\"], [1, p=>p+\"+'0'\"], [1, p=>p+\"+'1'\"]],\n    elim: {\n      ctag: x => x+\".length===0?'be':\"+x+\"[\"+x+\".length-1]==='0'?'b0':'b1'\",\n      ctor: [[], [x => x+\".slice(0,-1)\"], [x => x+\".slice(0,-1)\"]],\n    },\n    cnam: ['be', 'b0', 'b1'],\n  },\n  U16: {\n    inst: [[1, x => \"Lam_to_U16(\"+x+\")\"]],\n    elim: {\n      ctag: x => \"'u16'\",\n      ctor: [[x => \"U16_to_Lam(\"+x+\")\"]],\n    },\n    cnam: ['u16'],\n  },\n  U32: {\n    inst: [[1, x => \"Lam_to_U32(\"+x+\")\"]],\n    elim: {\n      ctag: x => \"'u32'\",\n      ctor: [[x => \"U32_to_Lam(\"+x+\")\"]],\n    },\n    cnam: ['u32'],\n  },\n  U64: {\n    inst: [[1, x => \"Lam_to_U64(\"+x+\")\"]],\n    elim: {\n      ctag: x => \"'u64'\",\n      ctor: [[x => \"U64_to_Lam(\"+x+\")\"]],\n    },\n    cnam: ['u64'],\n  },\n  F64: {\n    inst: [[1, x => \"Lam_to_F64(\"+x+\")\"]],\n    elim: {\n      ctag: x => \"'f64'\",\n      ctor: [[x => \"F64_to_Lam(\"+x+\")\"]],\n    },\n    cnam: ['f64'],\n  },\n  String: {\n    inst: [[0,\"''\"], [2, h => t => \"(String.fromCharCode(\"+h+\")+\"+t+\")\"]],\n    elim: {\n      ctag: x => x+\".length===0?'nil':'cons'\",\n      ctor: [[], [x => x+\".charCodeAt(0)\", x => x+\".slice(1)\"]],\n    },\n    cnam: ['nil', 'cons'],\n  },\n};\n\nfunction adt_type(adt) {\n  var inst = [];\n  var elim = {\n    ctag: x => x+\"._\",\n    ctor: [],\n  };\n  var cnam = [];\n  for (let i = 0; i < adt.length; ++i) {\n    inst.push([adt[i].flds.length, (function go(j, ctx) {\n      if (j < adt[i].flds.length) {\n        return x => go(j + 1, ctx.concat([x]));\n      } else {\n        var res = \"({_:'\"+adt[i].name+\"'\";\n        for (var k = 0; k < j; ++k) {\n          res += \",'\"+adt[i].flds[k]+\"':\"+ctx[k];\n        };\n        res += \"})\";\n        return res;\n      };\n    })(0, [])]);\n    elim.ctor.push(adt[i].flds.map((n,j) => (x => x+\".\"+adt[i].flds[j])));\n    cnam.push(adt[i].name);\n  };\n  return {inst, elim, cnam};\n};\n\nvar prim_funcs = {\n  \"Bool.not\"    : [1, a=>`!${a}`],\n  \"Bool.and\"    : [2, a=>b=>`${a}&&${b}`],\n  \"Bool.if\"     : [3, a=>b=>c=>`${a}?${b}:${c}`],\n  \"Bool.or\"     : [2, a=>b=>`${a}||${b}`],\n  \"Debug.log\"   : [2, a=>b=>`(console.log(${a}),${b}())`],\n  \"Nat.add\"     : [2, a=>b=>`${a}+${b}`],\n  \"Nat.sub\"     : [2, a=>b=>`${a}-${b}<=0n?0n:${a}-${b}`],\n  \"Nat.mul\"     : [2, a=>b=>`${a}*${b}`],\n  \"Nat.div\"     : [2, a=>b=>`${a}/${b}`],\n  \"Nat.div_mod\" : [2, a=>b=>`({_:'Pair.new','fst':${a}/${b},'snd':${a}%${b}})`], // TODO change to proper pair\n  \"Nat.pow\"     : [2, a=>b=>`${a}**${b}`],\n  \"Nat.ltn\"     : [2, a=>b=>`${a}<${b}`],\n  \"Nat.lte\"     : [2, a=>b=>`${a}<=${b}`],\n  \"Nat.eql\"     : [2, a=>b=>`${a}===${b}`],\n  \"Nat.gte\"     : [2, a=>b=>`${a}>=${b}`],\n  \"Nat.gtn\"     : [2, a=>b=>`${a}>${b}`],\n  \"U16.add\"     : [2, a=>b=>`${a}+${b}`],\n  \"U16.sub\"     : [2, a=>b=>`Math.max(${a}-${b},0)`],\n  \"U16.mul\"     : [2, a=>b=>`${a}*${b}`],\n  \"U16.div\"     : [2, a=>b=>`(${a}/${b})>>>0`],\n  \"U16.mod\"     : [2, a=>b=>`${a}%${b}`],\n  \"U16.pow\"     : [2, a=>b=>`(${a}**${b})&0xFFFF`],\n  \"U16.ltn\"     : [2, a=>b=>`${a}<${b}`],\n  \"U16.lte\"     : [2, a=>b=>`${a}<=${b}`],\n  \"U16.eql\"     : [2, a=>b=>`${a}===${b}`],\n  \"U16.gte\"     : [2, a=>b=>`${a}>=${b}`],\n  \"U16.gtn\"     : [2, a=>b=>`${a}>${b}`],\n  \"U16.shr\"     : [2, a=>b=>`${a}>>>${b}`],\n  \"U16.shl\"     : [2, a=>b=>`${a}<<${b}`],\n  \"U16.and\"     : [2, a=>b=>`${a}&${b}`],\n  \"U16.or\"      : [2, a=>b=>`${a}|${b}`],\n  \"U16.xor\"     : [2, a=>b=>`${a}^${b}`],\n  \"U32.add\"     : [2, a=>b=>`${a}+${b}`],\n  \"U32.sub\"     : [2, a=>b=>`Math.max(${a}-${b},0)`],\n  \"U32.mul\"     : [2, a=>b=>`${a}*${b}`],\n  \"U32.div\"     : [2, a=>b=>`(${a}/${b})>>>0`],\n  \"U32.mod\"     : [2, a=>b=>`${a}%${b}`],\n  \"U32.pow\"     : [2, a=>b=>`(${a}**${b})>>>0`],\n  \"U32.ltn\"     : [2, a=>b=>`${a}<${b}`],\n  \"U32.lte\"     : [2, a=>b=>`${a}<=${b}`],\n  \"U32.eql\"     : [2, a=>b=>`${a}===${b}`],\n  \"U32.gte\"     : [2, a=>b=>`${a}>=${b}`],\n  \"U32.gtn\"     : [2, a=>b=>`${a}>${b}`],\n  \"U32.shr\"     : [2, a=>b=>`${a}>>>${b}`],\n  \"U32.shl\"     : [2, a=>b=>`${a}<<${b}`],\n  \"U32.and\"     : [2, a=>b=>`${a}&${b}`],\n  \"U32.or\"      : [2, a=>b=>`${a}|${b}`],\n  \"U32.xor\"     : [2, a=>b=>`${a}^${b}`],\n  \"U64.add\"     : [2, a=>b=>`(${a}+${b})&0xFFFFFFFFFFFFFFFFn`],\n  \"U64.sub\"     : [2, a=>b=>`${a}-${b}<=0n?0n:a-b`],\n  \"U64.mul\"     : [2, a=>b=>`(${a}*${b})&0xFFFFFFFFFFFFFFFFn`],\n  \"U64.div\"     : [2, a=>b=>`${a}/${b}`],\n  \"U64.mod\"     : [2, a=>b=>`${a}%${b}`],\n  \"U64.pow\"     : [2, a=>b=>`(${a}**${b})&0xFFFFFFFFFFFFFFFFn`],\n  \"U64.ltn\"     : [2, a=>b=>`(${a}<${b})`],\n  \"U64.lte\"     : [2, a=>b=>`(${a}<=${b})`],\n  \"U64.eql\"     : [2, a=>b=>`(${a}===${b})`],\n  \"U64.gte\"     : [2, a=>b=>`(${a}>=${b})`],\n  \"U64.gtn\"     : [2, a=>b=>`(${a}>${b})`],\n  \"U64.shr\"     : [2, a=>b=>`(${a}>>${b})&0xFFFFFFFFFFFFFFFFn`],\n  \"U64.shl\"     : [2, a=>b=>`(${a}<<${b})&0xFFFFFFFFFFFFFFFFn`],\n  \"U64.and\"     : [2, a=>b=>`${a}&${b}`],\n  \"U64.or\"      : [2, a=>b=>`${a}|${b}`],\n  \"U64.xor\"     : [2, a=>b=>`${a}^${b}`],\n  \"F64.add\"     : [2, a=>b=>`${a}+${b}`],\n  \"F64.sub\"     : [2, a=>b=>`${a}-${b}`],\n  \"F64.mul\"     : [2, a=>b=>`${a}*${b}`],\n  \"F64.div\"     : [2, a=>b=>`${a}/${b}`],\n  \"F64.mod\"     : [2, a=>b=>`${a}%${b}`],\n  \"F64.pow\"     : [2, a=>b=>`${a}**${b}`],\n  \"F64.log\"     : [1, a=>`Math.log(${a})`],\n  \"F64.cos\"     : [1, a=>`Math.cos(${a})`],\n  \"F64.sin\"     : [1, a=>`Math.sin(${a})`],\n  \"F64.tan\"     : [1, a=>`Math.tan(${a})`],\n  \"F64.acos\"    : [1, a=>`Math.acos(${a})`],\n  \"F64.asin\"    : [1, a=>`Math.asin(${a})`],\n  \"F64.atan\"    : [1, a=>`Math.atan(${a})`],\n  \"String.eql\"  : [2, a=>b=>`${a}===${b}`],\n};\n\nvar count = 0;\nfunction fresh() {\n  return \"$\"+(count++);\n};\n\n// Simple substitution, assumes `name` is globally unique.\nfunction subst(term, name, val) {\n  switch (term.ctor) {\n    case \"Var\": return term.name === name ? val : term;\n    case \"Ref\": return cmp.Ref(term.name);\n    case \"Lam\": return cmp.Lam(term.name, term.name === name ? term.body : subst(term.body, name, val));\n    case \"App\": return cmp.App(subst(term.func, name, val), subst(term.argm, name, val));\n    case \"Let\": return cmp.Let(term.name, subst(term.expr, name, val), term.name === name ? term.body : subst(term.body, name, val));\n    case \"Eli\": return cmp.Eli(term.prim, subst(term.expr, name, val));\n    case \"Ins\": return cmp.Ins(term.prim, subst(term.expr, name, val));\n    default: return term;\n  }\n};\n  \n// Inlines a list of arguments in lambdas, as much as possible. Example:\n// apply_inline((x) (y) f, [a, b, c, d, e]) = f[x<-a,y<-b](c)(d)(e)\nfunction apply_inline(term, args) {\n  if (term.ctor === \"Lam\" && args.length > 0) {\n    return apply_inline(subst(term.body, term.name, args[0]), args.slice(1));\n  } else if (args.length > 0) {\n    return apply_inline(cmp.App(term, args[0]), args.slice(1));\n  } else {\n    return term;\n  }\n};\n\n// Builds a lambda by filling a template with args.\nfunction build_from_template(arity, template, args) {\n  var res = \"\";\n  for (var i = args.length; i < arity; ++i) {\n    res += (\"a\"+i)+\"=>\";\n  };\n  var bod = template;\n  for (var i = 0; i < Math.min(args.length, arity); ++i) {\n    bod = bod(js_code(args[i]));\n  };\n  for (var i = args.length; i < arity; ++i) {\n    bod = bod(\"a\"+i);\n  };\n  bod = \"(\"+bod+\")\";\n  for (var i = arity; i < args.length; ++i) {\n    bod = bod+\"(\"+js_code(args[i])+\")\";\n  };\n  return res + bod;\n};\n\nfunction application(func, allow_empty = false) {\n  var args = [];\n  while (func && func.ctor === \"App\") {\n    args.push(func.argm);\n    func = func.func;\n  };\n  args.reverse();\n\n  // Primitive function application\n  if (func && (allow_empty || args.length > 0) && func.ctor === \"Ref\" && prim_funcs[func.name]) {\n    var [arity, template] = prim_funcs[func.name];\n    return build_from_template(arity, template, args);\n\n  // Primitive type elimination\n  } else if (func && (allow_empty || args.length > 0) && func.ctor === \"Eli\") {\n    if (typeof func.prim === \"string\" && prim_types[func.prim]) {\n      var type_info = prim_types[func.prim];\n    } else if (typeof func.prim === \"object\") {\n      var type_info = adt_type(func.prim);\n    } else {\n      return null;\n    };\n    var {ctag, ctor} = type_info.elim;\n    var cnam = type_info.cnam;\n    var res = \"(()=>\";\n    for (var i = args.length; i < ctor.length; ++i) {\n      res += (\"c\"+i)+\"=>\";\n    };\n    res += \"{\";\n    res += \"var self=\"+js_code(func.expr)+\";\";\n    res += \"switch(\"+ctag(\"self\")+\"){\";\n    for (var i = 0; i < ctor.length; ++i) {\n      res += \"case '\"+cnam[i]+\"':\";\n      var fargs = [];\n      for (var j = 0; j < ctor[i].length; ++j) {\n        var nam = fresh();\n        res += \"var \"+nam+\"=\"+ctor[i][j](\"self\")+\";\"\n        fargs.push(cmp.Var(nam));\n      };\n      var ret = apply_inline(args[i] || cmp.Var(\"c\"+i), fargs);\n      res += \"return \"+js_code(ret)+\";\";\n    };\n    res += \"}})()\";\n    for (var i = ctor.length; i < args.length; ++i) {\n      res += \"(\"+js_code(args[i])+\")\";\n    };\n    return res;\n  }\n  return null;\n};\n\nfunction instantiation(term) {\n  if (term.ctor === \"Ins\") {\n    if (typeof term.prim === \"string\" && prim_types[term.prim]) {\n      var templates = prim_types[term.prim].inst;\n    } else if (typeof term.prim === \"object\") {\n      var templates = adt_type(term.prim).inst;\n    } else {\n      return null;\n    }\n    term = term.expr;\n    var vars = [];\n    while (term.ctor === \"Lam\") {\n      vars.push(term.name);\n      term = term.body;\n    }\n    if (templates.length === vars.length) {\n      var func = term;\n      var args = [];\n      while (func.ctor === \"App\") { \n        args.push(func.argm);\n        func = func.func;\n      };\n      args.reverse();\n      if (func.ctor === \"Var\" || func.ctor === \"Ref\") {\n        for (var i = 0; i < vars.length; ++i) {\n          if (func.name === vars[i]) {\n            var [ctor_arity, ctor_template] = templates[i];\n            if (ctor_arity === args.length) {\n              var res = ctor_template;\n              for (var arg of args) {\n                res = res(js_code(arg));\n              };\n              return res;\n            };\n          }\n        };\n      };\n    };\n  };\n  return null;\n};\n\nfunction instantiator(inst) {\n  var ctors = inst;\n  var res = \"x=>x\";\n  for (var i = 0; i < ctors.length; ++i) {\n    res += \"(\";\n    var [ctor_arity, ctor_template] = ctors[i];\n    for (var j = 0; j < ctor_arity; ++j) {\n      res += \"x\"+j+\"=>\";\n    };\n    var bod = ctor_template;\n    for (var j = 0; j < ctor_arity; ++j) {\n      bod = bod(\"x\"+j);\n    };\n    res += bod+\")\";\n  };\n  return res;\n};\n\nfunction flatten_lets(term) {\n  var res = \"(()=>{\";\n  while (term.ctor === \"Let\") {\n    res += \"var \"+js_name(term.name)+\"=\"+js_code(term.expr)+\";\";\n    term = term.body;\n  };\n  res += \"return \"+js_code(term)+\"})()\";\n  return res;\n};\n\n// Checks if a function is recursive and tail-safe.\nfunction recursion(term, name) {\n  // Used by tail-call detection. If this application is the elimination of a\n  // native type, then its arguments are all in tail position.\n  function get_branches(term) {\n    var done = false;\n    var func = term;\n    var args = [];\n    while (func.ctor === \"App\") {\n      args.push(func.argm);\n      func = func.func;\n    };\n    args.reverse();\n    if (func.ctor === \"Eli\") {\n      //console.log(\"- Possibly branch safe.\", name, func.prim);\n      if (typeof func.prim === \"string\" && prim_types[func.prim]) {\n        var type_info = prim_types[func.prim];\n      } else if (typeof func.prim === \"object\") {\n        var type_info = adt_type(func.prim);\n      } else {\n        return null;\n      }\n      if (args.length === type_info.inst.length) {\n        //console.log(\"- Correct case count.\");\n        var branches = [];\n        for (var i = 0; i < args.length; ++i) {\n          var fields = type_info.inst[i][0];\n          var branch = args[i];\n          //console.log(\"...\", i, fields, type_info.inst[i], branch);\n          var arity = 0;\n          while (arity < fields && branch.ctor === \"Lam\") {\n            arity += 1;\n            branch = branch.body;\n          }\n          if (arity === fields) {\n            //console.log(\"- Correct field count on branch \"+i+\".\");\n            branches.push(branch);\n          }\n        }\n        if (args.length === branches.length) {\n          return {func, branches};\n        }\n      }\n    }\n    return null;\n  };\n  var args = [];\n  while (term.ctor === \"Lam\") {\n    args.push(term.name);\n    term = term.body;\n  };\n  var is_recursive = false;\n  var is_tail_safe = true;\n  function check(term, tail) {\n    switch (term.ctor) {\n      case \"Lam\":\n        check(term.body, tail);\n        break;\n      case \"App\":\n        var got = tail && get_branches(term);\n        if (got) {\n          check(got.func, tail);\n          for (var branch of got.branches) {\n            check(branch, tail);\n          };\n        } else {\n          check(term.func, tail);\n          check(term.argm, false);\n        };\n        break;\n      case \"Let\":\n        check(term.expr, tail);\n        check(term.body, tail);\n        break;\n      case \"Eli\":\n        check(term.expr, tail);\n        break;\n      case \"Ins\":\n        check(term.expr, tail);\n        break;\n      case \"Ref\":\n        if (term.name === name) {\n          is_recursive = true;\n          is_tail_safe = is_tail_safe && tail;\n        };\n        break;\n    };\n  };\n  check(term, true);\n  if (is_recursive) {\n    return {tail: is_tail_safe, args};\n  }\n  return null;\n};\n\nfunction js_code(term, name = null) {\n  var rec = recursion(term, name);\n  var app = application(term);\n  var ins = instantiation(term);\n  if (rec && rec.tail) {\n    var vars = [];\n    var code = \"\";\n    while (term.ctor === \"Lam\") {\n      vars.push(term.name);\n      code = code + js_name(term.name)+\"=>\";\n      term = term.body;\n    }\n    code += \"{\";\n    code += \"var \"+js_name(name)+\"=\";\n    code += vars.map(v => js_name(v)+\"=>\").join(\"\");\n    code += \"({ctr:'TCO',arg:[\"+vars.map(js_name).join(\",\")+\"]});\";\n    code += \"while(true){\";\n    code += \"var R=\"+js_code(term)+\";\";\n    code += \"if(R.ctr==='TCO')[\"+vars.map(js_name).join(\",\")+\"]=R.arg;\";\n    code += \"else return R;\";\n    code += \"}}\";\n    return code;\n  } else if (app) {\n    return app;\n  } else if (ins) {\n    return ins;\n  } else if (typeof term === \"string\") {\n    return term;\n  } else {\n    switch (term.ctor) {\n      case \"Var\":\n        return js_name(term.name);\n      case \"Ref\":\n        return js_name(term.name);\n      case \"Nul\":\n        return \"null\";\n      case \"Lam\":\n        return \"(\"+js_name(term.name)+\"=>\"+js_code(term.body)+\")\";\n      case \"App\":\n        return js_code(term.func)+\"(\"+js_code(term.argm)+\")\";\n      case \"Let\":\n        return flatten_lets(term);\n      case \"Eli\":\n        if (typeof term.prim === \"string\") {\n          return \"elim_\"+term.prim.toLowerCase()+\"(\"+js_code(term.expr)+\")\";\n        } else {\n          throw \"Internal compiler error. Please report on https://github.com/moonad/formality.\";\n        }\n      case \"Ins\":\n        if (typeof term.prim === \"string\") {\n          return \"inst_\"+term.prim.toLowerCase()+\"(\"+js_code(term.expr)+\")\";\n        } else {\n          throw \"Internal compiler error. Please report on https://github.com/moonad/formality.\";\n        }\n      case \"Nat\":\n        return term.natx+\"n\";\n      case \"Chr\":\n        return term.chrx.charCodeAt(0);\n      case \"Str\":\n        return \"`\"+term.strx+\"`\";\n    };\n  };\n};\n\nfunction js_name(str) {\n  return str.replace(/\\./g,\"$\");\n};\n\nfunction compile(main, defs, only_expression = false) {\n  //console.log(\"compiling \", main);\n  var {defs: cmps, nams} = cmp.core_to_comp(defs, main);\n\n  var used_prim_types = {}; \n  for (var prim in prim_types) {\n    if (defs[prim]) used_prim_types[prim] = prim_types[prim];\n  };\n  var used_prim_funcs = {};\n  for (var prim in prim_funcs) {\n    if (defs[prim]) used_prim_funcs[prim] = prim_funcs[prim];\n  };\n\n  // Builds header and initial dependencies\n  var isio = fmc.equal(defs[main].type, fmc.App(false, fmc.Ref(\"IO\"), fmc.Ref(\"Unit\")), defs);\n  var code = \"\";\n  if (!only_expression) {\n    code += \"module.exports = \";\n  };\n  code += \"(function (){\\n\";\n  if (used_prim_types[\"U16\"]) {\n    code += \"  var Lam_to_U16 = x=>(function R(x,k){return x(0)(p=>R(p,k*2))(p=>k+R(p,k*2))})(x,1);\\n\";\n    code += \"  var U16_to_Lam = x=>((function R(i){return we=>w0=>w1=>i===16?we:((x>>>i)&1?w1:w0)(R(i+1))})(0));\\n\";\n  };\n  if (used_prim_types[\"U32\"]) {\n    code += \"  var Lam_to_U32 = x=>(function R(x,k){return x(0)(p=>R(p,k*2))(p=>k+R(p,k*2))})(x,1);\\n\";\n    code += \"  var U32_to_Lam = x=>((function R(i){return we=>w0=>w1=>i===32?we:((x>>>i)&1?w1:w0)(R(i+1))})(0));\\n\";\n  };\n  if (used_prim_types[\"U64\"]) {\n    code += \"  var Lam_to_U32 = x=>(function R(x,k){return x(0n)(p=>R(p,k*2n))(p=>k+R(p,k*2n))})(x,1n);\\n\";\n    code += \"  var U32_to_Lam = x=>((function R(i){return we=>w0=>w1=>i===64n?we:((x>>i)&1n?w1:w0)(R(i+1n))})(0n));\\n\";\n  };\n  if (used_prim_types[\"F64\"]) {\n    code += \"  var F64 = new Float64Array(1);\\n\";\n    code += \"  var U32 = new Uint32Array(F64.buffer);\\n\";\n    code += \"  var F64_get = (x,i)=>((F64[0]=x),(i<32?(U32[0]>>>i)&1:(U32[1]>>>(i-32)&1)));\\n\";\n    code += \"  var F64_set = (x,i)=>((F64[0]=x),(i<32?(U32[0]=U32[0]|(1<<i)):(U32[1]=U32[1]|(1<<(i-32)))),F64[0]);\\n\";\n    code += \"  var Lam_to_F64 = x=>(function R(x,i){return x(0)(p=>R(p,i+1))(p=>F64_set(R(p,i+1),i))})(x,0);\";\n    code += \"  var F64_to_Lam = x=>((function R(i){return we=>w0=>w1=>i===64?we:(F64_get(x,i)?w1:w0)(R(i+1))})(0));\";\n  };\n  for (var prim in used_prim_types) {\n    code += \"  var inst_\"+prim.toLowerCase()+\" = \"+instantiator(used_prim_types[prim].inst)+\";\\n\";\n    code += \"  var elim_\"+prim.toLowerCase()+\" = \"+js_code(cmp.Lam(\"x\", application(cmp.Eli(prim, cmp.Var(\"x\")), true)))+\";\\n\";\n  };\n  if (isio) {\n    code += \"  var rdl = require('readline').createInterface({input:process.stdin,output:process.stdout});\\n\";\n    code += \"  var run = (p) => {\\n\";\n    code += \"    switch (p._) {\\n\";\n    code += \"      case 'IO.end': return Promise.resolve(p.val);\\n\";\n    code += \"      case 'IO.log': return new Promise((res,_) => (console.log(p.str), run(p.nxt(1)).then(res)));\\n\";\n    code += \"      case 'IO.get': return new Promise((res,_) => rdl.question('', (line) => run(p.nxt(line)).then(res)));\\n\";\n    code += \"    }\\n\";\n    code += \"  };\\n\";\n    //code += \"    var case_end = (val) => Promise.resolve(val);\\n\";\n    //code += \"    var case_log = (str) => (nxt) => new Promise((res,_) => (console.log(str), run(nxt(1)).then(res)));\\n\";\n    //code += \"    var case_inp = (nxt) => new Promise((res,_) => rdl.question('', (line) => run(nxt(line)).then(res)));\\n\";\n    //code += \"    return p(case_end)(case_log)(case_inp);\\n\";\n    //code += \"  };\\n\";\n  }\n\n  // Builds each top-level definition\n  var exps = [];\n  compile_def: for (var name of nams) {\n    // Don't compile primitive types\n    if (used_prim_types[name]) {\n      continue;\n    };\n\n    // Generate JS expression\n    var expr = null;\n    if (used_prim_funcs[name]) {\n      expr = application(cmp.Ref(name), true);\n    } else {\n      try {\n        var comp = cmps[name];\n        var type = defs[name].type;\n        if (fmc.equal(type, fmc.Typ(), defs)) {\n          continue;\n        } else {\n          expr = js_code(comp, name);\n        }\n      } catch (e) {\n        console.log(e);\n        expr = \"'ERROR'\";\n      };\n    };\n\n    // Adds to code and register export\n    code += \"  var \"+js_name(name)+\" = \"+expr+\";\\n\";\n    exps.push(name);\n  };\n\n  // Builds export list\n  code += \"  return {\\n\";\n  if (isio) {\n    code += \"    '$main$': ()=>run(\"+js_name(main)+\"),\\n\"\n  };\n  for (var name of exps) {\n    code += \"    '\"+name+\"': \"+js_name(name)+\",\\n\";\n  };\n  code += \"  };\\n\";\n  code += \"})();\";\n\n  // Builds last line to call exported main\n  if (!only_expression) {\n    if (isio) {\n      code += \"\\nmodule.exports['$main$']().then(() => process.exit());\";\n    } else {\n      code += \"\\nconsole.log(module.exports['\"+main+\"']);\";\n    };\n  };\n\n  return code;\n};\n\nmodule.exports = {compile};\n","const {Var, App, Lam, Ref, Ext, Nil, find} = require(\"./FormalitySynt.js\");\nconst {Net, Pointer, addr_of, slot_of, numb_of, ptrn_eq, ptrn_st, NOD} = require(\"./FormalityInet.js\");\n\nfunction erase(term, dep = 0) {\n  const id = {ctor: \"Lam\", body: {ctor: \"Var\", indx: 0}};\n  switch (term.ctor) {\n    case \"Var\":\n      return {\n        ctor: \"Var\",\n        indx: dep - term.indx - 1,\n      };\n    case \"Ref\":\n      return {ctor: \"Ref\", name: term.name};\n    case \"Typ\":\n      return id;\n    case \"All\":\n      return id;\n    case \"Lam\":\n      if (term.eras) {\n        return erase(term.body(id), dep);\n      } else {\n        return {\n          ctor: \"Lam\",\n          name: term.name,\n          body: erase(term.body({ctor: \"Var\", indx: dep}), dep + 1),\n        };\n      }\n    case \"App\":\n      if (term.eras) {\n        return erase(term.func, dep);\n      } else {\n        return {\n          ctor: \"App\",\n          func: erase(term.func, dep),\n          argm: erase(term.argm, dep),\n        };\n      }\n    case \"Let\":\n      if (term.dups) {\n        return {\n          ctor: \"Let\",\n          name: term.name,\n          expr: erase(term.expr, dep),\n          body: erase(term.body({ctor: \"Var\", indx: dep}), dep + 1),\n        };\n      } else {\n        return erase(term.body(term.expr), dep);\n      }\n    case \"Ann\":\n      return erase(term.expr, dep);\n    case \"Loc\":\n      return erase(term.expr, dep);\n    case \"Hol\":\n      throw \"Can't compile hole.\";\n  };\n};\n\nfunction compile(fm_term, defs = {}) {\n  var term = erase(fm_term);\n  const ref_ptrs = {};\n  const build_net = (term, net, var_ptrs, level) => {\n    const get_var = (ptrn) => {\n      if (ptrn_eq(net.enter_port(ptrn), ptrn)) {\n        return ptrn;\n      } else {\n        var dups_ptrn = net.enter_port(ptrn);\n        var dup_addr = net.alloc_node(NOD, Math.floor(Math.random()*(2**24)) + 1);\n        net.link_ports(Pointer(dup_addr, 0), ptrn);\n        net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n        return Pointer(dup_addr, 2);\n      }\n    };\n    switch (term.ctor) {\n      case \"Let\":\n        var expr_ptr = build_net(term.expr, net, var_ptrs, level);\n        level_of[ptrn_st(expr_ptr)] = level;\n        var_ptrs.push(expr_ptr);\n        var body_ptr = build_net(term.body, net, var_ptrs, level);\n        var_ptrs.pop();\n        return body_ptr;\n      case \"Lam\":\n        var lam_addr = net.alloc_node(NOD, 0);\n        net.link_ports(Pointer(lam_addr, 1), Pointer(lam_addr, 1));\n        level_of[ptrn_st(Pointer(lam_addr, 1))] = level;\n        var_ptrs.push(Pointer(lam_addr, 1));\n        var body_ptr = build_net(term.body, net, var_ptrs, level);\n        var_ptrs.pop();\n        net.link_ports(Pointer(lam_addr, 2), body_ptr);\n        return Pointer(lam_addr, 0);\n      case \"App\":\n        var app_addr = net.alloc_node(NOD, 0);\n        var func_ptr = build_net(term.func, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 0), func_ptr);\n        var argm_ptr = build_net(term.argm, net, var_ptrs, level);\n        net.link_ports(Pointer(app_addr, 1), argm_ptr)\n        return Pointer(app_addr, 2);\n      case \"Var\":\n        return get_var(var_ptrs[var_ptrs.length - term.indx - 1]);\n      case \"Ref\":\n        var ref_ptrn = ref_ptrs[term.name];\n        // First time seeing this ref\n        if (!ref_ptrn) {\n          // Create a dup node for it and recurse\n          var dup_addr = net.alloc_node(NOD, 0xFFFD);\n          var ref_ptrn = Pointer(dup_addr, 1);\n          ref_ptrs[term.name] = ref_ptrn;\n          var dref = erase(defs[term.name].term);\n          var dref_ptr = build_net(dref, net, var_ptrs, level);\n          net.link_ports(Pointer(dup_addr, 0), dref_ptr);\n          return Pointer(dup_addr, 2);\n        // Already created the dup node for this ref\n        } else {\n          // First use: just connect to the port 1 of the dup node\n          if (ptrn_eq(net.enter_port(ref_ptrn), ref_ptrn)) {\n            return ref_ptrn;\n          // Other uses: extend with another dup node and connect\n          } else {\n            var dups_ptrn = net.enter_port(ref_ptrn);\n            var dup_addr = net.alloc_node(NOD, 0xFFFD);\n            net.link_ports(Pointer(dup_addr, 0), ref_ptrn);\n            net.link_ports(Pointer(dup_addr, 1), dups_ptrn);\n            return Pointer(dup_addr, 2);\n          }\n        }\n      default:\n        throw \"Internal error.\";\n        //return build_net(Lam(\"\", null, Var(0), false), net, var_ptrs, level);\n    }\n  };\n  var level_of = {};\n  var net = new Net();\n  var root_addr = net.alloc_node(NOD, 0);\n  var term_ptr = build_net(term, net, [], 0);\n  net.link_ports(Pointer(root_addr, 0), Pointer(root_addr, 2));\n  net.link_ports(Pointer(root_addr, 1), term_ptr);\n  // Removes invalid redexes. They can be created by the\n  // compiler when duplicating variables more than once.\n  net.redex = net.redex.filter((a_addr) => {\n    var b_ptrn = net.enter_port(Pointer(a_addr, 0));\n    var b_addr = addr_of(b_ptrn);\n    var a_p0 = Pointer(a_addr, 0);\n    var b_p0 = Pointer(b_addr, 0);\n    var a_ok = ptrn_eq(net.enter_port(a_p0), b_p0);\n    var b_ok = ptrn_eq(net.enter_port(b_p0), a_p0);\n    return a_ok && b_ok;\n  });\n  // Optimization: if a ref is only used once, remove the unecessary dup node\n  for (var name in ref_ptrs) {\n    var ref_ptrn = ref_ptrs[name];\n    if (ptrn_eq(net.enter_port(ref_ptrn), ref_ptrn)) {\n      var dup_addr = addr_of(ref_ptrn);\n      var ref_ptrn = net.enter_port(Pointer(dup_addr, 0));\n      var loc_ptrn = net.enter_port(Pointer(dup_addr, 2));\n      net.link_ports(ref_ptrn, loc_ptrn);\n      net.free_node(dup_addr);\n    }\n  }\n  return net;\n};\n\nfunction decompile(net) {\n  const build_term = (net, ptrn, var_ptrs, dup_exit) => {\n    var addr = addr_of(ptrn);\n    var kind = net.kind_of(addr);\n    if (kind === 0) {\n      switch (slot_of(ptrn)) {\n        case 0:\n          var_ptrs.push(Pointer(addr, 1));\n          var body = build_term(net, net.enter_port(Pointer(addr, 2)), var_ptrs, dup_exit);\n          var_ptrs.pop();\n          var vlen = var_ptrs.length;\n          return ctx => {\n            var t_name = \"x\" + vlen;\n            var t_body = x => body(Ext([t_name,x], ctx));\n            return Lam(false, t_name, t_body);\n          };\n        case 1:\n          for (var index = 0; index < var_ptrs.length; ++index) {\n            if (ptrn_eq(var_ptrs[var_ptrs.length - index - 1], ptrn)) {\n              return ctx => find(ctx, (x,i) => i === index).value[1];\n            }\n          }\n        case 2:\n          var argm = build_term(net, net.enter_port(Pointer(addr, 1)), var_ptrs, dup_exit);\n          var func = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n          return ctx => App(false, func(ctx), argm(ctx));\n      }\n    } else {\n      switch (slot_of(ptrn)) {\n        case 0:\n          var exit = dup_exit.pop();\n          var term = build_term(net, net.enter_port(Pointer(addr, exit)), var_ptrs, dup_exit);\n          dup_exit.push(exit);\n          return term;\n        default:\n          dup_exit.push(slot_of(ptrn));\n          var term = build_term(net, net.enter_port(Pointer(addr, 0)), var_ptrs, dup_exit);\n          dup_exit.pop();\n          return term;\n      }\n    }\n  };\n  return build_term(net, net.enter_port(Pointer(0, 1)), [], [])(Nil());\n};\n\nfunction normalize(term, defs = {}, lazy = true) {\n  var net = compile(term, defs);\n  var stats = lazy ? net.reduce_lazy() : net.reduce();\n  var term = decompile(net);\n  return {term, stats};\n};\n\nmodule.exports = {erase, compile, decompile, normalize};\n","var req = require(\"xhr-request-promise\");\nvar sig = require(\"nano-ethereum-signer\");\nvar Peer = require(\"simple-peer\");\nvar lib = require(\"./lib.js\");\nvar WebSocket = require('isomorphic-ws')\n\nmodule.exports = ({url = \"http://moonad.org\"}) => {\n\n  async function request(method, query) {\n    return await req(url+\"/\"+method, {method:\"POST\", query});\n  };\n\n  async function query(method, query) {\n    var response = await req(url+\"/\"+method, {method:\"POST\", query});\n    if (response.slice(0,2) === \"0x\") {\n      return response;\n    } else {\n      throw response;\n    }\n  };\n\n  async function post(post, pkey) {\n    return await query(\"post\", lib.sign_post(post, pkey));\n  };\n\n  async function register({name, addr}) {\n    return await query(\"register\", {name, addr});\n  };\n\n  async function get({key}) {\n    return await query(\"get\", {key});\n  };\n\n  async function get_orig({name}) {\n    return await get({key: name+\".orig\"});\n  };\n\n  async function get_deps({name}) {\n    return lib.hex_to_string(await get({key: name+\".deps\"}))\n      .split(\";\")\n      .filter(s => s !== \"\");\n  };\n\n  async function get_addr({name}) {\n    return lib.hex_to_string(await get({key: name+\".addr\"}));\n  };\n\n  async function get_name({addr}) {\n    return lib.hex_to_string(await get({key: addr+\".name\"}));\n  };\n\n  async function get_cite({poid}) {\n    return lib.split_hex_in_chunks(64, await get({key: poid+\".cite\"}));\n  };\n\n  async function get_refs({poid}) {\n    return lib.split_hex_in_chunks(64, await get({key: poid+\".refs\"}));\n  };\n\n  async function get_post({poid}) {\n    return lib.hex_to_post(await get({key: poid+\".post\"}));\n  };\n\n  function direct() {\n    var self = {};\n    self.post = {}; // Map Poid Post\n    self.cite = {}; // Map Poid [Poid]\n    self.name = {}; // Map Addr String\n    self.orig = {};\n    self.deps = {};\n    self.ws = new WebSocket(url.replace(\"http\",\"ws\")+\"/\");\n\n    self.api = {};\n    self.api.request = request;\n    self.api.query = query;\n    self.api.post = post;\n    self.api.register = register;\n    self.api.get = get;\n    self.api.get_addr = get_addr;\n    self.api.get_cite = get_cite;\n    self.api.get_refs = get_refs;\n    self.api.get_orig = async function ({name}) {\n      if (!self.orig[name]) {\n        self.orig[name] = await get_orig({name});\n      }\n      return self.orig[name];\n    };\n    self.api.get_deps = async function ({name}) {\n      if (!self.deps[name]) {\n        self.deps[name] = await get_deps({name});\n      }\n      return self.deps[name];\n    };\n    self.api.get_name = async function ({addr}) {\n      if (!self.name[addr]) {\n        self.name[addr] = await get_name({addr});\n      };\n      return self.name[addr];\n    };\n    self.api.get_post = async function ({poid}) {\n      if (!self.post[poid]) {\n        self.post[poid] = await get_post({poid});\n      };\n      return self.post[poid];\n    };\n    self.lib = lib;\n\n    self.do_watch = (poid) => {\n      self.ws.send(lib.bytes_concat([\n        [lib.DO_WATCH],\n        lib.hex_to_bytes(poid),\n      ]));\n    };\n\n    self.do_post = (post, pkey) => {\n      //console.log(\"posting\", lib.bytes_concat([\n        //[lib.POST],\n        //lib.post_to_bytes(lib.sign_post(post, pkey)),\n      //]));\n      self.ws.send(lib.bytes_concat([\n        [lib.DO_POST],\n        lib.post_to_bytes(lib.sign_post(post, pkey)),\n      ]));\n    };\n\n    self.ws.binaryType = \"arraybuffer\";\n\n    self.ws.onopen = async function() {\n      console.log(\"ws: connected\");\n    };\n\n    self.ws.onmessage = async (msg) => {\n      var data = new Uint8Array(msg.data);\n      console.log(\"ws: got\", data);\n      var indx = 0;\n      while (indx < data.length) {\n        switch (data[indx]) {\n          case lib.POST:\n            var poid = lib.bytes_to_hex(data.slice(indx+1, indx+9));\n            var plen = lib.bytes_to_uint32(data.slice(indx+9, indx+13));\n            var post = lib.bytes_to_post(data.slice(indx+13, indx+13+plen));\n            indx += 13+plen;\n            self.post[poid] = post;\n            //console.log(\"Got post \"+poid+\":\", JSON.stringify(post));\n            break;\n          case lib.CITE:\n            var poid = lib.bytes_to_hex(data.slice(indx+1, indx+9));\n            var from = lib.bytes_to_uint32(data.slice(indx+9, indx+13));\n            var upto = lib.bytes_to_uint32(data.slice(indx+13, indx+17));\n            self.cite[poid] = self.cite[poid] || [];\n            for (var i = from; i < upto; ++i) {\n              self.cite[poid][i] = lib.bytes_to_hex(data.slice(indx+17+(i-from)*8, indx+17+(i-from)*8+8));\n              //console.log(\"Got cite \"+i+\":\", self.cite[poid][i]);\n            };\n            indx += 17+i*8+8;\n            break;\n          case lib.NAME:\n            var addr = lib.bytes_to_hex(data.slice(indx+1, indx+21));\n            var nlen = lib.bytes_to_uint32(data.slice(indx+21, indx+25));\n            var name = lib.bytes_to_string(data.slice(indx+25, indx+25+nlen));\n            self.name[addr] = name;\n            indx += 25 + nlen;\n            //console.log(\"Got name: \"+addr+\" \"+name);\n            break;\n          case lib.ROOM:\n            // TODO\n            break;\n          default:\n            process.exit();\n        };\n      };\n    };\n\n    return self;\n  };\n\n  return {\n    request,\n    query,\n    post,\n    register,\n    get,\n    get_name,\n    get_addr,\n    get_refs,\n    get_cite,\n    get_post,\n    direct,\n  };\n};\n//(async () => {\n  //var moonad = module.exports({url: \"http://localhost\"}).direct();\n  ////setInterval(() => {\n    ////console.log(moonad.cite);\n  ////}, 1000);\n\n  //var pkey = \"0x000000000000000000000000000000000000000000000000000000000000000000000001\";\n  //var addr = sig.addressFromKey(pkey);\n  ////moonad.api.register({addr, name: \"Foo\"});\n\n  //setTimeout(() => {\n    //moonad.do_post({cite:\"0x0000000000000000\", head: \"abc\", body: \"def\"}, pkey);\n  //}, 2500);\n\n//})();\n","var request = require('xhr-request')\n\nmodule.exports = function (url, options) {\n  return new Promise(function (resolve, reject) {\n    request(url, options, function (err, data) {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n};\n","var queryString = require('query-string')\nvar setQuery = require('url-set-query')\nvar assign = require('object-assign')\nvar ensureHeader = require('./lib/ensure-header.js')\n\n// this is replaced in the browser\nvar request = require('./lib/request.js')\n\nvar mimeTypeJson = 'application/json'\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (url, opt, cb) {\n  if (!url || typeof url !== 'string') {\n    throw new TypeError('must specify a URL')\n  }\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n  if (cb && typeof cb !== 'function') {\n    throw new TypeError('expected cb to be undefined or a function')\n  }\n\n  cb = cb || noop\n  opt = opt || {}\n\n  var defaultResponse = opt.json ? 'json' : 'text'\n  opt = assign({ responseType: defaultResponse }, opt)\n\n  var headers = opt.headers || {}\n  var method = (opt.method || 'GET').toUpperCase()\n  var query = opt.query\n  if (query) {\n    if (typeof query !== 'string') {\n      query = queryString.stringify(query)\n    }\n    url = setQuery(url, query)\n  }\n\n  // allow json response\n  if (opt.responseType === 'json') {\n    ensureHeader(headers, 'Accept', mimeTypeJson)\n  }\n\n  // if body content is json\n  if (opt.json && method !== 'GET' && method !== 'HEAD') {\n    ensureHeader(headers, 'Content-Type', mimeTypeJson)\n    opt.body = JSON.stringify(opt.body)\n  }\n\n  opt.method = method\n  opt.url = url\n  opt.headers = headers\n  delete opt.query\n  delete opt.json\n\n  return request(opt, cb)\n}\n","'use strict';\nvar strictUriEncode = require('strict-uri-encode');\nvar objectAssign = require('object-assign');\nvar decodeComponent = require('decode-uri-component');\n\nfunction encoderForArrayFormat(opts) {\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, index) {\n\t\t\t\treturn value === null ? [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tindex,\n\t\t\t\t\t']'\n\t\t\t\t].join('') : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[',\n\t\t\t\t\tencode(index, opts),\n\t\t\t\t\t']=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'[]=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value) {\n\t\t\t\treturn value === null ? encode(key, opts) : [\n\t\t\t\t\tencode(key, opts),\n\t\t\t\t\t'=',\n\t\t\t\t\tencode(value, opts)\n\t\t\t\t].join('');\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(opts) {\n\tvar result;\n\n\tswitch (opts.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t} else if (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn function (key, value, accumulator) {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction encode(value, opts) {\n\tif (opts.encode) {\n\t\treturn opts.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t} else if (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input)).sort(function (a, b) {\n\t\t\treturn Number(a) - Number(b);\n\t\t}).map(function (key) {\n\t\t\treturn input[key];\n\t\t});\n\t}\n\n\treturn input;\n}\n\nfunction extract(str) {\n\tvar queryStart = str.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\treturn str.slice(queryStart + 1);\n}\n\nfunction parse(str, opts) {\n\topts = objectAssign({arrayFormat: 'none'}, opts);\n\n\tvar formatter = parserForArrayFormat(opts);\n\n\t// Create an object with no prototype\n\t// https://github.com/sindresorhus/query-string/issues/47\n\tvar ret = Object.create(null);\n\n\tif (typeof str !== 'string') {\n\t\treturn ret;\n\t}\n\n\tstr = str.trim().replace(/^[?#&]/, '');\n\n\tif (!str) {\n\t\treturn ret;\n\t}\n\n\tstr.split('&').forEach(function (param) {\n\t\tvar parts = param.replace(/\\+/g, ' ').split('=');\n\t\t// Firefox (pre 40) decodes `%3D` to `=`\n\t\t// https://github.com/sindresorhus/query-string/pull/37\n\t\tvar key = parts.shift();\n\t\tvar val = parts.length > 0 ? parts.join('=') : undefined;\n\n\t\t// missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tval = val === undefined ? null : decodeComponent(val);\n\n\t\tformatter(decodeComponent(key), val, ret);\n\t});\n\n\treturn Object.keys(ret).sort().reduce(function (result, key) {\n\t\tvar val = ret[key];\n\t\tif (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(val);\n\t\t} else {\n\t\t\tresult[key] = val;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = function (obj, opts) {\n\tvar defaults = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none'\n\t};\n\n\topts = objectAssign(defaults, opts);\n\n\tif (opts.sort === false) {\n\t\topts.sort = function () {};\n\t}\n\n\tvar formatter = encoderForArrayFormat(opts);\n\n\treturn obj ? Object.keys(obj).sort(opts.sort).map(function (key) {\n\t\tvar val = obj[key];\n\n\t\tif (val === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (val === null) {\n\t\t\treturn encode(key, opts);\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tvar result = [];\n\n\t\t\tval.slice().forEach(function (val2) {\n\t\t\t\tif (val2 === undefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tresult.push(formatter(key, val2, result.length));\n\t\t\t});\n\n\t\t\treturn result.join('&');\n\t\t}\n\n\t\treturn encode(key, opts) + '=' + encode(val, opts);\n\t}).filter(function (x) {\n\t\treturn x.length > 0;\n\t}).join('&') : '';\n};\n\nexports.parseUrl = function (str, opts) {\n\treturn {\n\t\turl: str.split('?')[0] || '',\n\t\tquery: parse(extract(str), opts)\n\t};\n};\n","'use strict';\nmodule.exports = function (str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n\t\treturn '%' + c.charCodeAt(0).toString(16).toUpperCase();\n\t});\n};\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","module.exports = urlSetQuery\nfunction urlSetQuery (url, query) {\n  if (query) {\n    // remove optional leading symbols\n    query = query.trim().replace(/^(\\?|#|&)/, '')\n\n    // don't append empty query\n    query = query ? ('?' + query) : query\n\n    var parts = url.split(/[\\?\\#]/)\n    var start = parts[0]\n    if (query && /\\:\\/\\/[^\\/]*$/.test(start)) {\n      // e.g. http://foo.com -> http://foo.com/\n      start = start + '/'\n    }\n    var match = url.match(/(\\#.*)$/)\n    url = start + query\n    if (match) { // add hash back in\n      url = url + match[0]\n    }\n  }\n  return url\n}\n","module.exports = ensureHeader\nfunction ensureHeader (headers, key, value) {\n  var lower = key.toLowerCase()\n  if (!headers[key] && !headers[lower]) {\n    headers[key] = value\n  }\n}\n","var xhr = require('xhr')\nvar normalize = require('./normalize-response')\nvar noop = function () {}\n\nmodule.exports = xhrRequest\nfunction xhrRequest (opt, cb) {\n  delete opt.uri\n\n  // for better JSON.parse error handling than xhr module\n  var useJson = false\n  if (opt.responseType === 'json') {\n    opt.responseType = 'text'\n    useJson = true\n  }\n\n  var req = xhr(opt, function xhrRequestResult (err, resp, body) {\n    if (useJson && !err) {\n      try {\n        var text = resp.rawRequest.responseText\n        body = JSON.parse(text)\n      } catch (e) {\n        err = e\n      }\n    }\n\n    resp = normalize(opt, resp)\n    if (err) cb(err, null, resp)\n    else cb(err, body, resp)\n    cb = noop\n  })\n\n  // Patch abort() so that it also calls the callback, but with an error\n  var onabort = req.onabort\n  req.onabort = function () {\n    var ret = onabort.apply(req, Array.prototype.slice.call(arguments))\n    cb(new Error('XHR Aborted'))\n    cb = noop\n    return ret\n  }\n\n  return req\n}\n","\"use strict\";\nvar window = require(\"global/window\")\nvar isFunction = require(\"is-function\")\nvar parseHeaders = require(\"parse-headers\")\nvar xtend = require(\"xtend\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  if (!fn) {\n    return false\n  }\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n","var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","module.exports = getResponse\nfunction getResponse (opt, resp) {\n  if (!resp) return null\n  return {\n    statusCode: resp.statusCode,\n    headers: resp.headers,\n    method: opt.method,\n    url: opt.url,\n    // the XHR object in browser, http response in Node\n    rawRequest: resp.rawRequest ? resp.rawRequest : resp\n  }\n}\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar debug = require('debug')('simple-peer')\nvar getBrowserRTC = require('get-browser-rtc')\nvar randombytes = require('randombytes')\nvar stream = require('readable-stream')\nvar queueMicrotask = require('queue-microtask') // TODO: remove when Node 10 is not supported\n\nvar MAX_BUFFERED_AMOUNT = 64 * 1024\nvar ICECOMPLETE_TIMEOUT = 5 * 1000\nvar CHANNEL_CLOSING_TIMEOUT = 5 * 1000\n\n// HACK: Filter trickle lines when trickle is disabled #354\nfunction filterTrickle (sdp) {\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\n}\n\nfunction makeError (err, code) {\n  if (typeof err === 'string') err = new Error(err)\n  if (err.error instanceof Error) err = err.error\n  err.code = code\n  return err\n}\n\nfunction warn (message) {\n  console.warn(message)\n}\n\n/**\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\n * Duplex stream.\n * @param {Object} opts\n */\nclass Peer extends stream.Duplex {\n  constructor (opts) {\n    opts = Object.assign({\n      allowHalfOpen: false\n    }, opts)\n\n    super(opts)\n\n    this._id = randombytes(4).toString('hex').slice(0, 7)\n    this._debug('new peer %o', opts)\n\n    this.channelName = opts.initiator\n      ? opts.channelName || randombytes(20).toString('hex')\n      : null\n\n    this.initiator = opts.initiator || false\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\n    this.negotiated = this.channelConfig.negotiated\n    this.config = Object.assign({}, Peer.config, opts.config)\n    this.offerOptions = opts.offerOptions || {}\n    this.answerOptions = opts.answerOptions || {}\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\n    this.streams = opts.streams || (opts.stream ? [opts.stream] : []) // support old \"stream\" option\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\n\n    this.destroyed = false\n    this._connected = false\n\n    this.remoteAddress = undefined\n    this.remoteFamily = undefined\n    this.remotePort = undefined\n    this.localAddress = undefined\n    this.localFamily = undefined\n    this.localPort = undefined\n\n    this._wrtc = (opts.wrtc && typeof opts.wrtc === 'object')\n      ? opts.wrtc\n      : getBrowserRTC()\n\n    if (!this._wrtc) {\n      if (typeof window === 'undefined') {\n        throw makeError('No WebRTC support: Specify `opts.wrtc` option in this environment', 'ERR_WEBRTC_SUPPORT')\n      } else {\n        throw makeError('No WebRTC support: Not a supported browser', 'ERR_WEBRTC_SUPPORT')\n      }\n    }\n\n    this._pcReady = false\n    this._channelReady = false\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\n    this._channel = null\n    this._pendingCandidates = []\n\n    this._isNegotiating = this.negotiated ? false : !this.initiator // is this peer waiting for negotiation to complete?\n    this._batchedNegotiation = false // batch synchronous negotiations\n    this._queuedNegotiation = false // is there a queued negotiation request?\n    this._sendersAwaitingStable = []\n    this._senderMap = new Map()\n    this._firstStable = true\n    this._closingInterval = null\n\n    this._remoteTracks = []\n    this._remoteStreams = []\n\n    this._chunk = null\n    this._cb = null\n    this._interval = null\n\n    try {\n      this._pc = new (this._wrtc.RTCPeerConnection)(this.config)\n    } catch (err) {\n      queueMicrotask(() => this.destroy(makeError(err, 'ERR_PC_CONSTRUCTOR')))\n      return\n    }\n\n    // We prefer feature detection whenever possible, but sometimes that's not\n    // possible for certain implementations.\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\n\n    this._pc.oniceconnectionstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onicegatheringstatechange = () => {\n      this._onIceStateChange()\n    }\n    this._pc.onconnectionstatechange = () => {\n      this._onConnectionStateChange()\n    }\n    this._pc.onsignalingstatechange = () => {\n      this._onSignalingStateChange()\n    }\n    this._pc.onicecandidate = event => {\n      this._onIceCandidate(event)\n    }\n\n    // Other spec events, unused by this implementation:\n    // - onconnectionstatechange\n    // - onicecandidateerror\n    // - onfingerprintfailure\n    // - onnegotiationneeded\n\n    if (this.initiator || this.negotiated) {\n      this._setupData({\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n      })\n    } else {\n      this._pc.ondatachannel = event => {\n        this._setupData(event)\n      }\n    }\n\n    if (this.streams) {\n      this.streams.forEach(stream => {\n        this.addStream(stream)\n      })\n    }\n    this._pc.ontrack = event => {\n      this._onTrack(event)\n    }\n\n    if (this.initiator) {\n      this._needsNegotiation()\n    }\n\n    this._onFinishBound = () => {\n      this._onFinish()\n    }\n    this.once('finish', this._onFinishBound)\n  }\n\n  get bufferSize () {\n    return (this._channel && this._channel.bufferedAmount) || 0\n  }\n\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n  get connected () {\n    return (this._connected && this._channel.readyState === 'open')\n  }\n\n  address () {\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\n  }\n\n  signal (data) {\n    if (this.destroyed) throw makeError('cannot signal after peer is destroyed', 'ERR_SIGNALING')\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data)\n      } catch (err) {\n        data = {}\n      }\n    }\n    this._debug('signal()')\n\n    if (data.renegotiate && this.initiator) {\n      this._debug('got request to renegotiate')\n      this._needsNegotiation()\n    }\n    if (data.transceiverRequest && this.initiator) {\n      this._debug('got request for transceiver')\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\n    }\n    if (data.candidate) {\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\n        this._addIceCandidate(data.candidate)\n      } else {\n        this._pendingCandidates.push(data.candidate)\n      }\n    }\n    if (data.sdp) {\n      this._pc.setRemoteDescription(new (this._wrtc.RTCSessionDescription)(data))\n        .then(() => {\n          if (this.destroyed) return\n\n          this._pendingCandidates.forEach(candidate => {\n            this._addIceCandidate(candidate)\n          })\n          this._pendingCandidates = []\n\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\n        })\n        .catch(err => {\n          this.destroy(makeError(err, 'ERR_SET_REMOTE_DESCRIPTION'))\n        })\n    }\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\n      this.destroy(makeError('signal() called with invalid signal data', 'ERR_SIGNALING'))\n    }\n  }\n\n  _addIceCandidate (candidate) {\n    var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate)\n    this._pc.addIceCandidate(iceCandidateObj)\n      .catch(err => {\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\n          warn('Ignoring unsupported ICE candidate.')\n        } else {\n          this.destroy(makeError(err, 'ERR_ADD_ICE_CANDIDATE'))\n        }\n      })\n  }\n\n  /**\n   * Send text/binary data to the remote peer.\n   * @param {ArrayBufferView|ArrayBuffer|Buffer|string|Blob} chunk\n   */\n  send (chunk) {\n    this._channel.send(chunk)\n  }\n\n  /**\n   * Add a Transceiver to the connection.\n   * @param {String} kind\n   * @param {Object} init\n   */\n  addTransceiver (kind, init) {\n    this._debug('addTransceiver()')\n\n    if (this.initiator) {\n      try {\n        this._pc.addTransceiver(kind, init)\n        this._needsNegotiation()\n      } catch (err) {\n        this.destroy(makeError(err, 'ERR_ADD_TRANSCEIVER'))\n      }\n    } else {\n      this.emit('signal', { // request initiator to renegotiate\n        transceiverRequest: { kind, init }\n      })\n    }\n  }\n\n  /**\n   * Add a MediaStream to the connection.\n   * @param {MediaStream} stream\n   */\n  addStream (stream) {\n    this._debug('addStream()')\n\n    stream.getTracks().forEach(track => {\n      this.addTrack(track, stream)\n    })\n  }\n\n  /**\n   * Add a MediaStreamTrack to the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  addTrack (track, stream) {\n    this._debug('addTrack()')\n\n    var submap = this._senderMap.get(track) || new Map() // nested Maps map [track, stream] to sender\n    var sender = submap.get(stream)\n    if (!sender) {\n      sender = this._pc.addTrack(track, stream)\n      submap.set(stream, sender)\n      this._senderMap.set(track, submap)\n      this._needsNegotiation()\n    } else if (sender.removed) {\n      throw makeError('Track has been removed. You should enable/disable tracks that you want to re-add.', 'ERR_SENDER_REMOVED')\n    } else {\n      throw makeError('Track has already been added to that stream.', 'ERR_SENDER_ALREADY_ADDED')\n    }\n  }\n\n  /**\n   * Replace a MediaStreamTrack by another in the connection.\n   * @param {MediaStreamTrack} oldTrack\n   * @param {MediaStreamTrack} newTrack\n   * @param {MediaStream} stream\n   */\n  replaceTrack (oldTrack, newTrack, stream) {\n    this._debug('replaceTrack()')\n\n    var submap = this._senderMap.get(oldTrack)\n    var sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw makeError('Cannot replace track that was never added.', 'ERR_TRACK_NOT_ADDED')\n    }\n    if (newTrack) this._senderMap.set(newTrack, submap)\n\n    if (sender.replaceTrack != null) {\n      sender.replaceTrack(newTrack)\n    } else {\n      this.destroy(makeError('replaceTrack is not supported in this browser', 'ERR_UNSUPPORTED_REPLACETRACK'))\n    }\n  }\n\n  /**\n   * Remove a MediaStreamTrack from the connection.\n   * @param {MediaStreamTrack} track\n   * @param {MediaStream} stream\n   */\n  removeTrack (track, stream) {\n    this._debug('removeSender()')\n\n    var submap = this._senderMap.get(track)\n    var sender = submap ? submap.get(stream) : null\n    if (!sender) {\n      throw makeError('Cannot remove track that was never added.', 'ERR_TRACK_NOT_ADDED')\n    }\n    try {\n      sender.removed = true\n      this._pc.removeTrack(sender)\n    } catch (err) {\n      if (err.name === 'NS_ERROR_UNEXPECTED') {\n        this._sendersAwaitingStable.push(sender) // HACK: Firefox must wait until (signalingState === stable) https://bugzilla.mozilla.org/show_bug.cgi?id=1133874\n      } else {\n        this.destroy(makeError(err, 'ERR_REMOVE_TRACK'))\n      }\n    }\n    this._needsNegotiation()\n  }\n\n  /**\n   * Remove a MediaStream from the connection.\n   * @param {MediaStream} stream\n   */\n  removeStream (stream) {\n    this._debug('removeSenders()')\n\n    stream.getTracks().forEach(track => {\n      this.removeTrack(track, stream)\n    })\n  }\n\n  _needsNegotiation () {\n    this._debug('_needsNegotiation')\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\n    this._batchedNegotiation = true\n    queueMicrotask(() => {\n      this._batchedNegotiation = false\n      this._debug('starting batched negotiation')\n      this.negotiate()\n    })\n  }\n\n  negotiate () {\n    if (this.initiator) {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('start negotiation')\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\n          this._createOffer()\n        }, 0)\n      }\n    } else {\n      if (this._isNegotiating) {\n        this._queuedNegotiation = true\n        this._debug('already negotiating, queueing')\n      } else {\n        this._debug('requesting negotiation from initiator')\n        this.emit('signal', { // request initiator to renegotiate\n          renegotiate: true\n        })\n      }\n    }\n    this._isNegotiating = true\n  }\n\n  // TODO: Delete this method once readable-stream is updated to contain a default\n  // implementation of destroy() that automatically calls _destroy()\n  // See: https://github.com/nodejs/readable-stream/issues/283\n  destroy (err) {\n    this._destroy(err, () => {})\n  }\n\n  _destroy (err, cb) {\n    if (this.destroyed) return\n\n    this._debug('destroy (error: %s)', err && (err.message || err))\n\n    this.readable = this.writable = false\n\n    if (!this._readableState.ended) this.push(null)\n    if (!this._writableState.finished) this.end()\n\n    this.destroyed = true\n    this._connected = false\n    this._pcReady = false\n    this._channelReady = false\n    this._remoteTracks = null\n    this._remoteStreams = null\n    this._senderMap = null\n\n    clearInterval(this._closingInterval)\n    this._closingInterval = null\n\n    clearInterval(this._interval)\n    this._interval = null\n    this._chunk = null\n    this._cb = null\n\n    if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\n    this._onFinishBound = null\n\n    if (this._channel) {\n      try {\n        this._channel.close()\n      } catch (err) {}\n\n      this._channel.onmessage = null\n      this._channel.onopen = null\n      this._channel.onclose = null\n      this._channel.onerror = null\n    }\n    if (this._pc) {\n      try {\n        this._pc.close()\n      } catch (err) {}\n\n      this._pc.oniceconnectionstatechange = null\n      this._pc.onicegatheringstatechange = null\n      this._pc.onsignalingstatechange = null\n      this._pc.onicecandidate = null\n      this._pc.ontrack = null\n      this._pc.ondatachannel = null\n    }\n    this._pc = null\n    this._channel = null\n\n    if (err) this.emit('error', err)\n    this.emit('close')\n    cb()\n  }\n\n  _setupData (event) {\n    if (!event.channel) {\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\n      // which is invalid behavior. Handle it gracefully.\n      // See: https://github.com/feross/simple-peer/issues/163\n      return this.destroy(makeError('Data channel event is missing `channel` property', 'ERR_DATA_CHANNEL'))\n    }\n\n    this._channel = event.channel\n    this._channel.binaryType = 'arraybuffer'\n\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\n    }\n\n    this.channelName = this._channel.label\n\n    this._channel.onmessage = event => {\n      this._onChannelMessage(event)\n    }\n    this._channel.onbufferedamountlow = () => {\n      this._onChannelBufferedAmountLow()\n    }\n    this._channel.onopen = () => {\n      this._onChannelOpen()\n    }\n    this._channel.onclose = () => {\n      this._onChannelClose()\n    }\n    this._channel.onerror = err => {\n      this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\n    }\n\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\n    var isClosing = false\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\n      if (this._channel && this._channel.readyState === 'closing') {\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\n        isClosing = true\n      } else {\n        isClosing = false\n      }\n    }, CHANNEL_CLOSING_TIMEOUT)\n  }\n\n  _read () {}\n\n  _write (chunk, encoding, cb) {\n    if (this.destroyed) return cb(makeError('cannot write after peer is destroyed', 'ERR_DATA_CHANNEL'))\n\n    if (this._connected) {\n      try {\n        this.send(chunk)\n      } catch (err) {\n        return this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\n      }\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n        this._cb = cb\n      } else {\n        cb(null)\n      }\n    } else {\n      this._debug('write before connect')\n      this._chunk = chunk\n      this._cb = cb\n    }\n  }\n\n  // When stream finishes writing, close socket. Half open connections are not\n  // supported.\n  _onFinish () {\n    if (this.destroyed) return\n\n    // Wait a bit before destroying so the socket flushes.\n    // TODO: is there a more reliable way to accomplish this?\n    const destroySoon = () => {\n      setTimeout(() => this.destroy(), 1000)\n    }\n\n    if (this._connected) {\n      destroySoon()\n    } else {\n      this.once('connect', destroySoon)\n    }\n  }\n\n  _startIceCompleteTimeout () {\n    if (this.destroyed) return\n    if (this._iceCompleteTimer) return\n    this._debug('started iceComplete timeout')\n    this._iceCompleteTimer = setTimeout(() => {\n      if (!this._iceComplete) {\n        this._iceComplete = true\n        this._debug('iceComplete timeout completed')\n        this.emit('iceTimeout')\n        this.emit('_iceComplete')\n      }\n    }, this.iceCompleteTimeout)\n  }\n\n  _createOffer () {\n    if (this.destroyed) return\n\n    this._pc.createOffer(this.offerOptions)\n      .then(offer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\n        offer.sdp = this.sdpTransform(offer.sdp)\n\n        const sendOffer = () => {\n          if (this.destroyed) return\n          var signal = this._pc.localDescription || offer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n        }\n\n        const onSuccess = () => {\n          this._debug('createOffer success')\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendOffer()\n          else this.once('_iceComplete', sendOffer) // wait for candidates\n        }\n\n        const onError = err => {\n          this.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(offer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(makeError(err, 'ERR_CREATE_OFFER'))\n      })\n  }\n\n  _requestMissingTransceivers () {\n    if (this._pc.getTransceivers) {\n      this._pc.getTransceivers().forEach(transceiver => {\n        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {\n          transceiver.requested = true // HACK: Safari returns negotiated transceivers with a null mid\n          this.addTransceiver(transceiver.sender.track.kind)\n        }\n      })\n    }\n  }\n\n  _createAnswer () {\n    if (this.destroyed) return\n\n    this._pc.createAnswer(this.answerOptions)\n      .then(answer => {\n        if (this.destroyed) return\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\n        answer.sdp = this.sdpTransform(answer.sdp)\n\n        const sendAnswer = () => {\n          if (this.destroyed) return\n          var signal = this._pc.localDescription || answer\n          this._debug('signal')\n          this.emit('signal', {\n            type: signal.type,\n            sdp: signal.sdp\n          })\n          if (!this.initiator) this._requestMissingTransceivers()\n        }\n\n        const onSuccess = () => {\n          if (this.destroyed) return\n          if (this.trickle || this._iceComplete) sendAnswer()\n          else this.once('_iceComplete', sendAnswer)\n        }\n\n        const onError = err => {\n          this.destroy(makeError(err, 'ERR_SET_LOCAL_DESCRIPTION'))\n        }\n\n        this._pc.setLocalDescription(answer)\n          .then(onSuccess)\n          .catch(onError)\n      })\n      .catch(err => {\n        this.destroy(makeError(err, 'ERR_CREATE_ANSWER'))\n      })\n  }\n\n  _onConnectionStateChange () {\n    if (this.destroyed) return\n    if (this._pc.connectionState === 'failed') {\n      this.destroy(makeError('Connection failed.', 'ERR_CONNECTION_FAILURE'))\n    }\n  }\n\n  _onIceStateChange () {\n    if (this.destroyed) return\n    var iceConnectionState = this._pc.iceConnectionState\n    var iceGatheringState = this._pc.iceGatheringState\n\n    this._debug(\n      'iceStateChange (connection: %s) (gathering: %s)',\n      iceConnectionState,\n      iceGatheringState\n    )\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\n\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\n      this._pcReady = true\n      this._maybeReady()\n    }\n    if (iceConnectionState === 'failed') {\n      this.destroy(makeError('Ice connection failed.', 'ERR_ICE_CONNECTION_FAILURE'))\n    }\n    if (iceConnectionState === 'closed') {\n      this.destroy(makeError('Ice connection closed.', 'ERR_ICE_CONNECTION_CLOSED'))\n    }\n  }\n\n  getStats (cb) {\n    // statreports can come with a value array instead of properties\n    const flattenValues = report => {\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\n        report.values.forEach(value => {\n          Object.assign(report, value)\n        })\n      }\n      return report\n    }\n\n    // Promise-based getStats() (standard)\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\n      this._pc.getStats()\n        .then(res => {\n          var reports = []\n          res.forEach(report => {\n            reports.push(flattenValues(report))\n          })\n          cb(null, reports)\n        }, err => cb(err))\n\n    // Single-parameter callback-based getStats() (non-standard)\n    } else if (this._pc.getStats.length > 0) {\n      this._pc.getStats(res => {\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\n        if (this.destroyed) return\n\n        var reports = []\n        res.result().forEach(result => {\n          var report = {}\n          result.names().forEach(name => {\n            report[name] = result.stat(name)\n          })\n          report.id = result.id\n          report.type = result.type\n          report.timestamp = result.timestamp\n          reports.push(flattenValues(report))\n        })\n        cb(null, reports)\n      }, err => cb(err))\n\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\n    // getStats() they implement.\n    } else {\n      cb(null, [])\n    }\n  }\n\n  _maybeReady () {\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\n\n    this._connecting = true\n\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\n    const findCandidatePair = () => {\n      if (this.destroyed) return\n\n      this.getStats((err, items) => {\n        if (this.destroyed) return\n\n        // Treat getStats error as non-fatal. It's not essential.\n        if (err) items = []\n\n        var remoteCandidates = {}\n        var localCandidates = {}\n        var candidatePairs = {}\n        var foundSelectedCandidatePair = false\n\n        items.forEach(item => {\n          // TODO: Once all browsers support the hyphenated stats report types, remove\n          // the non-hypenated ones\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\n            remoteCandidates[item.id] = item\n          }\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\n            localCandidates[item.id] = item\n          }\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\n            candidatePairs[item.id] = item\n          }\n        })\n\n        const setSelectedCandidatePair = selectedCandidatePair => {\n          foundSelectedCandidatePair = true\n\n          var local = localCandidates[selectedCandidatePair.localCandidateId]\n\n          if (local && (local.ip || local.address)) {\n            // Spec\n            this.localAddress = local.ip || local.address\n            this.localPort = Number(local.port)\n          } else if (local && local.ipAddress) {\n            // Firefox\n            this.localAddress = local.ipAddress\n            this.localPort = Number(local.portNumber)\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            local = selectedCandidatePair.googLocalAddress.split(':')\n            this.localAddress = local[0]\n            this.localPort = Number(local[1])\n          }\n          if (this.localAddress) {\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\n\n          if (remote && (remote.ip || remote.address)) {\n            // Spec\n            this.remoteAddress = remote.ip || remote.address\n            this.remotePort = Number(remote.port)\n          } else if (remote && remote.ipAddress) {\n            // Firefox\n            this.remoteAddress = remote.ipAddress\n            this.remotePort = Number(remote.portNumber)\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\n            // TODO: remove this once Chrome 58 is released\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\n            this.remoteAddress = remote[0]\n            this.remotePort = Number(remote[1])\n          }\n          if (this.remoteAddress) {\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\n          }\n\n          this._debug(\n            'connect local: %s:%s remote: %s:%s',\n            this.localAddress, this.localPort, this.remoteAddress, this.remotePort\n          )\n        }\n\n        items.forEach(item => {\n          // Spec-compliant\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\n          }\n\n          // Old implementations\n          if (\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\n          ) {\n            setSelectedCandidatePair(item)\n          }\n        })\n\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\n        // But wait until at least 1 candidate pair is available\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\n          setTimeout(findCandidatePair, 100)\n          return\n        } else {\n          this._connecting = false\n          this._connected = true\n        }\n\n        if (this._chunk) {\n          try {\n            this.send(this._chunk)\n          } catch (err) {\n            return this.destroy(makeError(err, 'ERR_DATA_CHANNEL'))\n          }\n          this._chunk = null\n          this._debug('sent chunk from \"write before connect\"')\n\n          var cb = this._cb\n          this._cb = null\n          cb(null)\n        }\n\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\n        // fallback to using setInterval to implement backpressure.\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\n          this._interval = setInterval(() => this._onInterval(), 150)\n          if (this._interval.unref) this._interval.unref()\n        }\n\n        this._debug('connect')\n        this.emit('connect')\n      })\n    }\n    findCandidatePair()\n  }\n\n  _onInterval () {\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\n      return\n    }\n    this._onChannelBufferedAmountLow()\n  }\n\n  _onSignalingStateChange () {\n    if (this.destroyed) return\n\n    if (this._pc.signalingState === 'stable' && !this._firstStable) {\n      this._isNegotiating = false\n\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\n      this._sendersAwaitingStable.forEach(sender => {\n        this._pc.removeTrack(sender)\n        this._queuedNegotiation = true\n      })\n      this._sendersAwaitingStable = []\n\n      if (this._queuedNegotiation) {\n        this._debug('flushing negotiation queue')\n        this._queuedNegotiation = false\n        this._needsNegotiation() // negotiate again\n      }\n\n      this._debug('negotiate')\n      this.emit('negotiate')\n    }\n    this._firstStable = false\n\n    this._debug('signalingStateChange %s', this._pc.signalingState)\n    this.emit('signalingStateChange', this._pc.signalingState)\n  }\n\n  _onIceCandidate (event) {\n    if (this.destroyed) return\n    if (event.candidate && this.trickle) {\n      this.emit('signal', {\n        candidate: {\n          candidate: event.candidate.candidate,\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\n          sdpMid: event.candidate.sdpMid\n        }\n      })\n    } else if (!event.candidate && !this._iceComplete) {\n      this._iceComplete = true\n      this.emit('_iceComplete')\n    }\n    // as soon as we've received one valid candidate start timeout\n    if (event.candidate) {\n      this._startIceCompleteTimeout()\n    }\n  }\n\n  _onChannelMessage (event) {\n    if (this.destroyed) return\n    var data = event.data\n    if (data instanceof ArrayBuffer) data = Buffer.from(data)\n    this.push(data)\n  }\n\n  _onChannelBufferedAmountLow () {\n    if (this.destroyed || !this._cb) return\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\n    var cb = this._cb\n    this._cb = null\n    cb(null)\n  }\n\n  _onChannelOpen () {\n    if (this._connected || this.destroyed) return\n    this._debug('on channel open')\n    this._channelReady = true\n    this._maybeReady()\n  }\n\n  _onChannelClose () {\n    if (this.destroyed) return\n    this._debug('on channel close')\n    this.destroy()\n  }\n\n  _onTrack (event) {\n    if (this.destroyed) return\n\n    event.streams.forEach(eventStream => {\n      this._debug('on track')\n      this.emit('track', event.track, eventStream)\n\n      this._remoteTracks.push({\n        track: event.track,\n        stream: eventStream\n      })\n\n      if (this._remoteStreams.some(remoteStream => {\n        return remoteStream.id === eventStream.id\n      })) return // Only fire one 'stream' event, even though there may be multiple tracks per stream\n\n      this._remoteStreams.push(eventStream)\n      queueMicrotask(() => {\n        this.emit('stream', eventStream) // ensure all tracks have been added\n      })\n    })\n  }\n\n  _debug () {\n    var args = [].slice.call(arguments)\n    args[0] = '[' + this._id + '] ' + args[0]\n    debug.apply(null, args)\n  }\n}\n\nPeer.WEBRTC_SUPPORT = !!getBrowserRTC()\n\n/**\n * Expose peer and data channel config for overriding all Peer\n * instances. Otherwise, just set opts.config or opts.channelConfig\n * when constructing a Peer.\n */\nPeer.config = {\n  iceServers: [\n    {\n      urls: 'stun:stun.l.google.com:19302'\n    },\n    {\n      urls: 'stun:global.stun.twilio.com:3478?transport=udp'\n    }\n  ],\n  sdpSemantics: 'unified-plan'\n}\n\nPeer.channelConfig = {}\n\nmodule.exports = Peer\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","// originally pulled out of simple-peer\n\nmodule.exports = function getBrowserRTC () {\n  if (typeof window === 'undefined') return null\n  var wrtc = {\n    RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection ||\n      window.webkitRTCPeerConnection,\n    RTCSessionDescription: window.RTCSessionDescription ||\n      window.mozRTCSessionDescription || window.webkitRTCSessionDescription,\n    RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate ||\n      window.webkitRTCIceCandidate\n  }\n  if (!wrtc.RTCPeerConnection) return null\n  return wrtc\n}\n","'use strict'\n\n// limit of Crypto.getRandomValues()\n// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\nvar MAX_BYTES = 65536\n\n// Node supports requesting up to this number of bytes\n// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48\nvar MAX_UINT32 = 4294967295\n\nfunction oldBrowser () {\n  throw new Error('Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11')\n}\n\nvar Buffer = require('safe-buffer').Buffer\nvar crypto = global.crypto || global.msCrypto\n\nif (crypto && crypto.getRandomValues) {\n  module.exports = randomBytes\n} else {\n  module.exports = oldBrowser\n}\n\nfunction randomBytes (size, cb) {\n  // phantomjs needs to throw\n  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')\n\n  var bytes = Buffer.allocUnsafe(size)\n\n  if (size > 0) {  // getRandomValues fails on IE if size == 0\n    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues\n      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues\n      for (var generated = 0; generated < size; generated += MAX_BYTES) {\n        // buffer.slice automatically checks if the end is past the end of\n        // the buffer so we don't have to here\n        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))\n      }\n    } else {\n      crypto.getRandomValues(bytes)\n    }\n  }\n\n  if (typeof cb === 'function') {\n    return process.nextTick(function () {\n      cb(null, bytes)\n    })\n  }\n\n  return bytes\n}\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","/* (ignored) */","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","/* (ignored) */","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","let promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","var sig = require(\"nano-ethereum-signer\");\nvar fm = require(\"formality-lang\");\n\n// Validation\n// ==========\n\nfunction hex(bits, hex) {\n  if (typeof hex !== \"string\" || !/^0x[a-fA-F0-9]*$/.test(hex)) {\n    return null;\n  };\n  while ((hex.length - 2) * 4 < bits) {\n    hex = \"0x0\" + hex.slice(2);\n  };\n  if ((hex.length - 2) * 4 > bits) {\n    hex = hex.slice(0, Math.floor(bits / 4) + 2);\n  }\n  return hex;\n};\n\nfunction nam(name) {\n  if (typeof name !== \"string\" || !/^[a-zA-Z0-9.]*$/.test(name)) {\n    return null;\n  } else {\n    return name;\n  }\n};\n\nfunction num(val) {\n  try {\n    var num = parseInt(val, 10);\n    if (isNaN(num)) {\n      return null;\n    } else {\n      return num;\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nconst hex_char = \"0123456789abcdef\".split(\"\");\n\nfunction hex_to_uint48(hex) {\n  return parseInt(hex.slice(-48), 16);\n};\n\nfunction uint48_to_hex(num) {\n  var hex = \"0x\";\n  for (var i = 0; i < 12; ++i) {\n    hex += hex_char[(num / (2**((12-i-1)*4))) & 0xF];\n  };\n  return hex;\n};\n\nfunction uint32_to_bytes(num) {\n  return new Uint8Array(new Uint32Array([num]).buffer);\n};\n\nfunction bytes_to_uint32(buf) {\n  return (new Uint32Array(buf.buffer))[0];\n};\n\nfunction bytes_to_hex(buf) {\n  var hex = \"0x\";\n  for (var i = 0; i < buf.length; ++i) {\n    hex += hex_char[buf[i]>>>4] + hex_char[buf[i]&0xF];\n  };\n  return hex;\n};\n\nfunction hex_to_bytes(hex) {\n  var arr = [];\n  for (var i = 0; i < (hex.length-2)/2; ++i) {\n    arr.push((parseInt(hex[2+i*2+0],16)<<4)|parseInt(hex[2+i*2+1],16));\n  };\n  return new Uint8Array(arr);\n};\n\nvar utf8_encoder = new TextEncoder(\"utf-8\");\nfunction string_to_bytes(str) {\n  return utf8_encoder.encode(str);\n};\n\nvar utf8_decoder = new TextDecoder(\"utf-8\");\nfunction bytes_to_string(buf) {\n  return utf8_decoder.decode(buf);\n};\n\nfunction string_to_hex(str) {\n  return bytes_to_hex(string_to_bytes(str));\n};\n\nfunction hex_to_string(hex) {\n  return bytes_to_string(hex_to_bytes(hex));\n};\n\nfunction get_hex_from_bytes(idx, lim, buf) {\n  var bytes = \"0x\";\n  for (var i = idx/8; i < lim/8; ++i) { \n    bytes += hex_char[buf[i]>>>4] + hex_char[buf[i]&0xF];\n  };\n  return bytes;\n};\n\nfunction bytes_to_post(buf) {\n  return {\n    date: hex_to_uint48(get_hex_from_bytes(0, 64, buf)),\n    cite: get_hex_from_bytes(64, 128, buf),\n    sign: get_hex_from_bytes(128, 648, buf),\n    head: hex_to_string(get_hex_from_bytes(648, 1024, buf)).replace(/\\0/g,\"\"),\n    body: hex_to_string(get_hex_from_bytes(1024, buf.length*8, buf)),\n  };\n};\n\nfunction put_hex_on_array(hex, arr) {\n  for (var i = 0; i < (hex.length-2)/2; ++i) {\n    var b0 = parseInt(hex[2+i*2+0],16);\n    var b1 = parseInt(hex[2+i*2+1],16);\n    arr.push((b0<<4)|b1);\n  };\n};\n\nfunction post_to_bytes(post) {\n  var arr = [];\n  put_hex_on_array(hex(64, uint48_to_hex(post.date)), arr);\n  put_hex_on_array(post.cite, arr);\n  put_hex_on_array(post.sign, arr);\n  put_hex_on_array(hex(376, string_to_hex(post.head)), arr);\n  put_hex_on_array(string_to_hex(post.body), arr);\n  return new Uint8Array(arr);\n};\n\nfunction hex_to_post(hex) {\n  return bytes_to_post(hex_to_bytes(hex));\n};\n\nfunction post_to_hex(post) {\n  return bytes_to_hex(post_to_bytes(post));\n};\n\nfunction get_post_blocks(post, author) {\n  var blocks = [{ctor:\"text\", text:\"\"}];\n  var inside_code = false;\n  for (var i = 0; i < post.body.length; ++i) {\n    if (!inside_code                            \n      && author\n      && (i === 0 || post.body[i-1] === \"\\n\")\n      && ( post.body.slice(i, i+author.length+1) === author+\".\"\n        || post.body[i] === \"T\" && post.body.slice(i+2, i+2+author.length) === author)) {\n      inside_code = true;\n      blocks.push({ctor:\"code\", code:\"\"});\n    } else if (inside_code\n      && post.body[i] === \"\\n\"\n      && post.body[i+1] === \"\\n\") {\n      inside_code = false;\n      blocks.push({ctor:\"text\", text:\"\"});\n    }\n    if (inside_code) {\n      blocks[blocks.length - 1].code += post.body[i];\n    } else {\n      blocks[blocks.length - 1].text += post.body[i];\n    };\n  };\n  return blocks;\n};\n\n// Returns the code portions of a post\nfunction get_post_code(post, author) {\n  var blocks = get_post_blocks(post, author);\n  var code = \"\";\n  for (var block of blocks) {\n    if (block.ctor === \"code\") {\n      code += code.length > 0 ? \"\\n\\n\" : \"\";\n      code += block.code;\n    }\n  };\n  return code;\n};\n\nfunction get_post_msge(post) {\n  return post.cite + \"\\n\" + post.head + \"\\n\" + post.body;\n};\n\nfunction get_post_auth(post) {\n  if (!post.auth) {\n    post.auth = sig.signerAddress(sig.keccak(get_post_msge(post)), post.sign)\n  };\n  return post.auth;\n};\n\nfunction sign_post(post, pkey) {\n  return {\n    ...post,\n    sign: post.sign || sig.signMessage(sig.keccak(get_post_msge(post)), pkey),\n  };\n};\n\nfunction get_term_refs(term, refs = {}) {\n  function go(term) {\n    switch (term.ctor) {\n      case \"Var\": break;\n      case \"Ref\": refs[term.name] = 1; break;\n      case \"Typ\": break;\n      case \"All\": go(term.bind); go(term.body(fm.synt.Var(\"\"),fm.synt.Var(\"\"))); break;\n      case \"Lam\": go(term.body(fm.synt.Var(\"\"))); break;\n      case \"App\": go(term.func); go(term.argm); break;\n      case \"Let\": go(term.expr); go(term.body(fm.synt.Var(\"\"))); break;\n      case \"Ann\": go(term.expr); go(term.type); break;\n      case \"Loc\": go(term.expr); break;\n      case \"Hol\": break;\n    };\n  };\n  go(term);\n  return refs;\n};\n\nfunction split_hex_in_chunks(len, hex) {\n  var chunks = [];\n  for (var i = 2; i < hex.length; i += len / 4) {\n    chunks.push(\"0x\" + hex.slice(i, i + len / 4)); \n  };\n  return chunks;\n};\n\nfunction hex_to_hex64s(hex) {\n  return split_hex_in_chunks(64, hex);\n};\n\nfunction bytes_concat(bytes) {\n  var size = 0;\n  for (var arr of bytes) {\n    size += arr.length;\n  }\n  var done = new Uint8Array(size);\n  var indx = 0;\n  for (var arr of bytes) {\n    for (var x of arr) {\n      done[indx++] = x\n    };\n  }\n  return done;\n};\n\n// Net message codes\nconst DO_POST = 66;\nconst DO_WATCH = 67;\nconst POST = 97;\nconst CITE = 98;\nconst NAME = 99;\nconst ROOM = 100;\n\nmodule.exports = {\n  hex,\n  nam,\n  num,\n  hex_to_uint48,\n  uint48_to_hex,\n  uint32_to_bytes,\n  bytes_to_uint32,\n  bytes_to_hex,\n  hex_to_bytes,\n  string_to_bytes,\n  bytes_to_string,\n  string_to_hex,\n  hex_to_string,\n  bytes_to_post,\n  post_to_bytes,\n  hex_to_post,\n  post_to_hex,\n  get_term_refs,\n  get_post_code,\n  get_post_blocks,\n  get_post_msge,\n  get_post_auth,\n  split_hex_in_chunks,\n  hex_to_hex64s,\n  bytes_concat,\n  sign_post,\n  DO_POST,\n  DO_WATCH,\n  POST,\n  CITE,\n  NAME,\n  ROOM,\n};\n","// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n","const {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nconst TopBar = require(\"./TopBar.js\");\nconst Write = require(\"./Write.js\");\nconst Posts = require(\"./Posts.js\");\nconst Term = require(\"./Term.js\");\n\nclass Moonad extends Component {\n  constructor(props) {\n    super(props);\n  }\n  componentDidMount() {\n    setInterval(() => this.forceUpdate(), 250);\n  }\n  render() {\n    var route = front.get_route();\n\n    var head = h(TopBar, {\n      name: front.name,\n      route: route,\n      posts: this.posts,\n      on_click_link: (name) => {\n        if (name === \"posts\") {\n          front.set_route(\"/p\");\n        } else if (name === \"user\") {\n          var msge = \"Logged with Ethereum.\\n\"\n            + \"- Address: \"+front.addr+\"\\n\"\n            + \"- PrivKey: \"+front.pkey+\"\\n\"\n            + \"Copy on the console.\";\n          alert(msge);\n          console.log(msge);\n        }\n      },\n    });\n\n    let paths = front.get_paths();\n    switch (paths[0]) {\n      case \"w\":\n        var body = h(Write, {moonad: this.moonad});\n        break;\n      case \"p\":\n        var body = h(Posts, {\n          moonad: front.moonad,\n          poid: paths[1] || \"0x0000000000000000\",\n        });\n        break;\n      case \"t\":\n        var body = h(Term, {\n          name: paths[1]\n        });\n    }\n\n    return h(\"div\", {\n      style: {\n        \"font-family\": \"IBMPlexMono-Light\",\n        \"font-size\": \"12px\",\n        \"background\": \"white\",\n        \"width\": \"100%\",\n        \"height\": \"100%\",\n      }}, [\n        head,\n        body,\n      ]);\n  }\n};\n\nmodule.exports = Moonad;\n","const {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\nconst User_info = require(\"./User_info.js\");\n\nclass TopBar extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    const head_lft = h(\"div\", {\n      onClick: () => this.props.on_click_link(\"posts\"),\n      style: {\n        \"cursor\": \"pointer\",\n      },\n    }, [\"Moonad\"]);\n    const head_rgt = h(\"div\", {}, [\n      //h(\"span\", {\n        //style: {\n          //\"cursor\": \"pointer\",\n          //\"text-decoration\": \"underline\",\n          //\"color\": \"rgb(101,102,105)\",\n        //},\n        //onClick: () => this.props.on_click_link(\"check\"),\n      //}, \"check\"),\n      //h(\"span\", {}, \" \"),\n      //h(\"span\", {\n        //style: {\n          //\"cursor\": \"pointer\",\n          //\"text-decoration\": \"underline\",\n          //\"color\": \"rgb(101,102,105)\",\n        //},\n        //onClick: () => this.props.on_click_link(\"write\"),\n      //}, \"write\"),\n      //h(\"span\", {}, \" \"),\n      h(\"span\", {\n        style: {\n          \"cursor\": \"pointer\",\n          \"text-decoration\": \"underline\",\n          \"color\": \"rgb(101,102,105)\",\n        },\n        onClick: () => this.props.on_click_link(\"user\"),\n      }, front.name),\n    ]);\n\n    const head = h(\"div\", {\n      style: {\n        \"background\": \"white\",\n        \"padding\": \"1px 6px\",\n        \"border-bottom\": \"2px solid rgb(240, 240, 240)\",\n        \"height\": \"26px\",\n        \"font-size\": \"16px\",\n        \"display\": \"flex\",\n        \"flex-flow\": \"row nowrap\",\n        \"justify-content\": \"space-between\",\n      },\n    }, [head_lft, head_rgt, h(User_info, {})]);\n\n    return head;\n  }\n};\n\nmodule.exports = TopBar;\n","const {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nclass User_info extends Component {\n  \n  constructor(props) {\n    super(props);\n  }\n  \n  render() {\n    var eth_address = front.get_addr();\n    eth_address = eth_address ? eth_address : \"-\";\n\n    var eth_pkey = front.get_pkey();\n    eth_pkey = eth_pkey ? eth_pkey : \"-\";\n\n    const eth_address_div =\n      h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Medium\",\n          \"font-size\": \"12px\",\n          \"padding-left\": \"10px\",\n        }},\n        \"Ethereum Address\"\n      )\n  \n    const eth_address_info =\n      h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"font-size\": \"12px\",\n          \"padding-left\": \"10px\",\n        }},\n        eth_address\n      )\n\n    const address_section = \n      h(\"div\", {\n        style: {\n          \"margin-top\": \"15px\"\n        }},\n        [ eth_address_div, eth_address_info]\n      )\n      \n    const eth_pkey_div =\n      h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Medium\",\n          \"font-size\": \"12px\",\n          \"padding-left\": \"10px\",\n        }},\n        \"Private key\"\n      )\n  \n    const eth_pkey_info =\n      h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"max-width\": \"100%\",\n          \"font-size\": \"12px\",\n          \"padding-left\": \"10px\",\n        }},\n        h(\"span\", eth_pkey)\n      )\n\n    const pkey_section = \n      h(\"div\", {\n        style: {\n          \"margin-top\": \"15px\"\n        }},\n        [ eth_pkey_div, eth_pkey_info]\n      )\n    // TODO: copy button\n\n    return h(\"div\", {\n      style: {\n        \"descr\": \"user-info-container\",\n        \"width\": \"200px\",\n        \"height\": \"100px\",\n        \"margin-top\": \"15px\",\n        \"margin-right\": \"20px\",\n        \"background\": \"green\",\n        \"z-index\": \"3\"\n      }}, [\n        address_section,\n        pkey_section\n      ]);\n  }\n\n};\n\nmodule.exports = User_info;","// The page where you write a new post\n\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nclass Write extends Component {\n  constructor(props) {\n    super(props);\n    this.cite = new URLSearchParams(window.location.search).get(\"cite\") || \"0x0000000000000000\";\n    this.head = \"Title...\";\n    this.body = \"Contents...\";\n    this.cleared = {};\n  }\n\n  async post({cite, head, body}) {\n    // Checks if citation is correct\n    if (!front.moonad.lib.hex(64, cite)) {\n      return alert(\"Incorrect cited post.\");\n    }\n\n    try {\n      await front.moonad.api.post({cite, head, body}, front.pkey);\n      window.history.back();\n    } catch (e) {\n      console.log(e);\n      alert(front.remove_colors(e));\n    }\n  }\n\n  click(key, elem) {\n    if (!this.cleared[key]) {\n      this.cleared[key] = true;\n      elem.innerText = \"\";\n      this.forceUpdate();\n    }\n  }\n\n  refresh(key, elem) {\n    this[key] = elem.innerText;\n    this.forceUpdate();\n  }\n\n  render() {\n\n    const head = h(\"pre\", {\n      contentEditable: true,\n      style: {\n        \"font-family\": \"IBMPlexMono-Light\",\n        \"font-size\": \"12px\",\n        \"color\": \"rgb(101,102,105)\",\n        \"outline\": \"none\",\n        \"width\": \"100%\",\n        \"height\": \"20px\",\n        \"padding\": \"2px 4px\",\n        \"border-bottom\": \"1px solid rgb(240,240,240)\",\n        \"background\": \"white\",\n      },\n      onClick: (e) => this.click(\"head\", e.target),\n      onInput: (e) => this.refresh(\"head\", e.target),\n    }, [this.head]);\n\n    const body = h(\"pre\", {\n      contentEditable: true,\n      style: {\n        \"font-family\": \"IBMPlexMono-Light\",\n        \"font-size\": \"12px\",\n        \"color\": \"rgb(101,102,105)\",\n        \"outline\": \"none\",\n        \"width\": \"100%\",\n        \"height\": \"360px\",\n        \"padding\": \"2px 4px\",\n        \"overflow-y\": \"scroll\",\n        \"border-bottom\": \"1px solid rgb(240,240,240)\",\n        \"background\": \"white\",\n      },\n      onClick: (e) => this.click(\"body\", e.target),\n      onInput: (e) => this.refresh(\"body\", e.target),\n    }, [this.body]);\n\n    const send = h(\"pre\", {\n      style: {\n        \"font-family\": \"IBMPlexMono-Light\",\n        \"font-size\": \"12px\",\n        \"color\": \"rgb(101,102,105)\",\n        \"outline\": \"none\",\n        \"width\": \"100%\",\n        \"height\": \"20px\",\n        \"padding\": \"2px 4px\",\n        \"background\": \"rgb(241,242,246)\",\n        \"border-bottom\": \"1px solid rgb(240,240,240)\",\n        \"text-decoration\": \"underline\",\n        \"cursor\": \"pointer\",\n      },\n      onClick: () => {\n        var cite = this.cite;\n        var head = this.head.replace(/\\n/g,\"\");\n        var body = this.body.replace(/\\n{3,}/g, \"\\n\\n\");\n        this.post({cite, head, body});\n      },\n    }, [\"Submit reply to \" + this.cite + \".\"]);\n\n    const repl = h(\"pre\", { \n      style: {\n        \"height\": \"calc(100% - 20px - 20px - 360px)\",\n        \"color\": \"rgb(101,102,105)\",\n        \"background\": \"rgb(221,222,224)\",\n        \"border-top\": \"1px solid rgb(201,202,204)\",\n        \"padding\": \"4px 4px\",\n      },\n    }, [\"*type-checker console and REPL here*\"]);\n\n    return h(\"div\", {\n      style: {\n        \"height\": \"calc(100% - 20px)\",\n      },\n    }, [\n      head,\n      body,\n      send,\n      repl,\n    ]);\n  }\n};\n\nmodule.exports = Write;\n\n","// A page of posts, including one on top and the replies below\n\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nconst Post = require(\"./Post.js\");\n\nclass Posts extends Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    var poid = this.props.poid;\n    var post = front.moonad.post[poid];\n    var body = [];\n\n    // Main post\n    body.push(Post({\n      top: true,\n      poid,\n      expand: true,\n      moonad: front.moonad,\n      on_click_post: this.props.on_click_post\n    }));\n\n    // Reply separator\n    body.push(h(\"div\", {\n      style: {\n        \"margin-top\": \"8px\",\n        \"margin-bottom\": \"8px\",\n        \"border-bottom\": \"1px solid rgb(240, 240, 240)\",\n        \"font-size\": \"16px\",\n        \"display\": \"flex\",\n        \"flex-flow\": \"row nowrap\",\n        \"justify-content\": \"space-between\",\n        \"align-items\": \"flex-end\",\n      },\n    }, [\n      h(\"span\", {\n        style: {\"font-size\": \"16px\"},\n      }, \"Replies:\"),\n      h(\"span\", {\n        style: {\n          \"font-size\": \"12px\",\n          \"text-decoration\": \"underline\",\n          \"cursor\": \"pointer\",\n          \"padding-bottom\": \"1px\",\n        },\n        onClick: () => front.set_route(\"/w?cite=\"+poid),\n      }, \"write reply\"),\n    ]));\n\n    // Post replies\n    if (front.moonad.cite[poid]) {\n      for (let i = front.moonad.cite[poid].length - 1; i >= 0; --i) {\n        body.push(Post({\n          poid: front.moonad.cite[poid][i],\n          expand: poid !== \"0x0000000000000000\",\n          moonad: front.moonad,\n        }));\n      };\n    };\n\n    return h(\"div\", {\n      style: {\n        \"min-height\": \"calc(100% - 30px)\",\n        \"display\": \"flex\",\n        \"flex-flow\": \"row nowrap\",\n        \"justify-content\": \"center\",\n      },\n    }, h(\"div\", {\n      style: {\n        \"background\": \"white\",\n        \"padding\": \"2px 6px\",\n        \"width\": \"586px\",\n      }\n    }, body));\n  }\n};\n\nmodule.exports = Posts;\n","// A single post, expanded or not\n\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nconst Code = require(\"./Code.js\");\n\nconst Post = ({poid, expand, top}) => {\n  const post = front.moonad.post[poid];\n  if (poid === \"0x0000000000000000\") {\n    return h(\"div\", {}, \"Welcome to Moonad.\");\n  } else if (poid === null || !post) {\n    return h(\"div\", {}, \"[loading...]\");\n  } else {\n    const title_back = h(\"span\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"user-select\": \"none\",\n          \"font-size\": expand ? \"16px\" : \"14px\",\n          \"text-decoration\": \"underline\",\n          \"color\": \"rgb(41, 42, 44)\",\n          \"cursor\": \"pointer\",\n        },\n        onClick: () => front.set_route(\"/p/\"+post.cite),\n      }, \"\");\n    const title_head = h(\"span\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"user-select\": \"none\",\n          \"font-size\": expand ? \"16px\" : \"14px\",\n          \"text-decoration\": \"underline\",\n          \"color\": \"rgb(41, 42, 44)\",\n          \"cursor\": \"pointer\",\n        },\n        onClick: () => front.set_route(\"/p/\"+poid),\n      }, post.head);\n    const title = h(\"div\", {}, top ? [title_back,\" \",title_head] : title_head);\n\n    var auth_addr = front.moonad.lib.get_post_auth(post).toLowerCase();\n    var auth_name = front.moonad.name[auth_addr];\n    var blocks = front.moonad.lib.get_post_blocks(post, front.moonad.name[auth_addr]);\n    var post_body = [];\n    for (var block of blocks) {\n      switch (block.ctor) {\n        case \"code\":\n          post_body.push(Code({code: block.code}));\n          break;\n        case \"text\":\n          post_body.push(block.text.replace(/^\\n/,\"\"));\n          break;\n      }\n    };\n\n    const body = !expand ? null : h(\"pre\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"font-size\": \"12px\",\n          \"padding\": \"2px 0px\",\n          \"color\": \"rgb(101,102,105)\",\n        }\n      }, post_body);\n\n    const author = h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"font-size\": \"8px\",\n          //\"font-style\": \"italic\",\n          \"color\": \"rgb(161, 162, 168)\",\n          \"padding-bottom\": \"8px\",\n        },\n      }, \"\"\n        + ((front.moonad.cite[poid] ? front.moonad.cite[poid].length : 0) + \" replies\")\n        + \" | at \" + front.format_date(post.date)\n        + \" | by \" + (front.moonad.name[post.auth.toLowerCase()] || post.auth || \"someone\")\n        );\n\n    return h(\"div\", {\n      style: {\n        //\"border-bottom\": \"1px solid rgb(240, 240, 240)\",\n        //\"padding-bottom\": \"16px\",\n      }}, [title, body, author]);\n  }\n};\n\nmodule.exports = Post;\n","// Code highlighting and hyperlinking\n\nconst fm = require(\"formality-lang\");\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst front = require(\"./../front.js\");\n\nconst Code = ({code}) => {\n  var tags = fm.lang.parse(code).tags;\n  var elems = [];\n  var def_col = \"rgb(20,120,32)\";\n  var txt_col = \"rgb(102,172,182)\";\n  var nam_col = \"rgb(160,162,166)\";\n  var nul_col = \"rgb(112,146,188)\";\n  var str_col = \"rgb(204,69,49)\";\n  var ref_col = \"rgb(157, 147, 171)\";\n  var typ_col = \"rgb(172,111,52)\";\n  for (let tag of tags) {\n    let color = null;\n    let click = null;\n    let decor = null;\n    let cursr = null;\n    switch (tag.ctor) {\n      case \"def\":\n        color = def_col;\n        click = () => front.set_route(\"/t/\"+tag.text);\n        decor = \"underline\";\n        cursr = \"pointer\";\n        break;\n      case \"nam\":\n        color = nam_col;\n        break;\n      case \"var\":\n        color = nam_col;\n        break;\n      case \"txt\":\n        if (tag.text === \"Type\") {\n          color = typ_col;\n        } else {\n          color = txt_col;\n        }\n        break;\n      case \"nul\": // ok \n        color = nul_col;\n        break;\n      case \"str\":\n        color = str_col;\n        break;\n      case \"ref\":\n        color = ref_col;\n        click = () => {console.log(\"TODO\")};\n        decor = \"underline\";\n        cursr = \"pointer\";\n        break;\n    }\n    elems.push(h(\"span\", {\n      onClick: click,\n      style: {\n        \"color\": color,\n        \"text-decoration\": decor,\n        \"cursor\": cursr,\n      }\n    }, tag.text));\n  };\n  return h(\"div\", {\n    style: {\n      \"background\": \"rgb(247,248,250)\",\n      \"padding\": \"4px\",\n    }\n  }, elems);\n};\n\nmodule.exports = Code;\n","// A page of posts, including one on top and the replies below\n\nconst {Component, render} = require(\"inferno\");\nconst h = require(\"inferno-hyperscript\").h;\nconst fm = require(\"formality-lang\");\nconst front = require(\"./../front.js\");\n\nclass Term extends Component {\n  constructor(props) {\n    super(props);\n    this.poid = null;\n    this.defs = null;\n    this.argm = [];\n    this.memo = {};\n  }\n  async componentDidMount() {\n    this.poid = await front.moonad.api.get_orig({name: this.props.name});\n    this.defs = await front.load_defs_of(this.props.name);\n  }\n  render() {\n    const name = this.props.name;\n    const defs = this.defs;\n\n    var head = h(\"div\", {\n      style: {\n        \"font-family\": \"IBMPlexMono-Light\",\n        \"user-select\": \"none\",\n        \"font-size\": \"16px\",\n        \"color\": \"rgb(41, 42, 44)\",\n        \"text-decoration\": \"underline\",\n        \"cursor\": \"pointer\",\n      },\n      onClick: () => {\n        if (this.poid) {\n          front.set_route(\"/p/\"+this.poid);\n        };\n      },\n    }, this.props.name);\n\n    var body = null;\n    if (defs && defs[name]) {\n\n      // Arguments\n      var type = fm.synt.reduce(this.defs[name].type);\n      var argm_divs = [];\n      var argm_type = [];\n      var argm_eras = [];\n      while (type.ctor === \"All\") {\n        let argm_i = argm_divs.length;\n        argm_eras.push(type.eras);\n        argm_type.push(type.bind);\n        argm_divs.push(h(\"div\", {}, [\n          h(\"div\", {}, [\n            h(\"span\", {}, [type.name+\" : \"+fm.lang.stringify(type.bind)+\" = \"]),\n            h(\"input\", {onInput: (e) => this.argm[argm_i] = e.target.value}),\n          ]),\n        ]));\n        var var0 = fm.synt.Var(type.self);\n        var var1 = fm.synt.Var(type.name);\n        type = fm.synt.reduce(type.body(var0, var1));\n      };\n\n      // Parses input arguments\n      var argm_term = [];\n      for (let i = 0; i < this.argm.length; ++i) {\n        if (this.argm[i]) {\n          try {\n            var parsed = fm.lang.parse_trm(this.argm[i], [0,[]], true);\n            var term = parsed[1](fm.synt.Nil());\n            argm_term.push(term);\n          } catch (e) {\n            console.log(e);\n            break;\n          }\n        }\n      }\n\n      // Prints result\n      if (argm_term.length === argm_type.length) {\n        var term = fm.synt.Ref(name);\n        for (let i = 0; i < argm_term.length; ++i) {\n          term = fm.synt.App(argm_eras[i], term, argm_term[i]);\n        };\n        defs[\"_main_\"] = {term, type: fm.synt.Hol(\"_main_\", fm.synt.Nil())};\n        try {\n          // Synthetizes\n          fm.synt.typesynth(\"_main_\", defs, fm.lang.stringify);\n          // Shows JS evaluation\n          var core_defs = {};\n          for (var def in defs) {\n            core_defs[def] = defs[def].core;\n          };\n          var js_code = fm.tojs.compile(\"_main_\", core_defs, true);\n          var js_eval = eval(js_code);\n          argm_divs.push(h(\"pre\", {}, \"\\nEval:\\n\" + js_eval._main_));\n          argm_divs.push(h(\"pre\", {}, \"\\nNorm:\"));\n          argm_divs.push(h(\"pre\", {\n            style: {\n              \"text-decoration\": \"underline\",\n              \"cursor\": \"pointer\",\n            },\n            onClick: () => {\n              // Shows normal form\n              var norm = fm.lang.stringify(fm.synt.normalize(term, defs));\n              var text = \"\";\n              for (var i = 0; i < norm.length; ++i) {\n                text += norm[i];\n                if (i % 80 === 79) {\n                  text += \"\\n\";\n                }\n              }\n              console.log(text);\n            }\n          }, \"(click to print on console)\"));\n        } catch (e) {\n          var emsg = typeof e === \"function\"\n            ? front.remove_colors(e().msg)\n            : e.toString();\n          argm_divs.push(h(\"pre\", {}, \"\\nError:\\n\" + emsg));\n        }\n      };\n\n      body = h(\"div\", {\n        style: {\n          \"font-family\": \"IBMPlexMono-Light\",\n          \"user-select\": \"none\",\n          \"font-size\": \"16px\",\n          \"color\": \"rgb(41, 42, 44)\",\n        },\n      }, argm_divs);\n    } else {\n      body = h(\"div\", {}, \"...loading...\");\n    };\n\n    return h(\"div\", {\n      style: {\n        \"min-height\": \"calc(100% - 30px)\",\n        \"padding\": \"4px\", //\"display\": \"flex\",\n        //\"flex-flow\": \"row nowrap\",\n        //\"justify-content\": \"center\",\n      },\n    }, [head, body]);\n  }\n};\n\nmodule.exports = Term;\n"],"sourceRoot":""}